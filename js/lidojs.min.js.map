{"version":3,"sources":["webpack://editolido/webpack/universalModuleDefinition","webpack://editolido/./node_modules/ngeohash/main.js","webpack://editolido/webpack/bootstrap","webpack://editolido/webpack/runtime/compat get default export","webpack://editolido/webpack/runtime/define property getters","webpack://editolido/webpack/runtime/hasOwnProperty shorthand","webpack://editolido/webpack/runtime/make namespace object","webpack://editolido/./src/modules/geolite.js","webpack://editolido/./src/modules/geopoint.js","webpack://editolido/./src/modules/kml_constants.js","webpack://editolido/./src/modules/route.js","webpack://editolido/./src/modules/kml_templates.js","webpack://editolido/./src/modules/kml.js","webpack://editolido/./src/modules/ofp_extensions.js","webpack://editolido/./src/modules/iata2icao.js","webpack://editolido/./src/modules/ofp_infos.js","webpack://editolido/./src/modules/ofp.js","webpack://editolido/./src/modules/geoindex.js","webpack://editolido/./src/modules/ogimet.js","webpack://editolido/./src/index.js"],"names":["root","factory","exports","module","define","amd","globalThis","BASE32_CODES","BASE32_CODES_DICT","i","length","charAt","ENCODE_AUTO","MIN_LAT","MAX_LAT","MIN_LON","MAX_LON","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","LatLng","constructor","this","format","v","letters","abs","degrees","floor","rest","minutes","cents","letter","padding","toFixed","padStart","phi","lam","map","PI","PhiLam","R","deg","rad_to_nm","radians","rad_to_deg","nm_to_rad","nm","km_to_rad","km","fmod","b","Number","toPrecision","dm2decimal","s","indexOf","offset","parseInt","slice","parseFloat","array_normalizer","array","dm_normalizer","mixedValue","lng","Array","isArray","arinc_normalizer","label","signed","GeoPoint","name","description","normalizer","latlng","Reflect","has","trim","philam_cache","dm_cache","asPhiLam","asDM","geopoint1","geopoint2","converter","distanceTo","course_to","point","segment","xtd_to","geopoints","options","howMany","x","y","z","p","philam","cosphi","cos","sin","atan2","sqrt","asLatLng","other","phi1","lam1","phi2","lam2","sd","acos","crs_ab","crs_ad","dist_ad","xtd","asin","atFraction","fraction","distance","circle","radius","steps","destination","tc","lat1","lon1","points","equals","toJSON","PIN_NONE","PIN_BLUE","PIN_YELLOW","PIN_BROWN","PIN_ORANGE","PIN_PINK","PIN_RED","PIN_GREEN","PIN_PURPLE","NAT_POSITION_ENTRY","NAT_POSITION_EXIT","PINS","GOOGLEICONS","c","AVENZAICONS","Route","iterator","route2","p1","p2","e","zip","segments","reduce","prev","current","accumulator","maxLength","preserve","remaining","first","maxRadians","segmentLength","Track","isMine","isComplete","super","pointTemplate","style","dm","lineTemplate","coordinates","segmentTemplate","folderTemplate","content","open","template","styles","folders","avenzaTemplate","styleTemplate","id","color","width","avenzaStyleTemplate","googleEarthStyleTemplate","iconTemplate","href","avenzaIconTemplate","pinProp","KMLFolder","linestrings","placemarks","lineStyle","pinId","enabled","empty","newValue","oldStyle","newStyle","KMLGenerator","renderers","Map","icons","text","replace","computeOptions","folderName","folderPinInherit","pin","isNaN","addFolder","folder","set","addFolders","items","String","clone","deleteProperty","addLine","route","renderLine","addPoints","excluded","addPoint","addSegments","render","renderIconTemplate","renderStyleTemplate","renderTemplate","renderIcons","index","renderFolders","renderFolder","renderer","filter","concat","output","isSegment","tpl","changeFolderColor","changeFolderPin","changeFolderState","reset","setName","StringExtractException","extract","start","end","endIsOptional","inclusive","from","to","substring","WptRegExp","RegExp","matchAll","str","result","console","geoPoints","forEach","match","wptRegExp","raw","AIRPORTS","require","IATADB","iata2icao","iata","icao2iata","icao","iata2GeoPoint","data","months3","pdfParsers","freeze","ofpTypes","FISHPOINTS","Ofp","assert","startsWith","pdfParser","pdfjs","ofpType","S4","includes","NVP","infos","pattern","exec","flight","depICAO","destICAO","datetime","ofp","groups","ofpTextDate","day","month","year","hours","ofpOUT","Date","UTC","inFlightReleased","rawFPL","flightNo","callsign","log","flightTime","alternates","ralts","levels","averageFL","rawFS","inFlightStart","InFlightStartETO","taxiTimeOUT","taxiTimeIN","destIATA","depIATA","pld","blockFuel","tripFuel","toUpperCase","groundDistance","scheduledIN","aircraftType","aircraftRegistration","exp","eep","minFuelMarginETOPS","aircraftICAO24","etopsTime","err","etopsSummary","min","m","ofpOFF","getTime","ofpON","ofpIN","ofpInfos","window","alert","exception","removePageFooterRegex","cache","fn","cacheStore","toISOString","wptCoordinates","wptCoordinatesAlternate","end_is_optional","reverse","wptNamesEET","matches","eet","previousEET","previousFL","level","t","fl","results","altname","isMyTrack","fplRoute","trackParser","parserResults","fishPoints","tracks","unknowns","f","trackRoute","trackIsComplete","labelDict","g","geoPoint","fpl","lidoRoute","replaceSID","pointsName","rawPoints","lidoPoints","fplRouteLenght","departure","innerFplRoute","innerFplRouteLength","reversedPoints","reversedLidoRoute","lidoRouteLength","track","fplPoints","needle","trackPoints","splice","recursiveNatReplace","unshift","GEO_HASH_GRID_SIZE","GeoGridIndex","precision","gridSize","toString","centerPoint","suggestedPrecision","maxSize","entries","centerHash","meAndNeighbors","hash","getNearestPointsDirty","ogimetRoute","wmoGrid","segmentSize","algorithm","neighbourRadius","getNeighbour","neighbours","getNearestPoints","sort","findStrategic","k","o_xtd","ogimet","f_xtd","filterByXtd","res","j","ogimetResults","o_index","neighbour","reduceFn","bestXtd","best","maxi","bestDiff","diff","idx","ogimetData","taxitime","ts","now_ts","tref","trefOfp","dateTimeFormat","Intl","DateTimeFormat","hour","minute","formatToParts","hfin","ceil","labels","url","proxy","version","VERSION"],"mappings":"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","file":"lidojs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"editolido\"] = factory();\n\telse\n\t\troot[\"editolido\"] = factory();\n})(globalThis, function() {\nreturn ","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nlam is the longitude in radians (lambda is a reserved name in python)\nphi is the latitude in radians\n\nLatLng is the base object when using degrees\nPhiLam is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {PhiLam} PhiLam - convert to a PhiLam\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asPhiLam() {\n        const [phi, lam] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new PhiLam(phi, lam);\n    }\n}\n\n/**\n * PhiLam\n *\n * @property {number} phi - latitude in radians\n * @property {number} lam - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass PhiLam {\n    constructor(phi, lam) {\n        this.phi = phi;\n        this.lam = lam;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'PhiLam';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.phi, this.lam].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst philam2latlng = (philam) => philam.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\n\nexport {\n    LatLng, PhiLam, philam2latlng, latlng2dm\n};\n","/* eslint-disable max-lines */\nimport {LatLng, PhiLam} from \"./geolite\";\n\n\n// earth mean radius in meters\n// nm in meters\nconst R = 6371000.0;\nconst NM = 1852.0;\nconst deg = 180 / Math.PI;\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst rad_to_deg = (radians) => radians * deg;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\nconst fmod = (a, b) => Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new LatLng(...array);\n    }\n    return new LatLng([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new LatLng(dm2decimal(lat), dm2decimal(lng))\n}\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new LatLng(lat, -lng);\n            case 'E': // NE + +\n                return new LatLng(lat, lng);\n            case 'S': // SE - +\n                return new LatLng(-lat, lng);\n            case 'W': // SW - -\n                return new LatLng(-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new LatLng(lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof LatLng) {\n            this.latlng = mixedValue;\n        } else if (mixedValue && typeof mixedValue === 'object'\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new LatLng(parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.philam_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion PhiLam\n     * @returns {PhiLam}\n     */\n    get philam() {\n        if (this.philam_cache === null) {\n            this.philam_cache = this.latlng.asPhiLam;\n        }\n        return this.philam_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Get the course in radians between to GeoPoints\n     * @param {GeoPoint} geopoint1 start GeoPoint\n     * @param {GeoPoint} geopoint2 end GeoPoint\n     * @returns {number} the course in radians\n     */\n    static course(geopoint1, geopoint2) {\n        return geopoint1.course_to(geopoint2);\n    }\n\n    /**\n     * Given the segment AB, computes cross track error at point D\n     * @param {GeoPoint} point GeoPoint D\n     * @param {[GeoPoint, GeoPoint]} segment segment AB\n     * @param {?function} converter the converter to use\n     * @returns {number} the xtd in radians unless a converter is given\n     */\n    static xtd(point, segment, converter=null) {\n        return point.xtd_to(segment, converter);\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options={}) {\n        let howMany = geopoints.length,\n            lam = 0,\n            phi = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            phi = p.philam.phi;\n            lam = p.philam.lam;\n            let cosphi = Math.cos(phi);\n            x += cosphi * Math.cos(lam);\n            y += cosphi * Math.sin(lam);\n            z += Math.sin(phi);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const sd = Math.acos(\n            Math.sin(phi1) * Math.sin(phi2)\n            + Math.cos(phi1) * Math.cos(phi2) * Math.cos(lam2 - lam1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * Get the course to another point\n     * @param {GeoPoint} other GeoPoint\n     * @returns {number} the course in radian\n     */\n    course_to(other) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        return fmod(\n            Math.atan2(\n                Math.sin(lam1 - lam2) * Math.cos(phi2),\n                Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam1 - lam2)\n            ),\n            2 * Math.PI\n        );\n    }\n\n    /**\n     * Given the segment AB; computes cross track error\n     * @param {[GeoPoint, GeoPoint]} segment the segment AB\n     * @param {?function} converter the converter to use otherwise result in radians\n     * @returns {number} the distance in radian unless a converter is set\n     */\n    xtd_to(segment, converter=null) {\n        const crs_ab = segment[0].course_to(segment[1]);\n        const crs_ad = segment[0].course_to(this);\n        const dist_ad = segment[0].distanceTo(this);\n        const xtd = Math.asin(Math.sin(dist_ad) * Math.sin(crs_ad - crs_ab));\n        if (converter !== null) {\n            return converter(xtd);\n        }\n        return xtd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(phi1) * Math.cos(lam1) + b * Math.cos(phi2) * Math.cos(lam2);\n        const y = a * Math.cos(phi1) * Math.sin(lam1) + b * Math.cos(phi2) * Math.sin(lam2);\n        const z = a * Math.sin(phi1) + b * Math.sin(phi2);\n        const phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n    }\n\n    /**\n     * Return points forming a circle around current points\n     * @param {int} radius distance in radians\n     * @param {int} steps number of points in the circle\n     * @param {function} converter converter to use for the radius\n     */\n    circle(radius, steps=64, converter=nm_to_rad) {\n        if (converter) radius = converter(radius);\n        const destination = (d, tc) => {\n            const lat1 = this.philam.phi;\n            const lon1 = this.philam.lam;\n            const phi = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) *Math.sin(d) * Math.cos(tc));\n            let lam = lon1;\n            if (Math.cos(phi) !== 0) {\n                lam = Math.asin(Math.sin(tc) * Math.sin(d) / Math.cos(phi))\n                if (lon1 - lam < - Math.PI) lam = lon1 + Math.PI; // fix PPT ETOPS circle\n                lam = fmod(lon1 - lam + Math.PI, 2 * Math.PI) - Math.PI;\n            }\n            return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n        }\n        const points = [];\n        for (let i = 0; i <= steps; i += 1) {\n            points.push(destination(radius, i * 2 * Math.PI / steps));\n        }\n        //points.push(points[0]); // close circle\n        return points;\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\nexport {array_normalizer, dm_normalizer, arinc_normalizer, GeoPoint,dm2decimal,km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, rad_to_deg, NM, R};\n","export const PIN_NONE = 0\nexport const PIN_BLUE = 1\nexport const PIN_YELLOW = 2\nexport const PIN_BROWN = 3 // not available in Avenza\nexport const PIN_ORANGE = 4\nexport const PIN_PINK = 5 // not available in Avenza\nexport const PIN_RED = 6\nexport const PIN_GREEN = 7\nexport const PIN_PURPLE = 8\n\nexport const NAT_POSITION_ENTRY = 0\nexport const NAT_POSITION_EXIT = 1\n\nexport const PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nexport const GOOGLEICONS = [\n    '', 'blu', 'ylw',\n    'red', 'orange', 'pink',\n    'red', 'grn', 'purple',\n].map(c => ((c) ? `https://maps.google.com/mapfiles/kml/paddle/${c}-blank.png` : ''));\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nexport const AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png`);\n","import {nm_to_rad, rad_to_nm} from \"./geopoint\";\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {GeoPoint[]}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=rad_to_nm) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} [options.converter] - must transform maxLength in radians\n     * @param {?boolean} [options.preserve] - if false, split at maxLength, do not keep intermediary points\n     * @param {string} [options.name] - generated route name\n     * @param {string} [options.description] - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options = {}){\n        let {converter=nm_to_rad, preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength;\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n\n    /**\n     * Given a track letter, returns the track label used in FPL\n     * @param {string} letter the track letter designator\n     * @return {string} the track label\n     */\n    static label(letter) {\n        return `NAT${letter}`;\n    }\n}\n\nexport {Route, Track};\n","/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nexport const pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nexport const folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nexport const styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nexport const avenzaStyleTemplate = ({id, color, width=3}) => styleTemplate({id, color, width});\nexport const googleEarthStyleTemplate = ({id, color, width=2}) => ((id === 'rnat') ? styleTemplate({id, color, 'width': 1}) : styleTemplate({id, color, width}));\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nexport const iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => ((href) ? `\n    <Style id=\"${id}\">\n      <IconStyle>\n          <Icon>\n              <href><![CDATA[${href}]]></href>\n          </Icon>\n          <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n      </IconStyle>\n    </Style>\\n` : `<Style id=\"${id}\"></Style>\\n`);\n\nexport const avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n","/* eslint-disable max-lines */\nimport {GOOGLEICONS, PINS, PIN_NONE} from \"./kml_constants\";\nimport {\n    folderTemplate, iconTemplate, lineTemplate, pointTemplate, segmentTemplate, styleTemplate, template\n} from \"./kml_templates\";\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? PIN_NONE : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = PINS[this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = PINS[newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || template;\n        this.pointTemplate = renderers.pointTemplate || pointTemplate;\n        this.lineTemplate = renderers.lineTemplate || lineTemplate;\n        this.folderTemplate = renderers.folderTemplate || folderTemplate;\n        this.styleTemplate = renderers.styleTemplate || styleTemplate;\n        this.iconTemplate = renderers.iconTemplate || iconTemplate;\n        this.segmentTemplate = renderers.segmentTemplate || segmentTemplate;\n        this.icons = renderers.icons || GOOGLEICONS;\n        this.name = undefined;\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = PINS[options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} [items.pinId=0] - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = PIN_NONE;\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        const renderIconTemplate = options.iconTemplate || this.iconTemplate;\n        const renderStyleTemplate = options.styleTemplate || this.styleTemplate;\n        const renderTemplate = options.template || this.template;\n        const renderIcons = options.icons || this.icons;\n        PINS.forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': PINS[index].slice(1), 'href': renderIcons[index]};\n                styles += renderIconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += renderStyleTemplate(folder.lineStyle)\n            }\n        }\n        if (!options.name) options.name = this.name;\n        return renderTemplate({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === PIN_NONE || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n    /**\n     * set the default name inserted in template\n     * @param {string} name the name/description\n     */\n    setName(name) {\n        this.name = name;\n    }\n}\n\nexport {KMLGenerator};\n","import {GeoPoint, dm_normalizer} from \"./geopoint\";\n\n/**\n * Exception thrown when a search term is not found\n */\nclass StringExtractException extends Error {}\n\n/**\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nfunction extract(text, start, end, endIsOptional = true, inclusive = false) {\n  let from = 0;\n  let to = 0;\n  if (start) {\n    from = text.indexOf(start);\n    if (from === -1) {\n      throw new StringExtractException(`${start} not found`);\n    }\n    if (!inclusive) {\n      from += start.length;\n    }\n  }\n  if (!end) {\n    return text.substring(from);\n  }\n  to = text.indexOf(end, from);\n  if (to === -1) {\n    if (endIsOptional) {\n      return text.substring(from);\n    }\n    throw new StringExtractException(`${end} not found`);\n  } else if (inclusive) {\n    to += end.length;\n  }\n  return text.substring(from, to);\n}\n\n/**\n * Defines an extract method on the String prototype\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nReflect.defineProperty(String.prototype, 'extract', {\n  value(start, end, endIsOptional = true, inclusive = false) {\n    return extract(this, start, end, endIsOptional, inclusive);\n  }\n});\n\n\n/**\n * A matchAll RegExp to extract WPT COORDINATES from text\n * @return {GeoPoint[]}\n */\nclass WptRegExp extends RegExp {\n\n  /**\n   * matchAll methods to return an array of GeoPoint\n   * @param str\n   * @returns {GeoPoint[]}\n   */\n  [Symbol.matchAll](str) {\n    // eslint-disable-next-line prefer-reflect\n    let result = RegExp.prototype[Symbol.matchAll].call(this, str);\n    if (!result) {\n      console.error(\"WPT Coordinates regexp failed\");\n      return [];\n    }\n    let geoPoints = [];\n    Array.from(result).forEach((match) => {\n      let name = match[1].trim().replace(/^-+/u, \"\");\n      if (name === \"\") {\n        name = match[2] + match[3];\n      }\n      geoPoints.push(\n        new GeoPoint(\n          [match[2], match[3]],\n          {\"name\": name, \"normalizer\": dm_normalizer})\n      );\n    });\n    return geoPoints;\n  }\n}\nconst wptRegExp = new WptRegExp(String.raw`(\\S+|\\s+)\\s+([NS]\\d{4}\\.\\d)([EW]\\d{5}\\.\\d)`, 'gu');\n\nexport {wptRegExp, StringExtractException, extract};\n","import {GeoPoint} from './geopoint';\nconst AIRPORTS = require('./airports.json');\nconst IATADB = require('./iata2icao.json');\n\n/** return icao code for a iata code or '????' */\nexport function iata2icao(iata) {\n    const index = IATADB.indexOf(iata + ':');\n    return (index >= 0) ? IATADB.substring(index + 4, index + 8) : '????';\n}\n\n/** return iata code for a icao code or '???' */\nexport function icao2iata(icao) {\n    const index = IATADB.indexOf(':' + icao);\n    return (index >= 0) ? IATADB.substring(index - 3, index) : '???';\n}\n\n/** return a LatLng from a iata code */\nexport function iata2GeoPoint(iata) {\n    const name = iata2icao(iata);\n    if (name) {\n        const data = AIRPORTS[name];\n        if (data) {\n            return new GeoPoint(data, {name});\n        }\n    }\n    return undefined\n}\n","/* eslint-disable max-lines */\n/* eslint-disable complexity */\n/* eslint-disable max-lines-per-function */\n\nimport {GeoPoint} from './geopoint';\nimport {icao2iata} from './iata2icao';\nconst AIRPORTS = require('./airports');\n\nconst months3 = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n Dictionary of common OFP data:\n - flightNo (AF009)\n - callsign (AFR009)\n - depICAO (KJFK)\n - depIATA IATA departure (JFK)\n - destICAO (LFPG)\n - destIATA IATA destination (CDG)\n - taxiTimeIN (departure taxi time in minutes)\n - taxiTimeOUT (arrival taxi time in minutes)\n - flightTime (ofp flight time in minutes)\n - ofpOUT (a javascript Date object for scheduled departure block time)\n - ofpOFF (ofpOUT + taxiTimeOUT)\n - ofpON (ofpOUT + taxiTimeOUT + flightTime)\n - ofpIN (ofpOUT + taxiTimeOUT + flightTime + taxiTimeIN)\n - scheduledIN (a javascript Date object for scheduled arrival block time)\n - ofp (OFP number 9/0/1)\n - alternates an array of alternate names\n - ralts an array of route alternate names (ETOPS)\n - rawFPL the raw text of the FPL\n - EEP the airport related to the ETOPS entry GeoPoint\n - EXP the airport related to the ETOPS exit GeoPoint\n - raltPoints the ETOPS airports as GeoPoint\n - maxETOPS the ETOPS time in minutes\n - minFuelMarginETOPS minimum fuel margin in T (extracted from ETOPS SUMMARY)\n - averageFL average flight level or 300\n - levels = array of flight levels found in FPL or [300]\n - payload in T\n - tripFuel in T\n - blockFuel in T\n - inFlightReleased is true when the OFP is released while in flight\n - inFlightStart is the start point name for ofp released in flight\n * @param text The OFP in text format\n * @returns {{flightNo: string, callsign: string, depICAO: string, depIATA: string, destICAO: string, destIATA: string, taxiTimeOUT: number, taxiTimeIN: number, ofpOUT: Date, ofpOFF: Date, ofpON: Date, ofpIN: Date, scheduledIN: Date, ofp: string, ralts: [] alternates: [], rawFPL: string, EEP: GeoPoint, EXP: GeoPoint, raltPoints: [GeoPoint], maxETOPS: number, fl: number, levels: [number], tripFuel: number, blockFuel: number, payload: number, inFlightReleased: boolean, inFlightStart: string}}\n */\nfunction ofpInfos(text) {\n  let pattern = /(?<flight>AF\\s+\\S+\\s+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\d+\\S{0,8})/u;\n  let match = pattern.exec(text);\n  if (match === null) {\n    pattern = /(?<flight>AF.+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\S+)Main/u;\n    match = pattern.exec(text);\n  }\n  let {flight, depICAO, destICAO, datetime, ofp} = match.groups;\n  // datetime is like 27Sep2019/1450\n  const [ofpTextDate] = datetime.split('/', 1);\n  const day = parseInt(datetime.substring(0,2), 10);\n  const month = months3.indexOf(datetime.substring(2,5));\n  const year = parseInt(datetime.substring(5,9), 10);\n  const hours = parseInt(datetime.substring(10,12), 10);\n  const minutes = parseInt(datetime.substring(12,14), 10);\n  const ofpOUT = new Date(Date.UTC(year, month, day, hours, minutes));\n  const inFlightReleased = text.indexOf(\"Inflight Released\") >= 0;\n\n  const rawFPL = text\n    .extract(\"ATC FLIGHT PLAN\", \"TRACKSNAT\")\n    .extract(\"(\", \")\", false, true);\n  const flightNo = flight.replace(/\\s/gu, \"\");\n  let callsign = flightNo;\n  pattern = /\\(FPL-([^-]+)-/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      callsign = match[1];\n  }\n\n  pattern = new RegExp(String.raw`(?:-TRIP|SUMMARYTRIP)\\s+[0-9]+[\\s.]+(\\d{2})(\\d{2})\\s`, \"u\");\n  match = pattern.exec(text);\n  if (match === null){\n    pattern = new RegExp(String.raw`-${destICAO}(\\d{2})(\\d{2})\\s`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match === null) {\n      console.log(\"flight duration not found, arbitrary set to 1 hour\");\n    } else {\n      console.log(\"trip time not found, using fpl flight time\");\n    }\n  }\n  const flightTime = (match) ? parseInt(match[2], 10) + 60 * parseInt(match[1], 10) : 60;\n\n  // try with 2 alternates first\n  pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n  match = pattern.exec(rawFPL);\n  let alternates = [];\n  if (match !== null){\n    alternates.push(match[1]);\n    alternates.push(match[2]);\n  } else {\n    pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match !== null) {\n      alternates.push(match[1]);\n    }\n  }\n\n  pattern = /RALT\\/((?:\\S{4}[ \\n])+)/u;\n  match = pattern.exec(rawFPL);\n  let ralts = [];\n  if (match !== null) {\n    ralts = match[1].trim().split(/\\s/u);\n  }\n\n  let levels = [...rawFPL.matchAll(/F(\\d{3})\\s/ug)].map(v => (v[1]*1));\n  let averageFL = 300;\n  if (levels && levels.length) {\n      averageFL = Math.round(levels.reduce((a, b) => a + b, 0) / levels.length);\n  } else {\n    levels = [averageFL];\n  }\n  const rawFS = text.extract(\"FLIGHT SUMMARY\", \"Generated\");\n  // eslint-disable-next-line init-declarations\n  let inFlightStart;\n  // eslint-disable-next-line init-declarations\n  let InFlightStartETO;\n  if (inFlightReleased) {\n    pattern = new RegExp(String.raw`ATC:${callsign}\\s+(\\S+)\\s+\\d{4}\\s+\\.{4}\\s+(\\d{2})(\\d{2})`, \"u\");\n    match = pattern.exec(rawFS);\n    if (match) {\n      inFlightStart = match[1];\n      InFlightStartETO = new Date(Date.UTC(year, month, day, parseInt(match[2], 10), parseInt(match[3], 10)))\n    }\n  }\n  pattern = /\\s(\\d{2})(\\d{2})\\s+TAXI IN/u;\n  match = pattern.exec(rawFS);\n  let taxiTimeOUT = 15;\n  if (match === null) {\n    console.log(\"taxiTimeOUT not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeOUT = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  let taxiTimeIN= 15;\n  pattern = /\\/\\s+(\\d{2})(\\d{2})MIN/u;\n  match = pattern.exec(rawFS);\n  if (match === null) {\n    console.log(\"arrival taxitime not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeIN = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  pattern = new RegExp(String.raw`\\s${destICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const destIATA = (match) ? match[1] : '';\n  pattern = new RegExp(String.raw`\\s${depICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const depIATA = (match) ? match[1] : icao2iata(depICAO);\n  pattern = /\\.PLD\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const pld = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\.BLOCK\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const blockFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\|TRIP\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const tripFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = new RegExp(String.raw`GND DIST\\s+(\\d+)${ofpTextDate.toUpperCase().substring(0,5)}`, \"u\");\n  match = pattern.exec(rawFS);\n  const groundDistance = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\s+STA\\s+([0-9]{4})/u;\n  match = pattern.exec(rawFS);\n  let scheduledIN = (match) ? new Date(Date.UTC(year, month, day, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10))): null;\n  if (scheduledIN && scheduledIN < ofpOUT) {\n    scheduledIN = new Date(Date.UTC(year, month, day + 1, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10)));\n  }\n  //aircraft type\n  let aircraftType = \"???\";\n  const aircraftTypes = { // convert to Oliver Ravet codes\n    'A388': '380',\n    'B772': '772',\n    'B773': '773',\n    'B77W': '773',\n    'B77L': '77F',\n    'B788': '787',\n    'B789': '787',\n    'B78X': '787',\n    'A318': '318',\n    'A319': '319',\n    'A320': '320',\n    'A321': '321',\n    'A332': '330',\n    'A333': '330',\n    'A338': '330',\n    'A339': '330',\n    'A342': '340',\n    'A343': '340',\n    'A344': '340',\n    'A345': '340',\n    'A346': '340',\n    'A359': '350',\n    'A35K': '350'\n  }\n  pattern = /-([AB][0-9]{2}.)\\//u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftType = aircraftTypes[match[1]] || '???';\n  }\n  // aircraft registration\n  let aircraftRegistration = '';\n  pattern = /REG\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftRegistration = match[1][0] + '-' + match[1].slice(1);\n  }\n  // icao24\n  let aircraftICAO24 = '';\n  pattern = /CODE\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n    aircraftICAO24 = match[1];\n  }\n  // eslint-disable-next-line init-declarations\n  let exp;\n  // eslint-disable-next-line init-declarations\n  let eep;\n  // eslint-disable-next-line init-declarations\n  let minFuelMarginETOPS;\n  let etopsTime = 0;\n  if (ralts.length > 0) {\n      pattern = /ETOPS\\s+(\\d{3})\\s/u\n      match = pattern.exec(rawFS);\n      if (match) {\n        etopsTime = parseInt(match[1], 10);\n      } else {\n        try {\n          match = pattern.exec(text.extract('FPL SUMMARY', 'Generated'));\n          if (match) {\n            etopsTime = parseInt(match[1], 10);\n          }\n        } catch (err) {\n          console.log(\"ETOPS range not found\");\n        }\n      }\n      const etopsSummary = text.extract(\"ETOPS SUMMARY\", \"Generated\");\n      pattern = /EEP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        eep = match[1];\n      }\n      pattern = /EXP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        exp = match[1];\n      }\n      pattern = /ETO\\.{4}\\s+([\\d.]+)\\/EFOB\\s([\\d.]+)/gu;\n      minFuelMarginETOPS = Math.min(...Array.from(etopsSummary.matchAll(pattern), m => parseFloat(m[2]) - parseFloat(m[1])));\n  }\n\n  const ofpOFF = (!InFlightStartETO) ? new Date(ofpOUT.getTime() + taxiTimeOUT * 60000) : InFlightStartETO;\n  const ofpON = new Date(ofpOFF.getTime() + flightTime * 60000);\n  const ofpIN = new Date(ofpON.getTime() + taxiTimeIN * 60000);\n\n  const infos = {\n    //\"flight\": flightNo, /*deprecated */\n    flightNo,\n    callsign,\n\n    //\"departure\": depICAO, /*deprecated */\n    //\"dep3\": depIATA, /*deprecated */\n    \"depICAO\": depICAO,\n    \"depIATA\": depIATA,\n\n    //\"destination\": destICAO, /*deprecated */\n    //\"des3\": destIATA, /*deprecated */\n    \"destICAO\": destICAO,\n    \"destIATA\": destIATA,\n\n    //\"datetime\": ofpOUT, /*deprecated */\n    //\"STD\": ofpOUT, /*deprecated */\n    //\"takeoff\": ofpOFF, /*deprecated */\n    //\"landing\": ofpON, /*deprecated */\n    //\"station\": scheduledIN, /*deprecated */\n    //\"STA\": scheduledIN, /*deprecated */\n    //\"datetime2\": ofpIN, /*deprecated */\n    ofpOUT,\n    ofpOFF,\n    ofpON,\n    ofpIN,\n    scheduledIN,\n    \"flightTime\": (ofpON.getTime() - ofpOFF.getTime()) / 60000,\n    \"blockTime\": (ofpIN.getTime() - ofpOUT.getTime()) / 60000,\n    \"scheduledBlockTime\": (scheduledIN) ? (scheduledIN.getTime() - ofpOUT.getTime()) / 60000 : 0,\n    //\"date\": ofpTextDate, /* deprecated */\n    ofpTextDate,\n    \"ofp\": ofp.replace(\"\\xA9\", \"\"),\n    //\"duration\": duration,  /*deprecated */\n    \"alternates\": alternates,\n    \"ralts\": ralts,\n    \"raltPoints\": [],\n    //\"taxitime\": taxiTimeOUT, /*deprecated */\n    //\"taxitime2\": taxiTimeIN, /*deprecated */\n    taxiTimeOUT,\n    taxiTimeIN,\n    //\"rawfpl\": rawFPL,/*deprecated */\n    rawFPL,\n    //\"aircraft\": aircraftType,  /*deprecated */\n    aircraftType,\n    //\"registration\": aircraftRegistration,  /*deprecated */\n    aircraftRegistration,\n    //\"icao24\": aircraftICAO24,  /*deprecated */\n    aircraftICAO24,\n    \"EEP\": null,\n    \"EXP\": null,\n    //\"ETOPS\": etopsTime,  /*deprecated */\n    \"maxETOPS\": etopsTime,\n    minFuelMarginETOPS,\n    averageFL,\n    levels,\n    \"payload\": pld / 1000,\n    \"tripFuel\": tripFuel / 1000,\n    \"blockFuel\": blockFuel / 1000,\n    groundDistance,\n    inFlightReleased,\n    inFlightStart\n  }\n  try {\n    infos['raltPoints'] = [];\n    for (const v of ralts) {\n      if (v && AIRPORTS[v]) {\n        infos['raltPoints'].push(new GeoPoint(AIRPORTS[v], {'name': v, 'description': 'ETOPS'}));\n      } else {\n        console.error('missing airport', v);\n      }\n    }\n    if (eep && AIRPORTS[eep]) {\n      infos['EEP'] = new GeoPoint(AIRPORTS[eep], {'name': eep, 'description': 'EEP'});\n    } else if (eep){\n      console.error('missing airport', eep);\n    }\n    if (exp && AIRPORTS[exp]) {\n      infos['EXP'] = new GeoPoint(AIRPORTS[exp], {'name': exp, 'description': 'EXP'});\n    } else if (exp){\n      console.error('missing airport', exp);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n  return infos\n}\nexport {ofpInfos, months3};\n","/* eslint-disable no-underscore-dangle,max-lines-per-function, max-lines */\n\nimport {GeoPoint, arinc_normalizer} from \"./geopoint\";\nimport {Route, Track} from \"./route\";\nimport {wptRegExp} from \"./ofp_extensions\";\n// eslint-disable-next-line sort-imports\nimport {ofpInfos} from \"./ofp_infos\";\n\n\nconst pdfParsers = Object.freeze({\n  \"pypdf2\": 3,\n  \"pdfjs\": 4\n});\n\nconst ofpTypes = Object.freeze({\n  \"S4\": 1,\n  \"NVP\": 2\n});\n\nconst FISHPOINTS = require('./fishpoints');\n\nexport class Ofp {\n  constructor(text=\"\") {\n    console.assert(text.startsWith(\"_PDFJS_\"), \"invalid text file\");\n    this.pdfParser = pdfParsers.pdfjs;\n    this.ofpType = ofpTypes.S4;\n    if (text.includes(\"--FLIGHT SUMMARY--\")) {\n      this.ofpType = ofpTypes.NVP;\n    }\n    try {\n      this.infos = ofpInfos(text);\n    } catch (error) {\n      console.error(error);\n      try {\n        if (window) {\n          // eslint-disable-next-line no-alert\n          window.alert(`Erreur: {error}` )\n        }\n      } catch (exception) {\n        // not in browser, just log\n      }\n      throw error;\n    }\n    this.removePageFooterRegex = new RegExp(String.raw`([\\s-]\\d{1,2})?Page\\s[0-9]+\\s.+?Page\\s[0-9]+.+?\\/${this.infos['depICAO']}-${this.infos['destICAO']}`, 'gsu');\n    this.text = text.replace(this.removePageFooterRegex,'');\n    this.cache = function (name, fn) {\n      if (this.cacheStore === undefined) {\n        this.cacheStore = {}; /* on first run create cache storage */\n      }\n      if (this.cacheStore[name] === undefined) {\n        this.cacheStore[name] = fn();\n      }\n      return this.cacheStore[name];\n    };\n  }\n\n  get description() {\n    const infos = this.infos;\n    return `${infos.flightNo} ${infos.depICAO}-${infos.destICAO} ${infos.ofpTextDate} ${infos.ofpOUT.toISOString().substring(11,16)}z OFP ${infos.ofp}`;\n  }\n\n  /**\n   * Array of WPT COORDINATES found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinates(start=\"WPT COORDINATES\") {\n    const infos = this.infos;\n    const end = (this.ofpType === ofpTypes.NVP) ? '----' + infos['destICAO']: '----';\n    const extract = this.text.extract(start, end);\n    const geoPoints = extract.matchAll(wptRegExp);\n    if (geoPoints.length > 0) {\n      if (!infos.inFlightReleased) {\n        geoPoints[0].name = this.infos['depICAO']; // avoid name problems\n      } else if (infos.inFlightStart) {\n        geoPoints[0].name = infos.inFlightStart;\n      }\n    }\n    return geoPoints;\n  }\n\n  /**\n   * Array of WPT COORDINATES for alternate found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinatesAlternate(start='WPT COORDINATES', end_is_optional=false) {\n\n    const end = (this.ofpType === ofpTypes.NVP) ? '--WIND INFORMATION--': 'ATC FLIGHT PLAN';\n    // take only what is after the last '----' (python rsplit)\n    // eslint-disable-next-line require-jsdoc\n    function reverse(str) {\n      return [...str].reverse().join('');\n    }\n    const t = this.text.extract(start, end, end_is_optional)\n    const extract = reverse(t).split('----', 1)[0];\n    return reverse(extract).matchAll(wptRegExp);\n  }\n\n  wptNamesEET(geoPoints) {\n    const start = 'ATC DEPARTURE';\n    const pattern = /[\\s-]([A-Z0-9/]+)\\s+[0-9]{3}\\s+(?:[0-9.\\s]{4})\\s+\\.\\.\\.\\.\\/\\.\\.\\.\\.\\s(.{3})\\s[A-Z0-9/.+\\s-]+?[0-9]{4}\\/([0-9]{4})\\s+[0-9]{3}\\/[0-9]{3}/gu;\n    const extract = this.text.extract(start, 'DESTINATION ALTERNATE', true);\n    const matches = extract.matchAll(pattern);\n\n    const eet = {};\n    let previousEET = 0;\n    // eslint-disable-next-line init-declarations\n    let previousFL = this.infos.levels[0];\n    for (let [,name, level, t,] of matches) {\n      //console.log(name)\n      if (name.startsWith('/')) name = name.slice(1); // ofp AF082\n      const fl = parseInt(level, 10);\n      if (!isNaN(fl)) previousFL = fl;\n      eet[name.split('/')[0]] = [previousEET, previousFL];\n      previousEET = (parseFloat(t.slice(0,2)) * 60) + parseFloat(t.slice(2))\n    }\n    eet[this.infos['destICAO']] = [previousEET, previousFL];\n    //console.log(eet);\n    const results = [];\n    let error = false;\n    for (const p of geoPoints) {\n      if (eet[p.name] === undefined) {\n          let altname = p.name.replace(/00\\.0/gu,'')\n          if (eet[altname] === undefined) {\n              altname = p.name.replace(/\\.0/gu,'')\n              if (eet[altname] === undefined) {\n                console.log('missing point', p.name);\n                error = true;\n                break;\n              } else {\n                results.push([p, ...eet[altname]]);\n              }\n          } else {\n            results.push([p, ...eet[altname]])\n          }\n      } else {\n          results.push([p, ...eet[p.name]])\n      }\n    }\n    return (error) ? [] : results;\n  }\n\n  /**\n   * check if the designated track is in the FPL\n   * @param letter\n   * @returns {boolean}\n   */\n  isMyTrack(letter) {\n    return this.fplRoute.indexOf(Track.label(letter)) !== -1;\n  }\n\n  /**\n   * Parse the OFP and return tracks as an array of [trackLetter, trackDescription]\n   * @returns {[]}\n   */\n  trackParser() {\n    let extract = \"\";\n    try {\n      extract = this.text\n        .extract(\"ATC FLIGHT PLAN\", \"NOTES:\").extract(')');\n    } catch (e) {\n      return [];\n    }\n    let results = [];\n    if (extract.includes(\"REMARKS:\")) {\n      extract = extract.split(\"REMARKS:\", 1)[0];\n      extract = extract.split(\"Generated at\", 1)[0];\n    }\n    if (extract.includes(\" LVLS \")) {\n      // split at track letter, discard first part\n      const a = extract.split(/(?:\\s|[^A-Z\\d])([A-Z])\\s{3}/gu).slice(1);\n      // results are [trackLetter, trackDescription]\n      for (let i = 0, max = a.length; i < max; i += 2) {\n        results.push([a[i], a[i + 1]]);\n      }\n    } else if (extract.includes('TRACKS')) {\n      console.error(\"Unknown TRACKSNAT message format\");\n      console.log(extract);\n    }\n    return results;\n  }\n\n  /**\n   * Tracks found in the OFP as an array of Track\n   * @returns {Track[]}\n   */\n  get tracks() {\n    return this.cache(\"tracks\", () => {\n      let parserResults = this.trackParser();\n      const pattern = /(\\d{2,4}[NS]\\d{3,5}[EW]|[NESW]\\d{4}|\\d[NESW]\\d{3}[^EW])/u;\n      let fishPoints = {};\n      let tracks = [];\n\n      //find unknows named waypoints in tracks\n      let unknowns = [];\n      // eslint-disable-next-line array-callback-return\n      parserResults.map(([, description]) => {\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) === null) {\n                unknowns.push(label);\n              }\n            }\n          });\n      });\n      // console.debug(`Unknown track points: ${unknowns}`);\n      unknowns.forEach((name) => {\n        const f = FISHPOINTS[name];\n        if (f !== undefined) {\n          fishPoints[name] = new GeoPoint(f, {\"name\": name});\n        }\n      });\n\n      parserResults.forEach(([letter, description]) => {\n        let trackRoute = [];\n        let trackIsComplete = true;\n        const isMine = this.isMyTrack(letter);\n        let labelDict = (isMine) ? {} : fishPoints;\n        if (isMine) {\n          this.route.points.forEach((g) => {\n            if (g.name !== \"\") {\n              labelDict[g.name] = g\n            }\n          })\n        }\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) !== null) {\n                trackRoute.push(new GeoPoint(label, {\n                  \"name\": label,\n                  \"normalizer\": arinc_normalizer\n                }));\n              } else {\n                let geoPoint = labelDict[label];\n                if (geoPoint !== undefined) {\n                  trackRoute.push(new GeoPoint(geoPoint, {\"name\": label}));\n                } else {\n                  trackIsComplete = false;\n                }\n              }\n            }\n          });\n        tracks.push(new Track(trackRoute,\n          {\n            \"name\": `NAT ${letter}`,\n            \"description\": description,\n            \"isMine\": isMine,\n            \"isComplete\": trackIsComplete\n          }));\n      });\n      return tracks;\n    });\n  }\n\n  /**\n   * Returns FPL as an Array\n   * @returns {string[]}\n   */\n  fpl() {\n    const infos = this.infos;\n    let text = infos.rawFPL.extract(`-${infos.depICAO}`, `-${infos.destICAO}`, false);\n    text = text.substring(text.indexOf(\" \") + 1);\n    let results = [infos.depICAO];\n    text.split(\" \").map((v) => v.trim())\n      .forEach((v) => {\n        if (v !== \"\" && !v.startsWith(\"-N\")){\n          results.push(v);\n        }\n      });\n    results.push(infos.destICAO);\n    return results;\n  }\n\n  /**\n   * FPL route found in OFP (fpl without speed/FL annotations)\n   * @returns {string[]}\n   */\n  get fplRoute() {\n    return this.cache(\"fplRoute\",\n      () => this.fpl().map((p) => {\n        if (p.includes(\"/\")) {\n          return p.split(\"/\", 1)[0];\n        }\n        return p;\n      })\n    );\n  }\n\n  get route() {\n    return this.cache(\"route\", () => new Route(this.wptCoordinates()));\n  }\n\n  lidoRoute(replaceSID=true) {\n    return this.cache(\"lidoRoute\" + ((replaceSID) ? \"_r\" : \"\"), () => {\n      const points = [];\n      const pointsName = []; // used if replaceSID === false\n      const rawPoints = []; // used if replaceSID === true\n      this.route.points.forEach((p) => {\n        rawPoints.push(p.dm);\n        pointsName.push(p.name || p.dm);\n        if (p.name === \"\" || (/\\d+/u).exec(p.name) !== null) {\n          points.push(p.dm);\n        } else {\n          points.push(p.name);\n        }\n      });\n      let lidoPoints = [];\n\n      let fplRoute = this.fplRoute;\n      let fplRouteLenght = fplRoute.length;\n      if (fplRouteLenght < 2) {\n        return points;\n      }\n      let departure = fplRoute[0];\n      let destination = fplRoute[fplRouteLenght - 1];\n      let innerFplRoute = fplRoute.slice(1, -1);\n      let innerFplRouteLength = innerFplRoute.length;\n\n\n      // replace points by rawPoint before first common waypoint\n      for (let i = 0; i < innerFplRouteLength; i += 1 ) {\n        let p = innerFplRoute[i];\n        let offset = points.indexOf(p);\n        if (offset !== -1) {\n          if (replaceSID) {\n            lidoPoints = rawPoints.slice(1, offset).concat(innerFplRoute.slice(i));\n          } else {\n            lidoPoints = pointsName.slice(1, offset).concat(innerFplRoute.slice(i));\n          }\n          break;\n        }\n      }\n      // replace points after last common waypoint by rawPoints\n      let reversedPoints = points.slice().reverse(); // copy before reverse\n      let reversedLidoRoute = lidoPoints.slice().reverse();\n      let lidoRouteLength = lidoPoints.length;\n      for (let i = 0; i < lidoRouteLength; i += 1 ) {\n        let p = reversedLidoRoute[i];\n        let offset = reversedPoints.indexOf(p);\n        if (offset !== -1) {\n          if (i > 0) {\n            lidoPoints = lidoPoints.slice(0, -i);\n          }\n          if (replaceSID) {\n            lidoPoints = lidoPoints.concat(rawPoints.slice(-offset, -1));\n          } else {\n            lidoPoints = lidoPoints.concat(pointsName.slice(-offset, -1));\n          }\n          break;\n        }\n      }\n      // replace known tracks (NATA, NATB...) by track_points\n      /**\n       * When there is a FL or Speed change, we may have multiple\n       * \"NATW\" in the FPL, so change them all.\n       * @param fplPoints: [] - an array of fplPoints\n       * @param needle: string\n       * @param trackPoints\n       * @returns {[]}\n       */\n      const recursiveNatReplace = function (fplPoints, needle, trackPoints) {\n        let match = [];\n        // infinite loop (while(true) breaks in browser)\n        // https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript\n        for (;;) {\n          let offset = fplPoints.indexOf(needle);\n          if (offset === -1) {\n            return match;\n          }\n          fplPoints.splice(offset, 1, ...trackPoints.slice(\n            trackPoints.indexOf(fplPoints[offset - 1]) +1,\n            trackPoints.indexOf(fplPoints[offset + 1])));\n          match = fplPoints;\n        }\n      };\n\n      this.tracks.forEach( (track) => {\n        if (track.isMine) {\n          let letter = track.name.slice(-1);\n          let results = recursiveNatReplace(\n            lidoPoints,\n            Track.label(letter),\n            track.points.map((p) => p.name)\n          );\n          if (results.length > 0) {\n            lidoPoints = results;\n          }\n        }\n      });\n      lidoPoints.push(destination);\n      lidoPoints.unshift((!this.infos.inFlightStart) ? departure : this.infos.inFlightStart);\n      // adds alternates and ralts\n      lidoPoints = lidoPoints.concat(...this.infos.alternates);\n      lidoPoints= lidoPoints.concat(...this.infos.ralts);\n      return lidoPoints;\n    });\n  }\n}\n","import {GeoPoint, km_to_rad} from \"./geopoint\";\nimport geohash from \"ngeohash\";\n\n// dependence between hashtag's precision and distance accurate calculating\n// in fact it's sizes of grids in km\nexport const GEO_HASH_GRID_SIZE = {\n    \"1\": 5000.0,\n    \"2\": 1260.0,\n    \"3\": 156.0,\n    \"4\": 40.0,\n    \"5\": 4.8,\n    \"6\": 1.22,\n    \"7\": 0.152,\n    \"8\": 0.038\n}\n\nexport class GeoGridIndex {\n    constructor(precision=3) {\n        this.precision = precision;\n        this.gridSize = km_to_rad(GEO_HASH_GRID_SIZE[precision.toString()]);\n        this.data = {};\n    }\n\n    /**\n     * Get Nearest points based on the geohash of the point\n     * It returns all wmo points in the 9 adjacents tiles\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians (unless a converter is given)\n     * @param {?function} converter\n     * @generator {GeoPoint}\n     */\n    *getNearestPointsDirty(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        if (radius > this.gridSize / 2.0) {\n            // radius is too big for current grid, we cannot use 9 neighbors\n            // to cover all possible points\n            let suggestedPrecision = 0;\n            for (const [precision, maxSize] of Object.entries(GEO_HASH_GRID_SIZE)) {\n                if (radius > km_to_rad(maxSize) / 2.0) {\n                    suggestedPrecision = parseInt(precision, 10) - 1;\n                    break;\n                }\n            }\n            throw new Error(`Too large radius, please rebuild GeoHashGrid with precision=\"${suggestedPrecision}\"`);\n        }\n        const centerHash = geohash.encode(centerPoint.latitude, centerPoint.longitude, this.precision);\n        let meAndNeighbors = geohash.neighbors(centerHash);\n        meAndNeighbors.push(centerHash);\n        for (const hash of meAndNeighbors) {\n            if (hash in this.data) {\n                for (const [name, latitude, longitude] of this.data[hash]) {\n                    yield new GeoPoint([latitude, longitude], {\"name\": name});\n                }\n            }\n        }\n    }\n\n    /**\n     * find nearest wmo points. Returns an array of [[distance, GeoPoint]]\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians unless a converter is set\n     * @param {?function} converter fn return radians\n     * @returns {{[number, GeoPoint]}} distance from centerPoint and a GeoPoint of the wmo\n     */\n    *getNearestPoints(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        for (const geoPoint of this.getNearestPointsDirty(centerPoint, radius, null)) {\n            let distance = geoPoint.distanceTo(centerPoint, null);\n            if (distance <= radius) {\n                if (converter !== null) {\n                    distance /= converter(1.0);\n                }\n                yield [geoPoint, distance];\n            }\n        }\n    }\n}\n","/* eslint-disable max-lines-per-function */\nimport {km_to_rad, rad_to_km} from \"./geopoint\";\nimport {Route} from \"./route\";\n\n/**\n * Compute the Ogimet Route\n * @param {editolido.Route} route the route to find the ogimet route for\n * @param {number} segmentSize the result is split to this length\n * @param {string} name the name of the returned route\n * @param {string} description the description of the returned route\n */\nexport function ogimetRoute(wmoGrid, route, {name=\"\", description=\"\", segmentSize=300, algorithm='xtd'} = {}) {\n    const neighbourRadius = (rad_to_km(wmoGrid.gridSize) / 2.0) - 0.1\n\n    const getNeighbour = (point) => {\n        let neighbours = [...wmoGrid.getNearestPoints(point, neighbourRadius)];\n        if (neighbours.length > 0) {\n            neighbours = neighbours.sort((a, b) => a[1] - b[1]);\n            if (neighbours.map((a) => a[0].name).indexOf(point.name) >= 0) {\n                return [point, 0];\n            }\n            return [neighbours[0][0], neighbours[0][1]];\n        }\n        return [null, null];\n    };\n    const findStrategic = (start, end, results) => {\n        const length = results.length;\n        for (let k = end - 1; k > start; k -= 1) {\n            const o_xtd = results[k].ogimet.xtd_to(\n                [results[k].fpl, results[k + 1].fpl]\n            );\n            const f_xtd = results[k].fpl.xtd_to(\n                [results[start].ogimet, results[end].ogimet]\n            )\n            if (Math.abs(f_xtd) > Math.abs(o_xtd)) {\n                const d = (k < length - 1) ? results[k].fpl.distanceTo(results[k+1].fpl) : -1;\n                if (Math.abs(f_xtd) < d || d < 0) return k;\n            }\n        }\n        return null;\n    };\n\n    const filterByXtd = (results) => {\n        if (results.length === 0) return [];\n        const res = [results[0]];\n        let i = -1;\n        while (i < results.length - 1) {\n            i += 1;\n            let j = i + 2;\n            while (j <= results.length - 1) {\n                let k = findStrategic(i, j, results);\n                if (k === null) {\n                    j += 1;\n                } else {\n                    if (res.map((r) => r.ogimet.name).indexOf(results[k].ogimet.name) < 0) {\n                        res.push(results[k]);\n                    }\n                    i = k - 1;\n                    break;\n                }\n            }\n        }\n        res.push(results[results.length - 1]);\n        if (res.length < results.length) {\n            return filterByXtd(res);\n        }\n        return res;\n    };\n\n    // eslint-disable-next-line no-unused-vars\n    const lowestCrsIndex = (results) => {\n        let bestDiff = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const diff = Math.abs(\n                results[i - 1].ogimet.course_to(results[i].ogimet)\n                - results[i - 1].ogimet.course_to(results[i+1].ogimet)\n            );\n            if (best === null || diff < bestDiff) {\n                best = i;\n                bestDiff = diff;\n            }\n        }\n        return best;\n    };\n\n    const lowestXtdIndex = (results) => {\n        let bestXtd = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const xtd = Math.abs(\n                results[i].fpl.xtd_to([results[i - 1].ogimet, results[i + 1].ogimet])\n            );\n            if (best === null || xtd < bestXtd) {\n                best = i;\n                bestXtd = xtd;\n            }\n        }\n        return best;\n    }\n\n    let ogimetResults = [];\n    const o_index = {};\n    for (const p of route.split(60, {'converter': km_to_rad, 'preserve': true}).points) {\n        const [neighbour, x] = getNeighbour(p);\n        if (neighbour !== null) {\n            if (neighbour.name in o_index) {\n                if (o_index[neighbour.name][0] > x) {\n                    o_index[neighbour.name] = [x, p];\n                }\n            } else {\n                o_index[neighbour.name] = [x, p];\n            }\n            ogimetResults.push({'fpl': p, 'ogimet': neighbour});\n        }\n    }\n\n    // eslint-disable-next-line eqeqeq\n    ogimetResults = ogimetResults.filter((r) => o_index[r.ogimet.name][1] == r.fpl);\n    ogimetResults = filterByXtd(ogimetResults);\n    //console.log(ogimetResults.length);\n    const reduceFn = (algorithm === 'xtd' ? lowestXtdIndex: lowestCrsIndex);\n    while (ogimetResults.length > 21) {\n        const idx = reduceFn(ogimetResults);\n        ogimetResults = ogimetResults.slice(0, idx).concat(ogimetResults.slice(idx + 1));\n    }\n    return new Route(ogimetResults.map((r) => r.ogimet))\n                .split(segmentSize, {'preserve': true, 'name': name, 'description': description});\n}\n\n/**\n * Computes ogimet url\n * @param {editolido.OFP} ofp the OFP\n * @param {editolido.GeoGridIndex} wmoGrid  the loaded Grid\n */\nexport function ogimetData(ofp, wmoGrid, algorithm=\"xtd\") {\n    // timestamp for departure\n    const taxitime = ofp.infos['taxiTimeOUT'];\n    const ts = (ofp.infos['ofpOUT'].getTime() / 1000) + (taxitime * 60);\n    const now_ts = (new Date()).getTime() / 1000;\n    const tref = Math.round(Math.max(ts, now_ts)); //for old ofp timeref=now\n    const trefOfp = new Date(Math.round(ts) * 1000);\n    // const dateref = new Date(tref * 1000); //for caching we use the ofp time instead\n    // https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\n    const dateTimeFormat = new Intl.DateTimeFormat('en', {'year': '2-digit', 'month': 'short', 'day': '2-digit', 'hour': '2-digit', 'minute': '2-digit', 'hourCycle': 'h24', 'timeZone': 'UTC'});\n    const [{'value': month},,{'value': day},,{'value': year},,{'value': hour},,{'value': minute}] = dateTimeFormat.formatToParts(trefOfp);\n    const name = `Route Gramet ${ofp.infos['flightNo']} ${ofp.infos['depICAO']}-${ofp.infos['destICAO']} ${day}${month}${year} ${hour}:${minute}z OFP ${ofp.infos['ofp']}`;\n    let hini = 0;\n    let hfin = Math.ceil(ofp.infos.flightTime / 60);\n    const fl = ofp.infos.averageFL;\n    const route = ogimetRoute(wmoGrid, ofp.route,{name, algorithm});\n    const labels = route.points.filter(p => p.name !== \"\").map(p => p.name);\n    route.description = labels.join(' ');\n    const url = `http://www.ogimet.com/display_gramet.php?lang=en&hini=${hini}&tref=${tref}&hfin=${hfin}&fl=${fl}&hl=3000&aero=yes&wmo=${labels.join('_')}&submit=submit`;\n    const proxy = `${hini}-${Math.round(ts)}-${hfin}-${fl}-${labels.join('_')}`;\n    return {tref, name, route, 'wmo': labels, url, proxy};\n}\n","/* globals VERSION */\nexport const version = VERSION;\nexport {GeoPoint, nm_to_rad, rad_to_nm, rad_to_deg, dm_normalizer} from \"./modules/geopoint\"\nexport {AVENZAICONS, GOOGLEICONS, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, PIN_BLUE, PIN_BROWN, PIN_GREEN, PIN_NONE, PIN_ORANGE, PIN_PINK, PIN_PURPLE, PIN_RED, PIN_YELLOW} from \"./modules/kml_constants\";\nexport {Route, Track} from \"./modules/route\"\nexport {googleEarthStyleTemplate, avenzaIconTemplate, avenzaStyleTemplate, avenzaTemplate, iconTemplate, styleTemplate, template} from \"./modules/kml_templates\";\nexport {KMLGenerator} from \"./modules/kml\";\nexport {Ofp} from \"./modules/ofp\";\nexport {GEO_HASH_GRID_SIZE, GeoGridIndex} from \"./modules/geoindex\";\nexport {ogimetRoute, ogimetData} from \"./modules/ogimet\";\nexport {months3} from \"./modules/ofp_infos\";\nexport {StringExtractException, extract} from \"./modules/ofp_extensions\";\nexport {iata2GeoPoint, icao2iata, iata2icao} from \"./modules/iata2icao\";\n"],"sourceRoot":""}