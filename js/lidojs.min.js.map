{"version":3,"sources":["webpack://editolido/webpack/universalModuleDefinition","webpack://editolido/./node_modules/ngeohash/main.js","webpack://editolido/webpack/bootstrap","webpack://editolido/webpack/runtime/compat get default export","webpack://editolido/webpack/runtime/define property getters","webpack://editolido/webpack/runtime/hasOwnProperty shorthand","webpack://editolido/webpack/runtime/make namespace object","webpack://editolido/./src/modules/geolite.js","webpack://editolido/./src/modules/geopoint.js","webpack://editolido/./src/modules/kml_constants.js","webpack://editolido/./src/modules/route.js","webpack://editolido/./src/modules/kml_templates.js","webpack://editolido/./src/modules/kml.js","webpack://editolido/./src/modules/ofp_extensions.js","webpack://editolido/./src/modules/iata2icao.js","webpack://editolido/./src/modules/ofp_infos.js","webpack://editolido/./src/modules/ofp.js","webpack://editolido/./src/modules/pairing.js","webpack://editolido/./src/modules/geoindex.js","webpack://editolido/./src/modules/ogimet.js","webpack://editolido/./src/index.js"],"names":["root","factory","exports","module","define","amd","globalThis","BASE32_CODES","BASE32_CODES_DICT","i","length","charAt","ENCODE_AUTO","MIN_LAT","MAX_LAT","MIN_LON","MAX_LON","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","LatLng","constructor","this","format","v","letters","abs","degrees","floor","rest","minutes","cents","letter","padding","toFixed","padStart","phi","lam","map","PI","PhiLam","R","deg","rad_to_nm","radians","rad_to_deg","nm_to_rad","nm","km_to_rad","km","fmod","b","Number","toPrecision","dm2decimal","s","indexOf","offset","parseInt","slice","parseFloat","array_normalizer","array","dm_normalizer","mixedValue","lng","Array","isArray","arincRegex","isARINC","label","match","arinc_normalizer","signed","GeoPoint","name","description","normalizer","latlng","Reflect","has","trim","philam_cache","dm_cache","asPhiLam","asDM","asRoundedDM","geopoint1","geopoint2","converter","distanceTo","course_to","point","segment","xtd_to","geopoints","options","howMany","x","y","z","p","philam","cosphi","cos","sin","atan2","sqrt","asLatLng","other","phi1","lam1","phi2","lam2","sd","acos","crs_ab","crs_ad","dist_ad","xtd","asin","atFraction","fraction","distance","circle","radius","steps","destination","tc","lat1","lon1","points","equals","toJSON","PIN_NONE","PIN_BLUE","PIN_YELLOW","PIN_BROWN","PIN_ORANGE","PIN_PINK","PIN_RED","PIN_GREEN","PIN_PURPLE","NAT_POSITION_ENTRY","NAT_POSITION_EXIT","PINS","GOOGLEICONS","c","AVENZAICONS","Route","iterator","route2","p1","p2","e","zip","segments","reduce","prev","current","accumulator","maxLength","preserve","remaining","first","maxRadians","segmentLength","Track","isMine","isComplete","infos","super","pointTemplate","style","dm","lineTemplate","coordinates","segmentTemplate","folderTemplate","content","open","template","styles","folders","avenzaTemplate","styleTemplate","id","color","width","avenzaStyleTemplate","googleEarthStyleTemplate","iconTemplate","href","avenzaIconTemplate","pinProp","KMLFolder","linestrings","placemarks","lineStyle","pinId","enabled","empty","newValue","oldStyle","newStyle","KMLGenerator","renderers","Map","icons","text","replace","computeOptions","folderName","folderPinInherit","pin","isNaN","addFolder","folder","set","addFolders","items","String","clone","deleteProperty","addLine","route","renderLine","addPoints","excluded","addPoint","addSegments","render","renderIconTemplate","renderStyleTemplate","renderTemplate","renderIcons","index","renderFolders","renderFolder","renderer","filter","concat","output","isSegment","tpl","changeFolderColor","changeFolderPin","changeFolderState","reset","setName","StringExtractException","extract","start","end","endIsOptional","inclusive","from","to","substring","WptRegExp","RegExp","matchAll","str","result","console","geoPoints","forEach","wptRegExp","raw","AIRPORTS","require","IATADB","TZDB","iata2icao","iata","icao2iata","icao","iata2tz","tz","tzOffset","isoString","timeZone","loc","event","Date","parse","toLocaleString","exec","day","month","year","hour","minute","baseIsoString","res","endsWith","iata2GeoPoint","data","months3","pdfParsers","freeze","ofpTypes","FISHPOINTS","Ofp","assert","startsWith","pdfParser","pdfjs","ofpType","S4","includes","NVP","pattern","flight","depICAO","destICAO","datetime","ofp","groups","ofpTextDate","hours","ofpOUT","UTC","inFlightReleased","rawFPL","flightNo","callsign","log","flightTime","alternates","ralts","levels","averageFL","rawFS","inFlightStart","InFlightStartETO","taxiTimeOUT","taxiTimeIN","destIATA","depIATA","pld","blockFuel","tripFuel","toUpperCase","groundDistance","scheduledIN","aircraftType","flightTypeAircraft","aircraftRegistration","exp","eep","minFuelMarginETOPS","aircraftICAO24","etopsTime","err","etopsSummary","min","m","ofpOFF","getTime","ofpON","ofpIN","tzdb","flightTypePNT","pairingText","duties","duty","previousIN","scheduledOut","blockTime","departure","arrival","legs","parseDuties","flightType","layovers","base","leg","layover","getFlightTypePNT","ofpInfos","window","alert","exception","removePageFooterRegex","cache","fn","cacheStore","toISOString","wptCoordinates","wptCoordinatesAlternate","end_is_optional","reverse","wptNamesEET","matches","eet","previousEET","previousFL","level","t","fl","results","tryAlts","altnames","altFn","altname","alternative","roundeddm","isMyTrack","fplRoute","trackParser","separator","parts","trackDescription","fishPoints","tracks","unknowns","f","trackRoute","trackIsComplete","labelDict","g","geoPoint","fpl","lidoRoute","replaceSID","pointsName","rawPoints","lidoPoints","fplRouteLenght","innerFplRoute","innerFplRouteLength","reversedPoints","reversedLidoRoute","lidoRouteLength","track","fplPoints","needle","trackPoints","splice","recursiveNatReplace","unshift","GEO_HASH_GRID_SIZE","GeoGridIndex","precision","gridSize","toString","centerPoint","suggestedPrecision","maxSize","entries","centerHash","meAndNeighbors","hash","getNearestPointsDirty","ogimetRoute","wmoGrid","segmentSize","algorithm","neighbourRadius","getNeighbour","neighbours","getNearestPoints","sort","findStrategic","k","o_xtd","ogimet","f_xtd","filterByXtd","j","ogimetResults","o_index","neighbour","reduceFn","bestXtd","best","maxi","bestDiff","diff","idx","ogimetData","taxitime","ts","now_ts","tref","trefOfp","dateTimeFormat","Intl","DateTimeFormat","formatToParts","hfin","ceil","labels","url","proxy","version","VERSION"],"mappings":"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","file":"lidojs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"editolido\"] = factory();\n\telse\n\t\troot[\"editolido\"] = factory();\n})(globalThis, function() {\nreturn ","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nlam is the longitude in radians (lambda is a reserved name in python)\nphi is the latitude in radians\n\nLatLng is the base object when using degrees\nPhiLam is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {PhiLam} PhiLam - convert to a PhiLam\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020\n     * @returns {String}\n     */\n    get asRoundedDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents > 5) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asPhiLam() {\n        const [phi, lam] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new PhiLam(phi, lam);\n    }\n}\n\n/**\n * PhiLam\n *\n * @property {number} phi - latitude in radians\n * @property {number} lam - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass PhiLam {\n    constructor(phi, lam) {\n        this.phi = phi;\n        this.lam = lam;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'PhiLam';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.phi, this.lam].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst philam2latlng = (philam) => philam.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\nconst latlng2roundeddm = (latlng) => latlng.asRoundedDM;\n\nexport {\n    LatLng, PhiLam, philam2latlng, latlng2dm, latlng2roundeddm\n};\n","/* eslint-disable max-lines */\nimport {LatLng, PhiLam} from \"./geolite\";\n\n\n// earth mean radius in meters\n// nm in meters\nconst R = 6371000.0;\nconst NM = 1852.0;\nconst deg = 180 / Math.PI;\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst rad_to_deg = (radians) => radians * deg;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\nconst fmod = (a, b) => Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new LatLng(...array);\n    }\n    return new LatLng([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new LatLng(dm2decimal(lat), dm2decimal(lng))\n}\nconst arincRegex = /^([NESW]\\d{4}|\\d[NESW]\\d{3}|\\d{4}[NS]\\d{3,5}[EW]|\\d{2}[NS]\\d{3}[EW])$/u;\nconst isARINC = (label) => label.match(arincRegex);\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new LatLng(lat, -lng);\n            case 'E': // NE + +\n                return new LatLng(lat, lng);\n            case 'S': // SE - +\n                return new LatLng(-lat, lng);\n            case 'W': // SW - -\n                return new LatLng(-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new LatLng(lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof LatLng) {\n            this.latlng = mixedValue;\n        } else if (mixedValue && typeof mixedValue === 'object'\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new LatLng(parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.philam_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion PhiLam\n     * @returns {PhiLam}\n     */\n    get philam() {\n        if (this.philam_cache === null) {\n            this.philam_cache = this.latlng.asPhiLam;\n        }\n        return this.philam_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get roundeddm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asRoundedDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Get the course in radians between to GeoPoints\n     * @param {GeoPoint} geopoint1 start GeoPoint\n     * @param {GeoPoint} geopoint2 end GeoPoint\n     * @returns {number} the course in radians\n     */\n    static course(geopoint1, geopoint2) {\n        return geopoint1.course_to(geopoint2);\n    }\n\n    /**\n     * Given the segment AB, computes cross track error at point D\n     * @param {GeoPoint} point GeoPoint D\n     * @param {[GeoPoint, GeoPoint]} segment segment AB\n     * @param {?function} converter the converter to use\n     * @returns {number} the xtd in radians unless a converter is given\n     */\n    static xtd(point, segment, converter=null) {\n        return point.xtd_to(segment, converter);\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options={}) {\n        let howMany = geopoints.length,\n            lam = 0,\n            phi = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            phi = p.philam.phi;\n            lam = p.philam.lam;\n            let cosphi = Math.cos(phi);\n            x += cosphi * Math.cos(lam);\n            y += cosphi * Math.sin(lam);\n            z += Math.sin(phi);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const sd = Math.acos(\n            Math.sin(phi1) * Math.sin(phi2)\n            + Math.cos(phi1) * Math.cos(phi2) * Math.cos(lam2 - lam1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * Get the course to another point\n     * @param {GeoPoint} other GeoPoint\n     * @returns {number} the course in radian\n     */\n    course_to(other) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        return fmod(\n            Math.atan2(\n                Math.sin(lam1 - lam2) * Math.cos(phi2),\n                Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam1 - lam2)\n            ),\n            2 * Math.PI\n        );\n    }\n\n    /**\n     * Given the segment AB; computes cross track error\n     * @param {[GeoPoint, GeoPoint]} segment the segment AB\n     * @param {?function} converter the converter to use otherwise result in radians\n     * @returns {number} the distance in radian unless a converter is set\n     */\n    xtd_to(segment, converter=null) {\n        const crs_ab = segment[0].course_to(segment[1]);\n        const crs_ad = segment[0].course_to(this);\n        const dist_ad = segment[0].distanceTo(this);\n        const xtd = Math.asin(Math.sin(dist_ad) * Math.sin(crs_ad - crs_ab));\n        if (converter !== null) {\n            return converter(xtd);\n        }\n        return xtd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(phi1) * Math.cos(lam1) + b * Math.cos(phi2) * Math.cos(lam2);\n        const y = a * Math.cos(phi1) * Math.sin(lam1) + b * Math.cos(phi2) * Math.sin(lam2);\n        const z = a * Math.sin(phi1) + b * Math.sin(phi2);\n        const phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n    }\n\n    /**\n     * Return points forming a circle around current points\n     * @param {int} radius distance in radians\n     * @param {int} steps number of points in the circle\n     * @param {function} converter converter to use for the radius\n     */\n    circle(radius, steps=64, converter=nm_to_rad) {\n        if (converter) radius = converter(radius);\n        const destination = (d, tc) => {\n            const lat1 = this.philam.phi;\n            const lon1 = this.philam.lam;\n            const phi = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) *Math.sin(d) * Math.cos(tc));\n            let lam = lon1;\n            if (Math.cos(phi) !== 0) {\n                lam = Math.asin(Math.sin(tc) * Math.sin(d) / Math.cos(phi))\n                if (lon1 - lam < - Math.PI) lam = lon1 + Math.PI; // fix PPT ETOPS circle\n                lam = fmod(lon1 - lam + Math.PI, 2 * Math.PI) - Math.PI;\n            }\n            return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n        }\n        const points = [];\n        for (let i = 0; i <= steps; i += 1) {\n            points.push(destination(radius, i * 2 * Math.PI / steps));\n        }\n        //points.push(points[0]); // close circle\n        return points;\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\nexport {array_normalizer, dm_normalizer, arinc_normalizer, isARINC, GeoPoint,dm2decimal,km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, rad_to_deg, NM, R};\n","export const PIN_NONE = 0\nexport const PIN_BLUE = 1\nexport const PIN_YELLOW = 2\nexport const PIN_BROWN = 3 // not available in Avenza\nexport const PIN_ORANGE = 4\nexport const PIN_PINK = 5 // not available in Avenza\nexport const PIN_RED = 6\nexport const PIN_GREEN = 7\nexport const PIN_PURPLE = 8\n\nexport const NAT_POSITION_ENTRY = 0\nexport const NAT_POSITION_EXIT = 1\n\nexport const PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nexport const GOOGLEICONS = [\n    '', 'blu', 'ylw',\n    'red', 'orange', 'pink',\n    'red', 'grn', 'purple',\n].map(c => ((c) ? `https://maps.google.com/mapfiles/kml/paddle/${c}-blank.png` : ''));\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nexport const AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png`);\n","import {nm_to_rad, rad_to_nm} from \"./geopoint\";\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {GeoPoint[]}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=rad_to_nm) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} [options.converter] - must transform maxLength in radians\n     * @param {?boolean} [options.preserve] - if false, split at maxLength, do not keep intermediary points\n     * @param {string} [options.name] - generated route name\n     * @param {string} [options.description] - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options = {}){\n        let {converter=nm_to_rad, preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength;\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true, infos={}} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n        this.infos = infos;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n\n    /**\n     * Given a track letter, returns the track label used in FPL\n     * @param {string} letter the track letter designator\n     * @return {string} the track label\n     */\n    static label(letter) {\n        return `NAT${letter}`;\n    }\n}\n\nexport {Route, Track};\n","/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nexport const pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nexport const folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nexport const styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nexport const avenzaStyleTemplate = ({id, color, width=3}) => styleTemplate({id, color, width});\nexport const googleEarthStyleTemplate = ({id, color, width=2}) => ((id === 'rnat') ? styleTemplate({id, color, 'width': 1}) : styleTemplate({id, color, width}));\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nexport const iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => ((href) ? `\n    <Style id=\"${id}\">\n      <IconStyle>\n          <Icon>\n              <href><![CDATA[${href}]]></href>\n          </Icon>\n          <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n      </IconStyle>\n    </Style>\\n` : `<Style id=\"${id}\"></Style>\\n`);\n\nexport const avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n","/* eslint-disable max-lines */\nimport {GOOGLEICONS, PINS, PIN_NONE} from \"./kml_constants\";\nimport {\n    folderTemplate, iconTemplate, lineTemplate, pointTemplate, segmentTemplate, styleTemplate, template\n} from \"./kml_templates\";\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? PIN_NONE : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = PINS[this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = PINS[newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || template;\n        this.pointTemplate = renderers.pointTemplate || pointTemplate;\n        this.lineTemplate = renderers.lineTemplate || lineTemplate;\n        this.folderTemplate = renderers.folderTemplate || folderTemplate;\n        this.styleTemplate = renderers.styleTemplate || styleTemplate;\n        this.iconTemplate = renderers.iconTemplate || iconTemplate;\n        this.segmentTemplate = renderers.segmentTemplate || segmentTemplate;\n        this.icons = renderers.icons || GOOGLEICONS;\n        this.name = undefined;\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = PINS[options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} [items.pinId=0] - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = PIN_NONE;\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        const renderIconTemplate = options.iconTemplate || this.iconTemplate;\n        const renderStyleTemplate = options.styleTemplate || this.styleTemplate;\n        const renderTemplate = options.template || this.template;\n        const renderIcons = options.icons || this.icons;\n        PINS.forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': PINS[index].slice(1), 'href': renderIcons[index]};\n                styles += renderIconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += renderStyleTemplate(folder.lineStyle)\n            }\n        }\n        if (!options.name) options.name = this.name;\n        return renderTemplate({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === PIN_NONE || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n    /**\n     * set the default name inserted in template\n     * @param {string} name the name/description\n     */\n    setName(name) {\n        this.name = name;\n    }\n}\n\nexport {KMLGenerator};\n","import {GeoPoint, dm_normalizer} from \"./geopoint\";\n\n/**\n * Exception thrown when a search term is not found\n */\nclass StringExtractException extends Error {}\n\n/**\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nfunction extract(text, start, end, endIsOptional = true, inclusive = false) {\n  let from = 0;\n  let to = 0;\n  if (start) {\n    from = text.indexOf(start);\n    if (from === -1) {\n      throw new StringExtractException(`${start} not found`);\n    }\n    if (!inclusive) {\n      from += start.length;\n    }\n  }\n  if (!end) {\n    return text.substring(from);\n  }\n  to = text.indexOf(end, from);\n  if (to === -1) {\n    if (endIsOptional) {\n      return text.substring(from);\n    }\n    throw new StringExtractException(`${end} not found`);\n  } else if (inclusive) {\n    to += end.length;\n  }\n  return text.substring(from, to);\n}\n\n/**\n * Defines an extract method on the String prototype\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nReflect.defineProperty(String.prototype, 'extract', {\n  value(start, end, endIsOptional = true, inclusive = false) {\n    return extract(this, start, end, endIsOptional, inclusive);\n  }\n});\n\n\n/**\n * A matchAll RegExp to extract WPT COORDINATES from text\n * @return {GeoPoint[]}\n */\nclass WptRegExp extends RegExp {\n\n  /**\n   * matchAll methods to return an array of GeoPoint\n   * @param str\n   * @returns {GeoPoint[]}\n   */\n  [Symbol.matchAll](str) {\n    // eslint-disable-next-line prefer-reflect\n    let result = RegExp.prototype[Symbol.matchAll].call(this, str);\n    if (!result) {\n      console.error(\"WPT Coordinates regexp failed\");\n      return [];\n    }\n    let geoPoints = [];\n    Array.from(result).forEach((match) => {\n      let name = match[1].trim().replace(/^-+/u, \"\");\n      if (name === \"\") {\n        name = match[2] + match[3];\n      }\n      geoPoints.push(\n        new GeoPoint(\n          [match[2], match[3]],\n          {\"name\": name, \"normalizer\": dm_normalizer})\n      );\n    });\n    return geoPoints;\n  }\n}\nconst wptRegExp = new WptRegExp(String.raw`(\\S+|\\s+)\\s+([NS]\\d{4}\\.\\d)([EW]\\d{5}\\.\\d)`, 'gu');\n\nexport {wptRegExp, StringExtractException, extract};\n","import {GeoPoint} from './geopoint';\nconst AIRPORTS = require('./airports.json');\nconst IATADB = require('./iata2icao.json');\nconst TZDB = require('./timezones.json');\n\n/** return icao code for a iata code or '????' */\nexport function iata2icao(iata) {\n    const index = IATADB.indexOf(iata + ':');\n    return (index >= 0) ? IATADB.substring(index + 4, index + 8) : '????';\n}\n\n/** return iata code for a icao code or '???' */\nexport function icao2iata(icao) {\n    const index = IATADB.indexOf(':' + icao);\n    return (index >= 0) ? IATADB.substring(index - 3, index) : '???';\n}\n\n/** return iata timezone \"Europe/Paris\" or undefined*/\nexport function iata2tz(iata) {\n    const index = IATADB.indexOf(iata + ':');\n    if (index >= 0) {\n        const tz = IATADB.substring(index + 8, index + 10);\n        return (tz === '00') ? undefined : TZDB[tz];\n    }\n    return undefined;\n}\n\n/** return timezone offset \"-2\" \"+5.5\" for iata at a date like \"2021-08-12T14:25Z\" or undefined */\nexport function tzOffset(iata, isoString) {\n    const timeZone = iata2tz(iata);\n    if (!timeZone) return undefined;\n    let event = new Date(Date.parse(isoString));\n    // British English uses day/month/year order and 24-hour time without AM/PM\n    // eslint-disable-next-line init-declarations\n    let loc;\n    try {\n        loc = event.toLocaleString(\"en-GB\", {timeZone});\n    } catch (e) {\n        return undefined;\n    }\n    const re = /(\\d\\d)\\/(\\d\\d)\\/(\\d\\d\\d\\d), (\\d\\d):(\\d\\d):\\d\\d/u\n    const match = re.exec(loc);\n    if (match !== null) {\n        const [, day, month, year, hour, minute] = match;\n        const baseIsoString = `${year}-${month}-${day}T${hour}:${minute}`;\n        const baseEvent = new Date(Date.parse(baseIsoString + \"Z\"));\n        const offset = (baseEvent - event)/3600000;\n        if (offset === 0) {\n            return \"+0\";\n        }\n        let res = (offset >= 0) ? '+' : '';\n        res += offset.toFixed(1)\n        return (res.endsWith('.0')) ? res.slice(0, -2) : res;\n    }\n    return undefined\n}\n\n/** return a LatLng from a iata code */\nexport function iata2GeoPoint(iata) {\n    const name = iata2icao(iata);\n    if (name) {\n        const data = AIRPORTS[name];\n        if (data) {\n            return new GeoPoint(data, {name});\n        }\n    }\n    return undefined\n}\n","/* eslint-disable max-lines */\n/* eslint-disable complexity */\n/* eslint-disable max-lines-per-function */\n\nimport {getFlightTypePNT, parseDuties} from './pairing';\nimport {iata2tz, icao2iata} from './iata2icao';\nimport {GeoPoint} from './geopoint';\nimport {StringExtractException} from \"./ofp_extensions\";\nconst AIRPORTS = require('./airports');\n\nconst months3 = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n Dictionary of common OFP data:\n - flightNo (AF009)\n - callsign (AFR009)\n - depICAO (KJFK)\n - depIATA IATA departure (JFK)\n - destICAO (LFPG)\n - destIATA IATA destination (CDG)\n - taxiTimeIN (departure taxi time in minutes)\n - taxiTimeOUT (arrival taxi time in minutes)\n - flightTime (ofp flight time in minutes)\n - ofpOUT (a javascript Date object for scheduled departure block time)\n - ofpOFF (ofpOUT + taxiTimeOUT)\n - ofpON (ofpOUT + taxiTimeOUT + flightTime)\n - ofpIN (ofpOUT + taxiTimeOUT + flightTime + taxiTimeIN)\n - scheduledIN (a javascript Date object for scheduled arrival block time)\n - ofp (OFP number 9/0/1)\n - alternates an array of alternate names\n - ralts an array of route alternate names (ETOPS)\n - rawFPL the raw text of the FPL\n - EEP the airport related to the ETOPS entry GeoPoint\n - EXP the airport related to the ETOPS exit GeoPoint\n - raltPoints the ETOPS airports as GeoPoint\n - maxETOPS the ETOPS time in minutes\n - minFuelMarginETOPS minimum fuel margin in T (extracted from ETOPS SUMMARY)\n - averageFL average flight level or 300\n - levels = array of flight levels found in FPL or [300]\n - payload in T\n - tripFuel in T\n - blockFuel in T\n - inFlightReleased is true when the OFP is released while in flight\n - inFlightStart is the start point name for ofp released in flight\n * @param text The OFP in text format\n * @returns {{flightNo: string, callsign: string, depICAO: string, depIATA: string, destICAO: string, destIATA: string, taxiTimeOUT: number, taxiTimeIN: number, ofpOUT: Date, ofpOFF: Date, ofpON: Date, ofpIN: Date, scheduledIN: Date, ofp: string, ralts: [] alternates: [], rawFPL: string, EEP: GeoPoint, EXP: GeoPoint, raltPoints: [GeoPoint], maxETOPS: number, fl: number, levels: [number], tripFuel: number, blockFuel: number, payload: number, inFlightReleased: boolean, inFlightStart: string, flightTypeAircraft: string, aircraftType: string}}\n */\nfunction ofpInfos(text) {\n  let pattern = /(?<flight>AF\\s+\\S+\\s+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\d+\\S{0,8})/u;\n  let match = pattern.exec(text);\n  if (match === null) {\n    pattern = /(?<flight>AF.+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\S+)Main/u;\n    match = pattern.exec(text);\n  }\n  let {flight, depICAO, destICAO, datetime, ofp} = match.groups;\n  // datetime is like 27Sep2019/1450\n  const [ofpTextDate] = datetime.split('/', 1);\n  const day = parseInt(datetime.substring(0,2), 10);\n  const month = months3.indexOf(datetime.substring(2,5));\n  const year = parseInt(datetime.substring(5,9), 10);\n  const hours = parseInt(datetime.substring(10,12), 10);\n  const minutes = parseInt(datetime.substring(12,14), 10);\n  const ofpOUT = new Date(Date.UTC(year, month, day, hours, minutes));\n  const inFlightReleased = text.indexOf(\"Inflight Released\") >= 0;\n\n  const rawFPL = text\n    .extract(\"ATC FLIGHT PLAN\", \"TRACKSNAT\")\n    .extract(\"(\", \")\", false, true);\n  const flightNo = flight.replace(/\\s/gu, \"\");\n  let callsign = flightNo;\n  pattern = /\\(FPL-([^-]+)-/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      callsign = match[1];\n  }\n\n  pattern = new RegExp(String.raw`(?:-TRIP|SUMMARYTRIP)\\s+[0-9]+[\\s.]+(\\d{2})(\\d{2})\\s`, \"u\");\n  match = pattern.exec(text);\n  if (match === null){\n    pattern = new RegExp(String.raw`-${destICAO}(\\d{2})(\\d{2})\\s`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match === null) {\n      console.log(\"flight duration not found, arbitrary set to 1 hour\");\n    } else {\n      console.log(\"trip time not found, using fpl flight time\");\n    }\n  }\n  const flightTime = (match) ? parseInt(match[2], 10) + 60 * parseInt(match[1], 10) : 60;\n\n  // try with 2 alternates first\n  pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n  match = pattern.exec(rawFPL);\n  let alternates = [];\n  if (match !== null){\n    alternates.push(match[1]);\n    alternates.push(match[2]);\n  } else {\n    pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match !== null) {\n      alternates.push(match[1]);\n    }\n  }\n\n  pattern = /RALT\\/((?:\\S{4}[ \\n])+)/u;\n  match = pattern.exec(rawFPL);\n  let ralts = [];\n  if (match !== null) {\n    ralts = match[1].trim().split(/\\s/u);\n  }\n\n  let levels = [...rawFPL.matchAll(/F(\\d{3})\\s/ug)].map(v => (v[1]*1));\n  let averageFL = 300;\n  if (levels && levels.length) {\n      averageFL = Math.round(levels.reduce((a, b) => a + b, 0) / levels.length);\n  } else {\n    levels = [averageFL];\n  }\n  const rawFS = text.extract(\"FLIGHT SUMMARY\", \"Generated\");\n  // eslint-disable-next-line init-declarations\n  let inFlightStart;\n  // eslint-disable-next-line init-declarations\n  let InFlightStartETO;\n  if (inFlightReleased) {\n    pattern = new RegExp(String.raw`ATC:${callsign}\\s+(\\S+)\\s+\\d{4}\\s+\\.{4}\\s+(\\d{2})(\\d{2})`, \"u\");\n    match = pattern.exec(rawFS);\n    if (match) {\n      inFlightStart = match[1];\n      InFlightStartETO = new Date(Date.UTC(year, month, day, parseInt(match[2], 10), parseInt(match[3], 10)))\n    }\n  }\n  pattern = /\\s(\\d{2})(\\d{2})\\s+TAXI IN/u;\n  match = pattern.exec(rawFS);\n  let taxiTimeOUT = 15;\n  if (match === null) {\n    console.log(\"taxiTimeOUT not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeOUT = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  let taxiTimeIN= 15;\n  pattern = /\\/\\s+(\\d{2})(\\d{2})MIN/u;\n  match = pattern.exec(rawFS);\n  if (match === null) {\n    console.log(\"arrival taxitime not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeIN = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  pattern = new RegExp(String.raw`\\s${destICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const destIATA = (match) ? match[1] : '';\n  pattern = new RegExp(String.raw`\\s${depICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const depIATA = (match) ? match[1] : icao2iata(depICAO);\n  pattern = /\\.PLD\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const pld = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\.BLOCK\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const blockFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\|TRIP\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const tripFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = new RegExp(String.raw`GND DIST\\s+(\\d+)${ofpTextDate.toUpperCase().substring(0,5)}`, \"u\");\n  match = pattern.exec(rawFS);\n  const groundDistance = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\s+STA\\s+([0-9]{4})/u;\n  match = pattern.exec(rawFS);\n  let scheduledIN = (match) ? new Date(Date.UTC(year, month, day, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10))): null;\n  if (scheduledIN && scheduledIN < ofpOUT) {\n    scheduledIN = new Date(Date.UTC(year, month, day + 1, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10)));\n  }\n  //aircraft type\n  let aircraftType = \"???\";\n  const aircraftTypes = { // convert to Oliver Ravet codes\n    'A388': '380',\n    'B772': '772',\n    'B773': '773',\n    'B77W': '773',\n    'B77L': '77F',\n    'B788': '787',\n    'B789': '787',\n    'B78X': '787',\n    'A318': '318',\n    'A319': '319',\n    'A320': '320',\n    'A20N': '320', //A320 neo\n    'A321': '321',\n    'A332': '330',\n    'A333': '330',\n    'A338': '330',\n    'A339': '330',\n    'A342': '340',\n    'A343': '340',\n    'A344': '340',\n    'A345': '340',\n    'A346': '340',\n    'A359': '350',\n    'A35K': '350',\n    'BCS1': '220',\n    'BCS3': '220'\n  }\n  pattern = /-([AB][0-9]{2}.|BCS\\d)\\//u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftType = aircraftTypes[match[1]] || '???';\n  }\n  const flightTypeAircraft = (['220', '318', '319', '320', '321'].includes(aircraftType)) ? \"MC\" : \"LC\";\n  // aircraft registration\n  let aircraftRegistration = '';\n  pattern = /REG\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftRegistration = match[1][0] + '-' + match[1].slice(1);\n  }\n  // icao24\n  let aircraftICAO24 = '';\n  pattern = /CODE\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n    aircraftICAO24 = match[1];\n  }\n  // eslint-disable-next-line init-declarations\n  let exp;\n  // eslint-disable-next-line init-declarations\n  let eep;\n  // eslint-disable-next-line init-declarations\n  let minFuelMarginETOPS;\n  let etopsTime = 0;\n  if (ralts.length > 0) {\n      pattern = /ETOPS\\s+(\\d{3})\\s/u\n      match = pattern.exec(rawFS);\n      if (match) {\n        etopsTime = parseInt(match[1], 10);\n      } else {\n        try {\n          match = pattern.exec(text.extract('FPL SUMMARY', 'Generated'));\n          if (match) {\n            etopsTime = parseInt(match[1], 10);\n          }\n        } catch (err) {\n          console.log(\"ETOPS range not found\");\n        }\n      }\n      const etopsSummary = text.extract(\"ETOPS SUMMARY\", \"--FLIGHT LOG\");\n      pattern = /EEP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        eep = match[1];\n      }\n      pattern = /EXP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        exp = match[1];\n      }\n      pattern = /ETO\\.{4}\\s+([\\d.]+)\\/EFOB\\s([\\d.]+)/gu;\n      minFuelMarginETOPS = Math.min(...Array.from(etopsSummary.matchAll(pattern), m => parseFloat(m[2]) - parseFloat(m[1])));\n  }\n\n  const ofpOFF = (!InFlightStartETO) ? new Date(ofpOUT.getTime() + taxiTimeOUT * 60000) : InFlightStartETO;\n  const ofpON = new Date(ofpOFF.getTime() + flightTime * 60000);\n  const ofpIN = new Date(ofpON.getTime() + taxiTimeIN * 60000);\n  const tzdb = {};\n  let flightTypePNT = null;\n  try {\n      const pairingText = text.extract('CREW PAIRING', 'Generated');\n      pattern = /DATE\\s:\\s(\\d+)\\.(\\S{3})\\.(\\d{4})/u;\n      match = pattern.exec(pairingText);\n      if (match) {\n          const y = parseInt(match[3], 10);\n          const m = months3.indexOf(match[2]) + 1; // 1-12\n          if (m <= 0) throw new Error('could not extract pairing month');\n          const duties = parseDuties(pairingText, y, m);\n          flightTypePNT = getFlightTypePNT(duties);\n          for (const duty of duties) {\n            if (duty.legs && duty.legs.length > 0) {\n              const iata = duty.legs[0].depIATA;\n              tzdb[iata] = iata2tz(iata);\n            }\n          }\n      } else {\n          throw new Error('could not extract pairing month/year');\n      }\n  } catch (err) {\n      if (!(err instanceof StringExtractException)) {\n          console.error(err);\n      }\n  }\n  const infos = {\n    //\"flight\": flightNo, /*deprecated */\n    flightNo,\n    callsign,\n\n    //\"departure\": depICAO, /*deprecated */\n    //\"dep3\": depIATA, /*deprecated */\n    \"depICAO\": depICAO,\n    \"depIATA\": depIATA,\n\n    //\"destination\": destICAO, /*deprecated */\n    //\"des3\": destIATA, /*deprecated */\n    \"destICAO\": destICAO,\n    \"destIATA\": destIATA,\n\n    //\"datetime\": ofpOUT, /*deprecated */\n    //\"STD\": ofpOUT, /*deprecated */\n    //\"takeoff\": ofpOFF, /*deprecated */\n    //\"landing\": ofpON, /*deprecated */\n    //\"station\": scheduledIN, /*deprecated */\n    //\"STA\": scheduledIN, /*deprecated */\n    //\"datetime2\": ofpIN, /*deprecated */\n    ofpOUT,\n    ofpOFF,\n    ofpON,\n    ofpIN,\n    scheduledIN,\n    \"flightTime\": (ofpON.getTime() - ofpOFF.getTime()) / 60000,\n    \"blockTime\": (ofpIN.getTime() - ofpOUT.getTime()) / 60000,\n    \"scheduledBlockTime\": (scheduledIN) ? (scheduledIN.getTime() - ofpOUT.getTime()) / 60000 : 0,\n    //\"date\": ofpTextDate, /* deprecated */\n    ofpTextDate,\n    \"ofp\": ofp.replace(\"\\xA9\", \"\"),\n    //\"duration\": duration,  /*deprecated */\n    \"alternates\": alternates,\n    \"ralts\": ralts,\n    \"raltPoints\": [],\n    //\"taxitime\": taxiTimeOUT, /*deprecated */\n    //\"taxitime2\": taxiTimeIN, /*deprecated */\n    taxiTimeOUT,\n    taxiTimeIN,\n    //\"rawfpl\": rawFPL,/*deprecated */\n    rawFPL,\n    //\"aircraft\": aircraftType,  /*deprecated */\n    aircraftType,\n    flightTypeAircraft,\n    //\"registration\": aircraftRegistration,  /*deprecated */\n    aircraftRegistration,\n    //\"icao24\": aircraftICAO24,  /*deprecated */\n    aircraftICAO24,\n    \"EEP\": null,\n    \"EXP\": null,\n    //\"ETOPS\": etopsTime,  /*deprecated */\n    \"maxETOPS\": etopsTime,\n    minFuelMarginETOPS,\n    averageFL,\n    levels,\n    \"payload\": pld / 1000,\n    \"tripFuel\": tripFuel / 1000,\n    \"blockFuel\": blockFuel / 1000,\n    groundDistance,\n    inFlightReleased,\n    inFlightStart,\n    flightTypePNT,\n    tzdb\n  }\n  try {\n    infos['raltPoints'] = [];\n    for (const v of ralts) {\n      if (v && AIRPORTS[v]) {\n        infos['raltPoints'].push(new GeoPoint(AIRPORTS[v], {'name': v, 'description': 'ETOPS'}));\n      } else {\n        console.error('missing airport', v);\n      }\n    }\n    if (eep && AIRPORTS[eep]) {\n      infos['EEP'] = new GeoPoint(AIRPORTS[eep], {'name': eep, 'description': 'EEP'});\n    } else if (eep){\n      console.error('missing airport', eep);\n    }\n    if (exp && AIRPORTS[exp]) {\n      infos['EXP'] = new GeoPoint(AIRPORTS[exp], {'name': exp, 'description': 'EXP'});\n    } else if (exp){\n      console.error('missing airport', exp);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n  return infos\n}\nexport {ofpInfos, months3};\n","/* eslint-disable no-underscore-dangle,max-lines-per-function, max-lines */\n\nimport {GeoPoint, arinc_normalizer} from \"./geopoint\";\nimport {Route, Track} from \"./route\";\nimport {wptRegExp} from \"./ofp_extensions\";\n// eslint-disable-next-line sort-imports\nimport {ofpInfos} from \"./ofp_infos\";\n\n\nconst pdfParsers = Object.freeze({\n  \"pypdf2\": 3,\n  \"pdfjs\": 4\n});\n\nconst ofpTypes = Object.freeze({\n  \"S4\": 1,\n  \"NVP\": 2\n});\n\nconst FISHPOINTS = require('./fishpoints');\n\nexport class Ofp {\n  constructor(text=\"\") {\n    console.assert(text.startsWith(\"_PDFJS_\"), \"invalid text file\");\n    this.pdfParser = pdfParsers.pdfjs;\n    this.ofpType = ofpTypes.S4;\n    if (text.includes(\"--FLIGHT SUMMARY--\")) {\n      this.ofpType = ofpTypes.NVP;\n    }\n    try {\n      this.infos = ofpInfos(text);\n    } catch (error) {\n      console.error(error);\n      try {\n        if (window) {\n          // eslint-disable-next-line no-alert\n          window.alert(`Erreur: {error}` )\n        }\n      } catch (exception) {\n        // not in browser, just log\n      }\n      throw error;\n    }\n    this.removePageFooterRegex = new RegExp(String.raw`([\\s-]\\d{1,2})?Page\\s[0-9]+\\s.+?Page\\s[0-9]+.+?\\/${this.infos['depICAO']}-${this.infos['destICAO']}`, 'gsu');\n    this.text = text.replace(this.removePageFooterRegex,'');\n    this.cache = function (name, fn) {\n      if (this.cacheStore === undefined) {\n        this.cacheStore = {}; /* on first run create cache storage */\n      }\n      if (this.cacheStore[name] === undefined) {\n        this.cacheStore[name] = fn();\n      }\n      return this.cacheStore[name];\n    };\n  }\n\n  get description() {\n    const infos = this.infos;\n    return `${infos.flightNo} ${infos.depICAO}-${infos.destICAO} ${infos.ofpTextDate} ${infos.ofpOUT.toISOString().substring(11,16)}z OFP ${infos.ofp}`;\n  }\n\n  /**\n   * Array of WPT COORDINATES found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinates(start=\"WPT COORDINATES\") {\n    const infos = this.infos;\n    const end = (this.ofpType === ofpTypes.NVP) ? '----' + infos['destICAO']: '----';\n    const extract = this.text.extract(start, end);\n    const geoPoints = extract.matchAll(wptRegExp);\n    if (geoPoints.length > 0) {\n      if (!infos.inFlightReleased) {\n        geoPoints[0].name = this.infos['depICAO']; // avoid name problems\n      } else if (infos.inFlightStart) {\n        geoPoints[0].name = infos.inFlightStart;\n      }\n    }\n    return geoPoints;\n  }\n\n  /**\n   * Array of WPT COORDINATES for alternate found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinatesAlternate(start='WPT COORDINATES', end_is_optional=false) {\n\n    const end = (this.ofpType === ofpTypes.NVP) ? '--WIND INFORMATION--': 'ATC FLIGHT PLAN';\n    // take only what is after the last '----' (python rsplit)\n    // eslint-disable-next-line require-jsdoc\n    function reverse(str) {\n      return [...str].reverse().join('');\n    }\n    const t = this.text.extract(start, end, end_is_optional)\n    const extract = reverse(t).split('----', 1)[0];\n    return reverse(extract).matchAll(wptRegExp);\n  }\n\n  wptNamesEET(geoPoints) {\n    const start = 'ATC DEPARTURE';\n    const pattern = /[\\s-]([A-Z0-9/]+)\\s+[0-9]{3}\\s+(?:[0-9.\\s]{4})\\s+\\.\\.\\.\\.\\/\\.\\.\\.\\.\\s(.{3})\\s[A-Z0-9/.+\\s-]+?[0-9]{4}\\/([0-9]{4})\\s+[0-9]{3}\\/[0-9]{3}/gu;\n    const extract = this.text.extract(start, 'DESTINATION ALTERNATE', true);\n    const matches = extract.matchAll(pattern);\n\n    const eet = {};\n    let previousEET = 0;\n    // eslint-disable-next-line init-declarations\n    let previousFL = this.infos.levels[0];\n    for (let [,name, level, t,] of matches) {\n      //console.log(name)\n      if (name.startsWith('/')) name = name.slice(1); // ofp AF082\n      const fl = parseInt(level, 10);\n      if (!isNaN(fl)) previousFL = fl;\n      eet[name.split('/')[0]] = [previousEET, previousFL];\n      previousEET = (parseFloat(t.slice(0,2)) * 60) + parseFloat(t.slice(2))\n    }\n    eet[this.infos['destICAO']] = [previousEET, previousFL];\n    //console.log(eet);\n    const results = [];\n    let error = false;\n    const tryAlts = (altnames) => {\n      for (const altFn of altnames) {\n        const altname = altFn();\n        if (altname !== null && eet[altname] !== undefined) {\n          return eet[altname];\n        }\n      }\n      return undefined;\n    }\n    for (const p of geoPoints) {\n      if (eet[p.name] === undefined) {\n        const alternative = tryAlts([\n          () => p.name.replace(/00\\.0/gu,''),\n          () => p.name.replace(/\\.0/gu,''),\n          () => p.roundeddm,\n        ]);\n        if (alternative) {\n          results.push([p, ...alternative]);\n        } else {\n          console.log('missing point', p.name);\n          error = true;\n          break;\n        }\n      } else {\n          results.push([p, ...eet[p.name]]);\n      }\n    }\n    return (error) ? [] : results;\n  }\n\n  /**\n   * check if the designated track is in the FPL\n   * @param letter\n   * @returns {boolean}\n   */\n  isMyTrack(letter) {\n    return this.fplRoute.indexOf(Track.label(letter)) !== -1;\n  }\n\n  /**\n   * Parse the OFP and return tracks as an array of [trackLetter, trackDescription]\n   * @returns {[]}\n   */\n  trackParser() {\n    let extract = \"\";\n    const infos = {};\n    try {\n      extract = this.text\n        .extract(\"ATC FLIGHT PLAN\").extract(')');\n    } catch (e) {\n      return [];\n    }\n    let results = [];\n    if (extract.includes(\"REMARKS:\")) {\n      extract = extract.split(\"REMARKS:\", 1)[0];\n      extract = extract.split(\"Generated at\", 1)[0];\n    }\n    let separator = \" NOTES:\";\n    //As we can have multiple TRACKNAT messages, we can not simply split on NOTES\n    if (extract.includes(separator)) {\n      const parts = extract.split(separator);\n      parts.slice(0, -1).join(separator);  // skip after _last_ NOTES:\n      extract = parts.slice(0, -1).join(separator);\n    }\n    if (extract.includes(\" LVLS \")) {\n      // split at track letter, discard first part\n      const a = extract.split(/(?:\\s|[^A-Z\\d])([A-Z])\\s{3}/gu).slice(1);\n      // results are [trackLetter, trackDescription]\n      for (let i = 0, max = a.length; i < max; i += 2) {\n        let trackDescription = a[i + 1];\n        results.push([a[i], trackDescription]);\n      }\n    } else if (extract.includes('TRACKS')) {\n      console.error(\"Unknown TRACKSNAT message format\");\n      console.log(extract);\n    }\n    return {results, infos};\n  }\n\n  /**\n   * Tracks found in the OFP as an array of Track\n   * @returns {Track[]}\n   */\n  get tracks() {\n    return this.cache(\"tracks\", () => {\n      const {results, infos} = this.trackParser();\n      const pattern = /(\\d{2,4}[NS]\\d{3,5}[EW]|[NESW]\\d{4}|\\d[NESW]\\d{3}[^EW])/u;\n      let fishPoints = {};\n      let tracks = [];\n\n      //find unknows named waypoints in tracks\n      let unknowns = [];\n      // eslint-disable-next-line array-callback-return\n      results.map(([, description]) => {\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) === null) {\n                unknowns.push(label);\n              }\n            }\n          });\n      });\n      // console.debug(`Unknown track points: ${unknowns}`);\n      unknowns.forEach((name) => {\n        const f = FISHPOINTS[name];\n        if (f !== undefined) {\n          fishPoints[name] = new GeoPoint(f, {\"name\": name});\n        }\n      });\n\n      results.forEach(([letter, description]) => {\n        let trackRoute = [];\n        let trackIsComplete = true;\n        const isMine = this.isMyTrack(letter);\n        let labelDict = (isMine) ? {} : fishPoints;\n        if (isMine) {\n          this.route.points.forEach((g) => {\n            if (g.name !== \"\") {\n              labelDict[g.name] = g\n            }\n          })\n        }\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) !== null) {\n                trackRoute.push(new GeoPoint(label, {\n                  \"name\": label,\n                  \"normalizer\": arinc_normalizer\n                }));\n              } else {\n                let geoPoint = labelDict[label];\n                if (geoPoint !== undefined) {\n                  trackRoute.push(new GeoPoint(geoPoint, {\"name\": label}));\n                } else {\n                  trackIsComplete = false;\n                }\n              }\n            }\n          });\n        let direction = \"\";\n        if (description.match(/RTS\\s+WEST/u)) direction = \"WEST\";\n        if (description.match(/RTS\\s+EAST/u)) direction = \"EAST\";\n        tracks.push(new Track(trackRoute,\n          {\n            \"name\": `NAT ${letter}`,\n            \"description\": description,\n            \"isMine\": isMine,\n            \"isComplete\": trackIsComplete,\n            \"infos\": {...infos, direction}\n          }));\n      });\n      return tracks;\n    });\n  }\n\n  /**\n   * Returns FPL as an Array\n   * @returns {string[]}\n   */\n  fpl() {\n    const infos = this.infos;\n    let text = infos.rawFPL.extract(`-${infos.depICAO}`, `-${infos.destICAO}`, false);\n    text = text.substring(text.indexOf(\" \") + 1);\n    let results = [infos.depICAO];\n    text.split(\" \").map((v) => v.trim())\n      .forEach((v) => {\n        if (v !== \"\" && !v.startsWith(\"-N\")){\n          results.push(v);\n        }\n      });\n    results.push(infos.destICAO);\n    return results;\n  }\n\n  /**\n   * FPL route found in OFP (fpl without speed/FL annotations)\n   * @returns {string[]}\n   */\n  get fplRoute() {\n    return this.cache(\"fplRoute\",\n      () => this.fpl().map((p) => {\n        if (p.includes(\"/\")) {\n          return p.split(\"/\", 1)[0];\n        }\n        return p;\n      })\n    );\n  }\n\n  get route() {\n    return this.cache(\"route\", () => new Route(this.wptCoordinates()));\n  }\n\n  lidoRoute(replaceSID=true) {\n    return this.cache(\"lidoRoute\" + ((replaceSID) ? \"_r\" : \"\"), () => {\n      const points = [];\n      const pointsName = []; // used if replaceSID === false\n      const rawPoints = []; // used if replaceSID === true\n      this.route.points.forEach((p) => {\n        rawPoints.push(p.dm);\n        pointsName.push(p.name || p.dm);\n        if (p.name === \"\" || (/\\d+/u).exec(p.name) !== null) {\n          points.push(p.dm);\n        } else {\n          points.push(p.name);\n        }\n      });\n      let lidoPoints = [];\n\n      let fplRoute = this.fplRoute;\n      let fplRouteLenght = fplRoute.length;\n      if (fplRouteLenght < 2) {\n        return points;\n      }\n      let departure = fplRoute[0];\n      let destination = fplRoute[fplRouteLenght - 1];\n      let innerFplRoute = fplRoute.slice(1, -1);\n      let innerFplRouteLength = innerFplRoute.length;\n\n\n      // replace points by rawPoint before first common waypoint\n      for (let i = 0; i < innerFplRouteLength; i += 1 ) {\n        let p = innerFplRoute[i];\n        let offset = points.indexOf(p);\n        if (offset !== -1) {\n          if (replaceSID) {\n            lidoPoints = rawPoints.slice(1, offset).concat(innerFplRoute.slice(i));\n          } else {\n            lidoPoints = pointsName.slice(1, offset).concat(innerFplRoute.slice(i));\n          }\n          break;\n        }\n      }\n      // replace points after last common waypoint by rawPoints\n      let reversedPoints = points.slice().reverse(); // copy before reverse\n      let reversedLidoRoute = lidoPoints.slice().reverse();\n      let lidoRouteLength = lidoPoints.length;\n      for (let i = 0; i < lidoRouteLength; i += 1 ) {\n        let p = reversedLidoRoute[i];\n        let offset = reversedPoints.indexOf(p);\n        if (offset !== -1) {\n          if (i > 0) {\n            lidoPoints = lidoPoints.slice(0, -i);\n          }\n          if (replaceSID) {\n            lidoPoints = lidoPoints.concat(rawPoints.slice(-offset, -1));\n          } else {\n            lidoPoints = lidoPoints.concat(pointsName.slice(-offset, -1));\n          }\n          break;\n        }\n      }\n      // replace known tracks (NATA, NATB...) by track_points\n      /**\n       * When there is a FL or Speed change, we may have multiple\n       * \"NATW\" in the FPL, so change them all.\n       * @param fplPoints: [] - an array of fplPoints\n       * @param needle: string\n       * @param trackPoints\n       * @returns {[]}\n       */\n      const recursiveNatReplace = function (fplPoints, needle, trackPoints) {\n        let match = [];\n        // infinite loop (while(true) breaks in browser)\n        // https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript\n        for (;;) {\n          let offset = fplPoints.indexOf(needle);\n          if (offset === -1) {\n            return match;\n          }\n          fplPoints.splice(offset, 1, ...trackPoints.slice(\n            trackPoints.indexOf(fplPoints[offset - 1]) +1,\n            trackPoints.indexOf(fplPoints[offset + 1])));\n          match = fplPoints;\n        }\n      };\n\n      this.tracks.forEach( (track) => {\n        if (track.isMine) {\n          let letter = track.name.slice(-1);\n          let results = recursiveNatReplace(\n            lidoPoints,\n            Track.label(letter),\n            track.points.map((p) => p.name)\n          );\n          if (results.length > 0) {\n            lidoPoints = results;\n          }\n        }\n      });\n      lidoPoints.push(destination);\n      lidoPoints.unshift((!this.infos.inFlightStart) ? departure : this.infos.inFlightStart);\n      // adds alternates and ralts\n      lidoPoints = lidoPoints.concat(...this.infos.alternates);\n      lidoPoints= lidoPoints.concat(...this.infos.ralts);\n      return lidoPoints;\n    });\n  }\n}\n","import {iata2GeoPoint} from \"./iata2icao\";\nimport {rad_to_nm} from \"./geopoint\";\n\n// const getFlightTypePNC = (departure, destination) => {\n//     if (departure.longitude >= -30 && departure.longitude <= 40 && departure.latitude >=25\n//         && destination.longitude >= -30 && destination.longitude <= 40 && destination.latitude >=25) {\n//         return \"MC\";\n//     }\n//     return \"LC\";\n// };\n\nexport const getFlightTypePNT = (duties) => {\n    let flightType = \"MT1\";\n    const layovers = [];\n    if (duties.length <= 0 || duties[0].legs.length <= 0) {\n        return flightType;\n    }\n    let base = duties[0].legs[0].departure;\n    for (const duty of duties) {\n        for (const leg of duty.legs) {\n            const distance = leg.departure.distanceTo(leg.arrival, rad_to_nm);\n            if (distance > 3000) {\n                return \"LT\";\n            } else if (distance > 2100) {\n                flightType = \"MT2\";\n            }\n        }\n        if (duty.legs.length > 0) layovers.push(duty.legs[duty.legs.length - 1].arrival);\n    }\n    if (flightType === \"MT1\") return flightType;\n    for (const layover of layovers) {\n        const meridians = Math.abs(Math.floor(base.longitude/15) - Math.floor(layover.longitude/15));\n        if (meridians >= 4) return \"LT\";\n    }\n    return flightType; //MT2\n};\nexport const parseDuties = (pairingText, year, month) => {\n    const duties = [];\n    let duty = {\"legs\": []};\n    let previousIN = null;\n    const pattern = /(\\d{2})\\/(\\d{2})\\s\\S+(\\sX)?\\s(\\S{3})\\s>\\s(\\S{3})\\s\\(([-+\\dh]+)\\)\\s(\\d{2}):(\\d{2})\\s(?:\\d{2}:\\d{2})\\s(\\d{2}):(\\d{2})/gu;\n    for (const match of pairingText.matchAll(pattern)) {\n        const m = parseInt(match[2], 10); // 1-12\n        const d = parseInt(match[1], 10);\n        const y = (m < month) ? year + 1 : year;\n        const scheduledOut = new Date(Date.UTC(y, m - 1, d, parseInt(match[7], 10), parseInt(match[8], 10))); // month must be 0-11\n        const blockTime = parseInt(match[10], 10) + parseInt(match[9], 10) * 60;\n        const depIATA = match[4];\n        const destIATA = match[5];\n        const departure = iata2GeoPoint(depIATA);\n        const arrival = iata2GeoPoint(destIATA);\n\n        if (previousIN && scheduledOut - previousIN > 36000000) { // more than 10 hours\n            duties.push(duty);\n            duty = {\"legs\": []};\n        }\n        duty.legs.push({\n            \"depIATA\": depIATA,\n            departure,\n            arrival,\n        });\n        previousIN = new Date(scheduledOut.getTime() + 60000 * blockTime);\n    }\n    if (duty.legs.length > 0) duties.push(duty);\n    return duties;\n}\n","import {GeoPoint, km_to_rad} from \"./geopoint\";\nimport geohash from \"ngeohash\";\n\n// dependence between hashtag's precision and distance accurate calculating\n// in fact it's sizes of grids in km\nexport const GEO_HASH_GRID_SIZE = {\n    \"1\": 5000.0,\n    \"2\": 1260.0,\n    \"3\": 156.0,\n    \"4\": 40.0,\n    \"5\": 4.8,\n    \"6\": 1.22,\n    \"7\": 0.152,\n    \"8\": 0.038\n}\n\nexport class GeoGridIndex {\n    constructor(precision=3) {\n        this.precision = precision;\n        this.gridSize = km_to_rad(GEO_HASH_GRID_SIZE[precision.toString()]);\n        this.data = {};\n    }\n\n    /**\n     * Get Nearest points based on the geohash of the point\n     * It returns all wmo points in the 9 adjacents tiles\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians (unless a converter is given)\n     * @param {?function} converter\n     * @generator {GeoPoint}\n     */\n    *getNearestPointsDirty(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        if (radius > this.gridSize / 2.0) {\n            // radius is too big for current grid, we cannot use 9 neighbors\n            // to cover all possible points\n            let suggestedPrecision = 0;\n            for (const [precision, maxSize] of Object.entries(GEO_HASH_GRID_SIZE)) {\n                if (radius > km_to_rad(maxSize) / 2.0) {\n                    suggestedPrecision = parseInt(precision, 10) - 1;\n                    break;\n                }\n            }\n            throw new Error(`Too large radius, please rebuild GeoHashGrid with precision=\"${suggestedPrecision}\"`);\n        }\n        const centerHash = geohash.encode(centerPoint.latitude, centerPoint.longitude, this.precision);\n        let meAndNeighbors = geohash.neighbors(centerHash);\n        meAndNeighbors.push(centerHash);\n        for (const hash of meAndNeighbors) {\n            if (hash in this.data) {\n                for (const [name, latitude, longitude] of this.data[hash]) {\n                    yield new GeoPoint([latitude, longitude], {\"name\": name});\n                }\n            }\n        }\n    }\n\n    /**\n     * find nearest wmo points. Returns an array of [[distance, GeoPoint]]\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians unless a converter is set\n     * @param {?function} converter fn return radians\n     * @returns {{[number, GeoPoint]}} distance from centerPoint and a GeoPoint of the wmo\n     */\n    *getNearestPoints(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        for (const geoPoint of this.getNearestPointsDirty(centerPoint, radius, null)) {\n            let distance = geoPoint.distanceTo(centerPoint, null);\n            if (distance <= radius) {\n                if (converter !== null) {\n                    distance /= converter(1.0);\n                }\n                yield [geoPoint, distance];\n            }\n        }\n    }\n}\n","/* eslint-disable max-lines-per-function */\nimport {km_to_rad, rad_to_km} from \"./geopoint\";\nimport {Route} from \"./route\";\n\n/**\n * Compute the Ogimet Route\n * @param {editolido.Route} route the route to find the ogimet route for\n * @param {number} segmentSize the result is split to this length\n * @param {string} name the name of the returned route\n * @param {string} description the description of the returned route\n */\nexport function ogimetRoute(wmoGrid, route, {name=\"\", description=\"\", segmentSize=300, algorithm='xtd'} = {}) {\n    const neighbourRadius = (rad_to_km(wmoGrid.gridSize) / 2.0) - 0.1\n\n    const getNeighbour = (point) => {\n        let neighbours = [...wmoGrid.getNearestPoints(point, neighbourRadius)];\n        if (neighbours.length > 0) {\n            neighbours = neighbours.sort((a, b) => a[1] - b[1]);\n            if (neighbours.map((a) => a[0].name).indexOf(point.name) >= 0) {\n                return [point, 0];\n            }\n            return [neighbours[0][0], neighbours[0][1]];\n        }\n        return [null, null];\n    };\n    const findStrategic = (start, end, results) => {\n        const length = results.length;\n        for (let k = end - 1; k > start; k -= 1) {\n            const o_xtd = results[k].ogimet.xtd_to(\n                [results[k].fpl, results[k + 1].fpl]\n            );\n            const f_xtd = results[k].fpl.xtd_to(\n                [results[start].ogimet, results[end].ogimet]\n            )\n            if (Math.abs(f_xtd) > Math.abs(o_xtd)) {\n                const d = (k < length - 1) ? results[k].fpl.distanceTo(results[k+1].fpl) : -1;\n                if (Math.abs(f_xtd) < d || d < 0) return k;\n            }\n        }\n        return null;\n    };\n\n    const filterByXtd = (results) => {\n        if (results.length === 0) return [];\n        const res = [results[0]];\n        let i = -1;\n        while (i < results.length - 1) {\n            i += 1;\n            let j = i + 2;\n            while (j <= results.length - 1) {\n                let k = findStrategic(i, j, results);\n                if (k === null) {\n                    j += 1;\n                } else {\n                    if (res.map((r) => r.ogimet.name).indexOf(results[k].ogimet.name) < 0) {\n                        res.push(results[k]);\n                    }\n                    i = k - 1;\n                    break;\n                }\n            }\n        }\n        res.push(results[results.length - 1]);\n        if (res.length < results.length) {\n            return filterByXtd(res);\n        }\n        return res;\n    };\n\n    // eslint-disable-next-line no-unused-vars\n    const lowestCrsIndex = (results) => {\n        let bestDiff = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const diff = Math.abs(\n                results[i - 1].ogimet.course_to(results[i].ogimet)\n                - results[i - 1].ogimet.course_to(results[i+1].ogimet)\n            );\n            if (best === null || diff < bestDiff) {\n                best = i;\n                bestDiff = diff;\n            }\n        }\n        return best;\n    };\n\n    const lowestXtdIndex = (results) => {\n        let bestXtd = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const xtd = Math.abs(\n                results[i].fpl.xtd_to([results[i - 1].ogimet, results[i + 1].ogimet])\n            );\n            if (best === null || xtd < bestXtd) {\n                best = i;\n                bestXtd = xtd;\n            }\n        }\n        return best;\n    }\n\n    let ogimetResults = [];\n    const o_index = {};\n    for (const p of route.split(60, {'converter': km_to_rad, 'preserve': true}).points) {\n        const [neighbour, x] = getNeighbour(p);\n        if (neighbour !== null) {\n            if (neighbour.name in o_index) {\n                if (o_index[neighbour.name][0] > x) {\n                    o_index[neighbour.name] = [x, p];\n                }\n            } else {\n                o_index[neighbour.name] = [x, p];\n            }\n            ogimetResults.push({'fpl': p, 'ogimet': neighbour});\n        }\n    }\n\n    // eslint-disable-next-line eqeqeq\n    ogimetResults = ogimetResults.filter((r) => o_index[r.ogimet.name][1] == r.fpl);\n    ogimetResults = filterByXtd(ogimetResults);\n    //console.log(ogimetResults.length);\n    const reduceFn = (algorithm === 'xtd' ? lowestXtdIndex: lowestCrsIndex);\n    while (ogimetResults.length > 21) {\n        const idx = reduceFn(ogimetResults);\n        ogimetResults = ogimetResults.slice(0, idx).concat(ogimetResults.slice(idx + 1));\n    }\n    return new Route(ogimetResults.map((r) => r.ogimet))\n                .split(segmentSize, {'preserve': true, 'name': name, 'description': description});\n}\n\n/**\n * Computes ogimet url\n * @param {editolido.OFP} ofp the OFP\n * @param {editolido.GeoGridIndex} wmoGrid  the loaded Grid\n */\nexport function ogimetData(ofp, wmoGrid, algorithm=\"xtd\") {\n    // timestamp for departure\n    const taxitime = ofp.infos['taxiTimeOUT'];\n    const ts = (ofp.infos['ofpOUT'].getTime() / 1000) + (taxitime * 60);\n    const now_ts = (new Date()).getTime() / 1000;\n    const tref = Math.round(Math.max(ts, now_ts)); //for old ofp timeref=now\n    const trefOfp = new Date(Math.round(ts) * 1000);\n    // const dateref = new Date(tref * 1000); //for caching we use the ofp time instead\n    // https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\n    const dateTimeFormat = new Intl.DateTimeFormat('en', {'year': '2-digit', 'month': 'short', 'day': '2-digit', 'hour': '2-digit', 'minute': '2-digit', 'hourCycle': 'h24', 'timeZone': 'UTC'});\n    const [{'value': month},,{'value': day},,{'value': year},,{'value': hour},,{'value': minute}] = dateTimeFormat.formatToParts(trefOfp);\n    const name = `Route Gramet ${ofp.infos['flightNo']} ${ofp.infos['depICAO']}-${ofp.infos['destICAO']} ${day}${month}${year} ${hour}:${minute}z OFP ${ofp.infos['ofp']}`;\n    let hini = 0;\n    let hfin = Math.ceil(ofp.infos.flightTime / 60);\n    const fl = ofp.infos.averageFL;\n    const route = ogimetRoute(wmoGrid, ofp.route,{name, algorithm});\n    const labels = route.points.filter(p => p.name !== \"\").map(p => p.name);\n    route.description = labels.join(' ');\n    const url = `http://www.ogimet.com/display_gramet.php?lang=en&hini=${hini}&tref=${tref}&hfin=${hfin}&fl=${fl}&hl=3000&aero=yes&wmo=${labels.join('_')}&submit=submit`;\n    const proxy = `${hini}-${Math.round(ts)}-${hfin}-${fl}-${labels.join('_')}`;\n    return {tref, name, route, 'wmo': labels, url, proxy};\n}\n","/* globals VERSION */\nexport const version = VERSION;\nexport {GeoPoint, nm_to_rad, rad_to_nm, rad_to_deg, dm_normalizer, arinc_normalizer, isARINC} from \"./modules/geopoint\"\nexport {AVENZAICONS, GOOGLEICONS, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, PIN_BLUE, PIN_BROWN, PIN_GREEN, PIN_NONE, PIN_ORANGE, PIN_PINK, PIN_PURPLE, PIN_RED, PIN_YELLOW} from \"./modules/kml_constants\";\nexport {Route, Track} from \"./modules/route\"\nexport {googleEarthStyleTemplate, avenzaIconTemplate, avenzaStyleTemplate, avenzaTemplate, iconTemplate, styleTemplate, template} from \"./modules/kml_templates\";\nexport {KMLGenerator} from \"./modules/kml\";\nexport {Ofp} from \"./modules/ofp\";\nexport {GEO_HASH_GRID_SIZE, GeoGridIndex} from \"./modules/geoindex\";\nexport {ogimetRoute, ogimetData} from \"./modules/ogimet\";\nexport {months3} from \"./modules/ofp_infos\";\nexport {StringExtractException, extract} from \"./modules/ofp_extensions\";\nexport {iata2GeoPoint, icao2iata, iata2icao, tzOffset, iata2tz} from \"./modules/iata2icao\";\n"],"sourceRoot":""}