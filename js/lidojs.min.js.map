{"version":3,"sources":["webpack://editolido/webpack/universalModuleDefinition","webpack://editolido/webpack/bootstrap","webpack://editolido/./node_modules/ngeohash/main.js","webpack://editolido/./src/modules/geolite.js","webpack://editolido/./src/modules/geopoint.js","webpack://editolido/./src/modules/kml_constants.js","webpack://editolido/./src/modules/route.js","webpack://editolido/./src/modules/kml_templates.js","webpack://editolido/./src/modules/kml.js","webpack://editolido/./src/modules/ofp_extensions.js","webpack://editolido/./src/modules/ofp_infos.js","webpack://editolido/./src/modules/ofp.js","webpack://editolido/./src/modules/geoindex.js","webpack://editolido/./src/modules/ogimet.js","webpack://editolido/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BASE32_CODES","BASE32_CODES_DICT","length","charAt","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","LatLng","constructor","this","format","v","letters","abs","degrees","floor","rest","minutes","cents","letter","padding","toFixed","padStart","rlat","phi","map","PI","LatPhi","R","rad_to_nm","radians","nm_to_rad","nm","km_to_rad","km","dm2decimal","indexOf","offset","parseInt","slice","parseFloat","array_normalizer","array","dm_normalizer","mixedValue","lng","Array","isArray","arinc_normalizer","label","signed","GeoPoint","description","normalizer","latlng","Reflect","has","trim","latphi_cache","dm_cache","asLatPhi","asDM","geopoint1","geopoint2","converter","distanceTo","course_to","point","segment","xtd_to","geopoints","options","howMany","x","y","z","latphi","cosrlat","cos","sin","atan2","sqrt","asLatLng","other","rlat1","phi1","rlat2","phi2","sd","acos","a","b","Number","toPrecision","crs_ab","crs_ad","dist_ad","xtd","asin","atFraction","fraction","distance","equals","toJSON","PIN_NONE","PIN_BLUE","PIN_YELLOW","PIN_BROWN","PIN_ORANGE","PIN_PINK","PIN_RED","PIN_GREEN","PIN_PURPLE","NAT_POSITION_ENTRY","NAT_POSITION_EXIT","PINS","GOOGLEICONS","AVENZAICONS","Route","points","iterator","route2","p1","p2","e","zip","segments","reduce","prev","current","accumulator","maxLength","preserve","remaining","first","maxRadians","segmentLength","Track","isMine","isComplete","super","pointTemplate","style","dm","lineTemplate","coordinates","segmentTemplate","folderTemplate","content","open","template","styles","folders","avenzaTemplate","styleTemplate","id","color","width","avenzaStyleTemplate","iconTemplate","href","avenzaIconTemplate","pinProp","KMLFolder","linestrings","placemarks","lineStyle","pinId","enabled","empty","newValue","oldStyle","newStyle","KMLGenerator","renderers","Map","icons","text","replace","computeOptions","folderName","folderPinInherit","pin","isNaN","addFolder","folder","set","addFolders","items","String","clone","deleteProperty","addLine","route","renderLine","addPoints","excluded","addPoint","addSegments","render","renderIconTemplate","renderStyleTemplate","renderTemplate","renderIcons","forEach","index","renderFolders","renderFolder","renderer","filter","concat","output","isSegment","tpl","changeFolderColor","changeFolderPin","changeFolderState","reset","setName","StringExtractException","start","end","endIsOptional","inclusive","from","to","substring","WptRegExp","RegExp","matchAll","str","result","console","geoPoints","match","wptRegExp","raw","months3","pdfParsers","freeze","ofpTypes","FISHPOINTS","require","Ofp","assert","startsWith","pdfParser","pdfjs","ofpType","S4","includes","NVP","infos","pattern","exec","flight","departure","destination","datetime","ofp","groups","date","day","month","year","hours","rawFplText","extract","duration","log","alternates","ralts","rawFS","taxitime","Date","UTC","ofpInfos","alert","exception","cache","fn","cacheStore","toISOString","wptCoordinates","wptCoordinatesAlternate","end_is_optional","reverse","isMyTrack","fplRoute","trackParser","results","parserResults","fishPoints","tracks","unknowns","f","trackRoute","trackIsComplete","labelDict","g","geoPoint","fpl","rawfpl","lidoRoute","rawPoints","lidoPoints","fplRouteLenght","innerFplRoute","innerFplRouteLength","reversedPoints","reversedLidoRoute","lidoRouteLength","track","fplPoints","needle","trackPoints","splice","recursiveNatReplace","unshift","GEO_HASH_GRID_SIZE","GeoGridIndex","precision","gridSize","toString","data","centerPoint","radius","suggestedPrecision","maxSize","entries","centerHash","meAndNeighbors","neighbors","hash","getNearestPointsDirty","ogimetRoute","wmoGrid","segmentSize","algorithm","neighbourRadius","getNeighbour","neighbours","getNearestPoints","sort","findStrategic","k","o_xtd","ogimet","f_xtd","filterByXtd","res","j","ogimetResults","o_index","neighbour","reduceFn","bestXtd","best","maxi","bestDiff","diff","idx","ogimetData","ts","valueOf","now_ts","tref","dateref","dateTimeFormat","Intl","DateTimeFormat","hour","minute","formatToParts","hfin","levels","fl","labels","url","version","VERSION"],"mappings":"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","file":"lidojs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"editolido\"] = factory();\n\telse\n\t\troot[\"editolido\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nrlat is the latitude in radians (lambda is a reserved name in python)\nphi is the longitude in radians\n\nLatLng is the base object when using degrees\nLatPhi is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {LatPhi} asLatPhi - convert to a LatPhi\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asLatPhi() {\n        const [rlat, phi] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new LatPhi(rlat, phi);\n    }\n}\n\n/**\n * LatPhi\n *\n * @property {number} rlat - latitude in radians\n * @property {number} phi - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass LatPhi {\n    constructor(rlat, phi) {\n        this.rlat = rlat;\n        this.phi = phi;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatPhi';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.rlat, this.phi].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst latphi2latlng = (latphi) => latphi.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\n\nexport {\n    LatLng, LatPhi, latphi2latlng, latlng2dm\n};\n","import {LatLng, LatPhi} from \"./geolite\";\n\n\n// earth mean radius in meters\n// nm in meters\nconst R = 6371000.0;\nconst NM = 1852.0;\n\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new LatLng(...array);\n    }\n    return new LatLng([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new LatLng(dm2decimal(lat), dm2decimal(lng))\n}\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new LatLng(lat, -lng);\n            case 'E': // NE + +\n                return new LatLng(lat, lng);\n            case 'S': // SE - +\n                return new LatLng(-lat, lng);\n            case 'W': // SW - -\n                return new LatLng(-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new LatLng(lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof LatLng) {\n            this.latlng = mixedValue;\n        } else if (mixedValue && typeof mixedValue === 'object'\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new LatLng(parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.latphi_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion LatPhi\n     * @returns {LatPhi}\n     */\n    get latphi() {\n        if (this.latphi_cache === null) {\n            this.latphi_cache = this.latlng.asLatPhi;\n        }\n        return this.latphi_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Get the course in radians between to GeoPoints\n     * @param {GeoPoint} geopoint1 start GeoPoint\n     * @param {GeoPoint} geopoint2 end GeoPoint\n     * @returns {number} the course in radians\n     */\n    static course(geopoint1, geopoint2) {\n        return geopoint1.course_to(geopoint2);\n    }\n\n    /**\n     * Given the segment AB, computes cross track error at point D\n     * @param {GeoPoint} point GeoPoint D\n     * @param {[GeoPoint, GeoPoint]} segment segment AB\n     * @param {?function} converter the converter to use\n     * @returns {number} the xtd in radians unless a converter is given\n     */\n    static xtd(point, segment, converter=null) {\n        return point.xtd_to(segment, converter);\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options={}) {\n        let howMany = geopoints.length,\n            phi = 0,\n            rlat = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            rlat = p.latphi.rlat;\n            phi = p.latphi.phi;\n            let cosrlat = Math.cos(rlat);\n            x += cosrlat * Math.cos(phi);\n            y += cosrlat * Math.sin(phi);\n            z += Math.sin(rlat);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        phi = Math.atan2(y, x);\n        return new GeoPoint(new LatPhi(rlat, phi).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const sd = Math.acos(\n            Math.sin(rlat1) * Math.sin(rlat2)\n            + Math.cos(rlat1) * Math.cos(rlat2) * Math.cos(phi2 - phi1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * Get the course to another point\n     * @param {GeoPoint} other GeoPoint\n     * @returns {number} the course in radian\n     */\n    course_to(other) {\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const fmod = (a, b) => Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n        return fmod(\n            Math.atan2(\n                Math.sin(phi1 - phi2) * Math.cos(rlat2),\n                Math.cos(rlat1) * Math.sin(rlat2) - Math.sin(rlat1) * Math.cos(rlat2) * Math.cos(phi1 - phi2)\n            ),\n            2 * Math.PI\n        );\n    }\n\n    /**\n     * Given the segment AB; computes cross track error\n     * @param {[GeoPoint, GeoPoint]} segment the segment AB \n     * @param {?function} converter the converter to use otherwise result in radians\n     * @returns {number} the distance in radian unless a converter is set\n     */\n    xtd_to(segment, converter=null) {\n        const crs_ab = segment[0].course_to(segment[1]);\n        const crs_ad = segment[0].course_to(this);\n        const dist_ad = segment[0].distanceTo(this);\n        const xtd = Math.asin(Math.sin(dist_ad) * Math.sin(crs_ad - crs_ab));\n        if (converter !== null) {\n            return converter(xtd);\n        }\n        return xtd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(rlat1) * Math.cos(phi1) + b * Math.cos(rlat2) * Math.cos(phi2);\n        const y = a * Math.cos(rlat1) * Math.sin(phi1) + b * Math.cos(rlat2) * Math.sin(phi2);\n        const z = a * Math.sin(rlat1) + b * Math.sin(rlat2);\n        const rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const phi = Math.atan2(y, x);\n        return new GeoPoint(new LatPhi(rlat, phi).asLatLng);\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\nexport {array_normalizer, dm_normalizer, arinc_normalizer, GeoPoint,dm2decimal,km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, NM, R};\n","export const PIN_NONE = 0\nexport const PIN_BLUE = 1\nexport const PIN_YELLOW = 2\nexport const PIN_BROWN = 3 // not available in Avenza\nexport const PIN_ORANGE = 4\nexport const PIN_PINK = 5 // not available in Avenza\nexport const PIN_RED = 6\nexport const PIN_GREEN = 7\nexport const PIN_PURPLE = 8\n\nexport const NAT_POSITION_ENTRY = 0\nexport const NAT_POSITION_EXIT = 1\n\nexport const PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nexport const GOOGLEICONS = [\n    'FFFFFF', '6699FF', 'FFFF00',\n    'CC9966', 'FF9922', 'DD5599',\n    'FF0000', '22DD44', 'BB11EE',\n].map(c => `http://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=|${c}`);\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nexport const AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png`);\n","import {nm_to_rad, rad_to_nm} from \"./geopoint\";\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {GeoPoint[]}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=rad_to_nm) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} [options.converter] - must transform maxLength in radians\n     * @param {?boolean} [options.preserve] - if false, split at maxLength, do not keep intermediary points\n     * @param {string} [options.name] - generated route name\n     * @param {string} [options.description] - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options = {}){\n        let {converter=nm_to_rad, preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength;\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n\n    /**\n     * Given a track letter, returns the track label used in FPL\n     * @param {string} letter the track letter designator\n     * @return {string} the track label\n     */\n    static label(letter) {\n        return `NAT${letter}`;\n    }\n}\n\nexport {Route, Track};\n","/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nexport const pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nexport const folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nexport const styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nexport const avenzaStyleTemplate = ({id, color, width=3}) => styleTemplate({id, color, width});\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nexport const iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => `\n    <Style id=\"${id}\">\n        <IconStyle>\n            <Icon>\n                <href><![CDATA[${href}]]></href>\n            </Icon>\n            <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n        </IconStyle>\n    </Style>\n`;\n\nexport const avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n","/* eslint-disable max-lines */\nimport {GOOGLEICONS, PINS, PIN_NONE} from \"./kml_constants\";\nimport {\n    folderTemplate, iconTemplate, lineTemplate, pointTemplate, segmentTemplate, styleTemplate, template\n} from \"./kml_templates\";\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? PIN_NONE : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = PINS[this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = PINS[newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || template;\n        this.pointTemplate = renderers.pointTemplate || pointTemplate;\n        this.lineTemplate = renderers.lineTemplate || lineTemplate;\n        this.folderTemplate = renderers.folderTemplate || folderTemplate;\n        this.styleTemplate = renderers.styleTemplate || styleTemplate;\n        this.iconTemplate = renderers.iconTemplate || iconTemplate;\n        this.segmentTemplate = renderers.segmentTemplate || segmentTemplate;\n        this.icons = renderers.icons || GOOGLEICONS;\n        this.name = undefined;\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = PINS[options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} [items.pinId=0] - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = PIN_NONE;\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        const renderIconTemplate = options.iconTemplate || this.iconTemplate;\n        const renderStyleTemplate = options.styleTemplate || this.styleTemplate;\n        const renderTemplate = options.template || this.template;\n        const renderIcons = options.icons || this.icons;\n        PINS.forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': PINS[index].slice(1), 'href': renderIcons[index]};\n                styles += renderIconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += renderStyleTemplate(folder.lineStyle)\n            }\n        }\n        if (!options.name) options.name = this.name;\n        return renderTemplate({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === PIN_NONE || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n    /**\n     * set the default name inserted in template\n     * @param {string} name the name/description\n     */\n    setName(name) {\n        this.name = name;\n    }\n}\n\nexport {KMLGenerator};\n","import {GeoPoint, dm_normalizer} from \"./geopoint\";\n\n/**\n * Exception thrown when a search term is not found\n */\nclass StringExtractException extends Error {}\n\n/**\n * Defines an extract method on the String prototype\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nReflect.defineProperty(String.prototype, 'extract', {\n  value(start, end, endIsOptional = true, inclusive = false) {\n    let from = 0;\n    let to = 0;\n    if (start) {\n      from = this.indexOf(start);\n      if (from === -1) {\n        throw new StringExtractException(`${start} not found`);\n      }\n      if (!inclusive) {\n        from += start.length;\n      }\n    }\n    if (!end) {\n      return this.substring(from);\n    }\n    to = this.indexOf(end, from);\n    if (to === -1) {\n      if (endIsOptional) {\n        return this.substring(from);\n      }\n      throw new StringExtractException(`${end} not found`);\n    } else if (inclusive) {\n      to += end.length;\n    }\n    return this.substring(from, to);\n  }\n});\n\n\n/**\n * A matchAll RegExp to extract WPT COORDINATES from text\n * @return {GeoPoint[]}\n */\nclass WptRegExp extends RegExp {\n\n  /**\n   * matchAll methods to return an array of GeoPoint\n   * @param str\n   * @returns {GeoPoint[]}\n   */\n  [Symbol.matchAll](str) {\n    // eslint-disable-next-line prefer-reflect\n    let result = RegExp.prototype[Symbol.matchAll].call(this, str);\n    if (!result) {\n      console.error(\"WPT Coordinates regexp failed\");\n      return [];\n    }\n    let geoPoints = [];\n    Array.from(result).forEach((match) => {\n      let name = match[1].trim().replace(/^-+/u, \"\");\n      if (name === \"\") {\n        name = match[2] + match[3];\n      }\n      geoPoints.push(\n        new GeoPoint(\n          [match[2], match[3]],\n          {\"name\": name, \"normalizer\": dm_normalizer})\n      );\n    });\n    return geoPoints;\n  }\n}\nconst wptRegExp = new WptRegExp(String.raw`(\\S+|\\s+)\\s+([NS]\\d{4}\\.\\d)([EW]\\d{5}\\.\\d)`, 'gu');\n\nexport {wptRegExp};\n","/* eslint-disable max-lines-per-function */\n\n\nconst months3 = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n Dictionary of common OFP data:\n - flight (AF009)\n - departure (KJFK)\n - destination (LFPG)\n - datetime (a javascript Date object for scheduled departure block time)\n - date (OFP text date 25Apr2016)\n - datetime2 (a javascript Date object for scheduled arrival landing time)\n - duration [hours, minutes] hours and minutes are Number\n - ofp (OFP number 9/0/1)\n - alternates an array of alternate\n - ralts an array of route alternates (ETOPS)\n - taxitime (departure taxi time in mn)\n - rawfpl the raw text of the FPL\n * @param text The OFP in text format\n * @returns {{duration: number[], flight: string, datetime: Date, taxitime: number, destination: string, ofp: string, ralts: [], departure: string, alternates: [], rawfpl: string}}\n */\nfunction ofpInfos(text) {\n  let pattern = /(?<flight>AF\\s+\\S+\\s+)(?<departure>\\S{4})\\/(?<destination>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\d+\\S{0,8})/u;\n  let match = pattern.exec(text);\n  if (match === null) {\n    pattern = /(?<flight>AF.+)(?<departure>\\S{4})\\/(?<destination>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\S+)Main/u;\n    match = pattern.exec(text);\n  }\n  let {flight, departure, destination, datetime, ofp} = match.groups;\n  // datetime is like 27Sep2019/1450\n  const [date] = datetime.split('/', 1);\n  const day = parseInt(datetime.substring(0,2), 10);\n  const month = months3.indexOf(datetime.substring(2,5));\n  const year = parseInt(datetime.substring(5,9), 10);\n  const hours = parseInt(datetime.substring(10,12), 10);\n  const minutes = parseInt(datetime.substring(12,14), 10);\n\n  const rawFplText = text\n    .extract(\"ATC FLIGHT PLAN\", \"TRACKSNAT\")\n    .extract(\"(\", \")\", false, true);\n\n  pattern = new RegExp(String.raw`-${destination}(\\d{4})\\s`, \"u\");\n  match = pattern.exec(rawFplText);\n  let duration = [1, 0];\n  if (match === null) {\n    console.log(\"flight duration not found, arbitrary set to 1 hour\");\n  } else {\n    duration = [\n      parseInt(match[1].substring(0,2), 10),\n      parseInt(match[1].substring(2,4), 10)\n    ];\n  }\n\n  // try with 2 alternates first\n  pattern = new RegExp(String.raw`-${destination}.+\\s(\\S{4})\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n  match = pattern.exec(rawFplText);\n  let alternates = [];\n  if (match !== null){\n    alternates.push(match[1]);\n    alternates.push(match[2]);\n  } else {\n     pattern = new RegExp(String.raw`-${destination}.+\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n     match = pattern.exec(rawFplText);\n     if (match !== null) {\n       alternates.push(match[1]);\n     }\n  }\n\n  pattern = /RALT\\/((?:\\S{4}[ \\n])+)/u;\n  match = pattern.exec(rawFplText);\n  let ralts = [];\n  if (match !== null) {\n    ralts.push(match[1].split(/\\s/u));\n  }\n\n  const rawFS = text.extract(\"FLIGHT SUMMARY\", \"Generated\");\n  pattern = /\\s(\\d{2})(\\d{2})\\s+TAXI IN/u;\n  match = pattern.exec(rawFS);\n  let taxitime = 15;\n  if (match === null) {\n    console.log(\"taxitime not found, arbitrary set to 15mn\");\n  } else {\n    taxitime = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n\n  return {\n    \"flight\": flight.replace(/\\s/gu, \"\"),\n    \"departure\": departure,\n    \"destination\": destination,\n    \"datetime\": new Date(Date.UTC(year, month, day, hours, minutes)),\n    \"datetime2\": new Date(Date.UTC(year, month, day, hours + duration[0], minutes + duration[1] + taxitime)),\n    \"date\": date,\n    \"ofp\": ofp.replace(\"\\xA9\", \"\"),\n    \"duration\": duration,\n    \"alternates\": alternates,\n    \"ralts\": ralts,\n    \"taxitime\": taxitime,\n    \"rawfpl\": rawFplText\n  }\n}\nexport {ofpInfos};\n","/* eslint-disable no-underscore-dangle,max-lines-per-function, max-lines */\n\nimport {GeoPoint, arinc_normalizer} from \"./geopoint\";\nimport {Route, Track} from \"./route\";\nimport {wptRegExp} from \"./ofp_extensions\";\n// eslint-disable-next-line sort-imports\nimport {ofpInfos} from \"./ofp_infos\";\n\n\nconst pdfParsers = Object.freeze({\n  \"pypdf2\": 3,\n  \"pdfjs\": 4\n});\n\nconst ofpTypes = Object.freeze({\n  \"S4\": 1,\n  \"NVP\": 2\n});\n\nconst FISHPOINTS = require('./fishpoints');\n\nexport class Ofp {\n  constructor(text=\"\") {\n    console.assert(text.startsWith(\"_PDFJS_\"), \"invalid text file\");\n    this.text = text;\n    this.pdfParser = pdfParsers.pdfjs;\n    this.ofpType = ofpTypes.S4;\n    if (text.includes(\"--FLIGHT SUMMARY--\")) {\n      this.ofpType = ofpTypes.NVP;\n    }\n\n    try {\n      this.infos = ofpInfos(text);\n    } catch (error) {\n      console.error(error);\n      try {\n        if (window) {\n          // eslint-disable-next-line no-alert\n          window.alert(`Erreur: {error}` )\n        }\n      } catch (exception) {\n        // not in browser, just log\n      }\n      throw error;\n    }\n\n    this.cache = function (name, fn) {\n      if (this.cacheStore === undefined) {\n        this.cacheStore = {}; /* on first run create cache storage */\n      }\n      if (this.cacheStore[name] === undefined) {\n        this.cacheStore[name] = fn();\n      }\n      return this.cacheStore[name];\n    };\n  }\n\n  get description() {\n    const infos = this.infos;\n    return `${infos.flight} ${infos.departure}-${infos.destination} ${infos.date} ${infos.datetime.toISOString().substring(11,16)}z OFP ${infos.ofp}`;\n  }\n\n  /**\n   * Array of WPT COORDINATES found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinates(start=\"WPT COORDINATES\") {\n    const infos = this.infos;\n    const end = (this.ofpType === ofpTypes.NVP) ? '----' + infos['destination']: '----';\n    const extract = this.text.extract(start, end);\n    return extract.matchAll(wptRegExp);\n  }\n\n  /**\n   * Array of WPT COORDINATES for alternate found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinatesAlternate(start='WPT COORDINATES', end_is_optional=false) {\n\n    const end = (this.ofpType === ofpTypes.NVP) ? '--WIND INFORMATION--': 'ATC FLIGHT PLAN';\n    // take only what is after the last '----' (python rsplit)\n    // eslint-disable-next-line require-jsdoc\n    function reverse(str) {\n      return [...str].reverse().join('');\n    }\n    const t = this.text.extract(start, end, end_is_optional)\n    const extract = reverse(t).split('----', 1)[0];\n    return reverse(extract).matchAll(wptRegExp);\n  }\n\n  /**\n   * check if the designated track is in the FPL\n   * @param letter\n   * @returns {boolean}\n   */\n  isMyTrack(letter) {\n    return this.fplRoute.indexOf(Track.label(letter)) !== -1;\n  }\n\n  /**\n   * Parse the OFP and return tracks as an array of [trackLetter, trackDescription]\n   * @returns {[]}\n   */\n  trackParser() {\n    let extract = \"\";\n    try {\n      extract = this.text\n        .extract(\"ATC FLIGHT PLAN\", \"NOTES:\").extract(')');\n    } catch (e) {\n      return [];\n    }\n    let results = [];\n    if (extract.includes(\"REMARKS:\")) {\n      extract = extract.split(\"REMARKS:\", 1)[0];\n      extract = extract.split(\"Generated at\", 1)[0];\n    }\n    if (extract.includes(\" LVLS \")) {\n      // split at track letter, discard first part\n      const a = extract.split(/(?:\\s|[^A-Z\\d])([A-Z])\\s{3}/gu).slice(1);\n      // results are [trackLetter, trackDescription]\n      for (let i = 0, max = a.length; i < max; i += 2) {\n        results.push([a[i], a[i + 1]]);\n      }\n    } else if (extract.includes('TRACKS')) {\n      console.error(\"Unknown TRACKSNAT message format\");\n      console.log(extract);\n    }\n    return results;\n  }\n\n  /**\n   * Tracks found in the OFP as an array of Track\n   * @returns {Track[]}\n   */\n  get tracks() {\n    return this.cache(\"tracks\", () => {\n      let parserResults = this.trackParser();\n      const pattern = /(\\d{2,4}[NS]\\d{3,5}[EW]|[NESW]\\d{4}|\\d[NESW]\\d{3}[^EW])/u;\n      let fishPoints = {};\n      let tracks = [];\n\n      //find unknows named waypoints in tracks\n      let unknowns = [];\n      // eslint-disable-next-line array-callback-return\n      parserResults.map(([, description]) => {\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) === null) {\n                unknowns.push(label);\n              }\n            }\n          });\n      });\n      // console.debug(`Unknown track points: ${unknowns}`);\n      unknowns.forEach((name) => {\n        const f = FISHPOINTS[name];\n        if (f !== undefined) {\n          fishPoints[name] = new GeoPoint(f, {\"name\": name});\n        }\n      });\n\n      parserResults.forEach(([letter, description]) => {\n        let trackRoute = [];\n        let trackIsComplete = true;\n        const isMine = this.isMyTrack(letter);\n        let labelDict = (isMine) ? {} : fishPoints;\n        if (isMine) {\n          this.route.points.forEach((g) => {\n            if (g.name !== \"\") {\n              labelDict[g.name] = g\n            }\n          })\n        }\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) !== null) {\n                trackRoute.push(new GeoPoint(label, {\n                  \"name\": label,\n                  \"normalizer\": arinc_normalizer\n                }));\n              } else {\n                let geoPoint = labelDict[label];\n                if (geoPoint !== undefined) {\n                  trackRoute.push(new GeoPoint(geoPoint, {\"name\": label}));\n                } else {\n                  trackIsComplete = false;\n                }\n              }\n            }\n          });\n        tracks.push(new Track(trackRoute,\n          {\n            \"name\": `NAT ${letter}`,\n            \"description\": description,\n            \"isMine\": isMine,\n            \"isComplete\": trackIsComplete\n          }));\n      });\n      return tracks;\n    });\n  }\n\n  /**\n   * Returns FPL as an Array\n   * @returns {string[]}\n   */\n  fpl() {\n    const infos = this.infos;\n    let text = infos.rawfpl\n      .extract(`-${infos.departure}`, `-${infos.destination}`, false);\n    text = text.substring(text.indexOf(\" \") + 1);\n    let results = [infos.departure];\n    text.split(\" \").map((v) => v.trim())\n      .forEach((v) => {\n        if (v !== \"\" && !v.startsWith(\"-N\")){\n          results.push(v);\n        }\n      });\n    results.push(infos.destination);\n    return results;\n  }\n\n  /**\n   * FPL route found in OFP (fpl without speed/FL annotations)\n   * @returns {string[]}\n   */\n  get fplRoute() {\n    return this.cache(\"fplRoute\",\n      () => this.fpl().map((p) => {\n        if (p.includes(\"/\")) {\n          return p.split(\"/\", 1)[0];\n        }\n        return p;\n      })\n    );\n  }\n\n  get route() {\n    return this.cache(\"route\", () => new Route(this.wptCoordinates()));\n  }\n\n  lidoRoute() {\n    return this.cache(\"lidoRoute\", () => {\n      const points = [];\n      const rawPoints = [];\n      this.route.points.forEach((p) => {\n        rawPoints.push(p.dm);\n        if (p.name === \"\" || (/\\d+/u).exec(p.name) !== null) {\n          points.push(p.dm);\n        } else {\n          points.push(p.name);\n        }\n      });\n      let lidoPoints = [];\n\n      let fplRoute = this.fplRoute;\n      let fplRouteLenght = fplRoute.length;\n      if (fplRouteLenght < 2) {\n        return points;\n      }\n      let departure = fplRoute[0];\n      let destination = fplRoute[fplRouteLenght - 1];\n      let innerFplRoute = fplRoute.slice(1, -1);\n      let innerFplRouteLength = innerFplRoute.length;\n\n      // replace points by rawPoint before first common waypoint\n      for (let i = 0; i < innerFplRouteLength; i += 1 ) {\n        let p = innerFplRoute[i];\n        let offset = points.indexOf(p);\n        if (offset !== -1) {\n          lidoPoints = rawPoints.slice(1, offset).concat(innerFplRoute.slice(i));\n          break;\n        }\n      }\n\n      // replace points after last common waypoint by rawPoints\n      let reversedPoints = points.slice().reverse(); // copy before reverse\n      let reversedLidoRoute = lidoPoints.slice().reverse();\n      let lidoRouteLength = lidoPoints.length;\n      for (let i = 0; i < lidoRouteLength; i += 1 ) {\n        let p = reversedLidoRoute[i];\n        let offset = reversedPoints.indexOf(p);\n        if (offset !== -1) {\n          if (i > 0) {\n            lidoPoints = lidoPoints.slice(0, -i);\n          }\n          lidoPoints = lidoPoints.concat(rawPoints.slice(-offset, -1));\n          break;\n        }\n      }\n      // replace known tracks (NATA, NATB...) by track_points\n      /**\n       * When there is a FL or Speed change, we may have multiple\n       * \"NATW\" in the FPL, so change them all.\n       * @param fplPoints: [] - an array of fplPoints\n       * @param needle: string\n       * @param trackPoints\n       * @returns {[]}\n       */\n      const recursiveNatReplace = function (fplPoints, needle, trackPoints) {\n        let match = [];\n        // infinite loop (while(true) breaks in browser)\n        // https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript\n        for (;;) {\n          let offset = fplPoints.indexOf(needle);\n          if (offset === -1) {\n            return match;\n          }\n          fplPoints.splice(offset, 1, ...trackPoints.slice(\n            trackPoints.indexOf(fplPoints[offset - 1]) +1,\n            trackPoints.indexOf(fplPoints[offset + 1])));\n          match = fplPoints;\n        }\n      };\n\n      this.tracks.forEach( (track) => {\n        if (track.isMine) {\n          let letter = track.name.slice(-1);\n          let results = recursiveNatReplace(\n            lidoPoints,\n            Track.label(letter),\n            track.points.map((p) => p.name)\n          );\n          if (results.length > 0) {\n            lidoPoints = results;\n          }\n        }\n      });\n      lidoPoints.push(destination);\n      lidoPoints.unshift(departure);\n      // adds alternates and ralts\n      lidoPoints = lidoPoints.concat(...this.infos.alternates);\n      lidoPoints= lidoPoints.concat(...this.infos.ralts);\n      return lidoPoints;\n    });\n  }\n}\n","import {GeoPoint, km_to_rad} from \"./geopoint\";\nimport geohash from \"ngeohash\";\n\n// dependence between hashtag's precision and distance accurate calculating\n// in fact it's sizes of grids in km\nexport const GEO_HASH_GRID_SIZE = {\n    \"1\": 5000.0,\n    \"2\": 1260.0,\n    \"3\": 156.0,\n    \"4\": 40.0,\n    \"5\": 4.8,\n    \"6\": 1.22,\n    \"7\": 0.152,\n    \"8\": 0.038\n}\n\nexport class GeoGridIndex {\n    constructor(precision=3) {\n        this.precision = precision;\n        this.gridSize = km_to_rad(GEO_HASH_GRID_SIZE[precision.toString()]);\n        this.data = {};\n    }\n\n    /**\n     * Get Nearest points based on the geohash of the point\n     * It returns all wmo points in the 9 adjacents tiles\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians (unless a converter is given)\n     * @param {?function} converter\n     * @generator {GeoPoint}\n     */\n    *getNearestPointsDirty(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        if (radius > this.gridSize / 2.0) {\n            // radius is too big for current grid, we cannot use 9 neighbors\n            // to cover all possible points\n            let suggestedPrecision = 0;\n            for (const [precision, maxSize] of Object.entries(GEO_HASH_GRID_SIZE)) {\n                if (radius > km_to_rad(maxSize) / 2.0) {\n                    suggestedPrecision = parseInt(precision, 10) - 1;\n                    break;\n                }\n            }\n            throw new Error(`Too large radius, please rebuild GeoHashGrid with precision=\"${suggestedPrecision}\"`);\n        }\n        const centerHash = geohash.encode(centerPoint.latitude, centerPoint.longitude, this.precision);\n        let meAndNeighbors = geohash.neighbors(centerHash);\n        meAndNeighbors.push(centerHash);\n        for (const hash of meAndNeighbors) {\n            if (hash in this.data) {\n                for (const [name, latitude, longitude] of this.data[hash]) {\n                    yield new GeoPoint([latitude, longitude], {\"name\": name});\n                }\n            }\n        }\n    }\n\n    /**\n     * find nearest wmo points. Returns an array of [[distance, GeoPoint]]\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians unless a converter is set\n     * @param {?function} converter fn return radians\n     * @returns {{[number, GeoPoint]}} distance from centerPoint and a GeoPoint of the wmo\n     */\n    *getNearestPoints(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        for (const geoPoint of this.getNearestPointsDirty(centerPoint, radius, null)) {\n            let distance = geoPoint.distanceTo(centerPoint, null);\n            if (distance <= radius) {\n                if (converter !== null) {\n                    distance /= converter(1.0);\n                }\n                yield [geoPoint, distance];\n            }\n        }\n    }\n}\n","/* eslint-disable max-lines-per-function */\nimport {km_to_rad, rad_to_km} from \"./geopoint\";\nimport {Route} from \"./route\";\n\n/**\n * Compute the Ogimet Route\n * @param {editolido.Route} route the route to find the ogimet route for\n * @param {number} segmentSize the result is split to this length\n * @param {string} name the name of the returned route\n * @param {string} description the description of the returned route\n */\nexport function ogimetRoute(wmoGrid, route, {name=\"\", description=\"\", segmentSize=300, algorithm='xtd'} = {}) {\n    const neighbourRadius = (rad_to_km(wmoGrid.gridSize) / 2.0) - 0.1\n\n    const getNeighbour = (point) => {\n        let neighbours = [...wmoGrid.getNearestPoints(point, neighbourRadius)];\n        if (neighbours.length > 0) {\n            neighbours = neighbours.sort((a, b) => a[1] - b[1]);\n            if (neighbours.map((a) => a[0].name).indexOf(point.name) >= 0) {\n                return [point, 0];\n            }\n            return [neighbours[0][0], neighbours[0][1]];\n        }\n        return [null, null];\n    };\n\n    const findStrategic = (start, end, results) => {\n        for (let k = end - 1; k > start; k -= 1) {\n            const o_xtd = results[k].ogimet.xtd_to(\n                [results[k].fpl, results[k + 1].fpl]\n            );\n            const f_xtd = results[k].fpl.xtd_to(\n                [results[start].ogimet, results[end].ogimet]\n            )\n            if (Math.abs(f_xtd) > Math.abs(o_xtd)) {\n                return k;\n            }\n        }\n        return null;\n    };\n\n    const filterByXtd = (results) => {\n        const res = [results[0]];\n        let i = -1;\n        while (i < results.length - 1) {\n            i += 1;\n            let j = i + 2;\n            while (j <= results.length - 1) {\n                let k = findStrategic(i, j, results);\n                if (k === null) {\n                    j += 1;\n                } else {\n                    if (res.map((r) => r.ogimet.name).indexOf(results[k].ogimet.name) < 0) {\n                        res.push(results[k]);\n                    }\n                    i = k - 1;\n                    break;\n                }\n            }\n        }\n        res.push(results[results.length - 1]);\n        if (res.length < results.length) {\n            return filterByXtd(res);\n        }\n        return res;\n    };\n\n    // eslint-disable-next-line no-unused-vars\n    const lowestCrsIndex = (results) => {\n        let bestDiff = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const diff = Math.abs(\n                results[i - 1].ogimet.course_to(results[i].ogimet)\n                - results[i - 1].ogimet.course_to(results[i+1].ogimet)\n            );\n            if (best === null || diff < bestDiff) {\n                best = i;\n                bestDiff = diff;\n            }\n        }\n        return best;\n    };\n\n    const lowestXtdIndex = (results) => {\n        let bestXtd = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const xtd = Math.abs(\n                results[i].fpl.xtd_to([results[i - 1].ogimet, results[i + 1].ogimet])\n            );\n            if (best === null || xtd < bestXtd) {\n                best = i;\n                bestXtd = xtd;\n            }\n        }\n        return best;\n    }\n\n    let ogimetResults = [];\n    const o_index = {};\n    for (const p of route.split(60, {'converter': km_to_rad, 'preserve': true}).points) {\n        const [neighbour, x] = getNeighbour(p);\n        if (neighbour !== null) {\n            if (neighbour.name in o_index) {\n                if (o_index[neighbour.name][0] > x) {\n                    o_index[neighbour.name] = [x, p];\n                }\n            } else {\n                o_index[neighbour.name] = [x, p];\n            }\n            ogimetResults.push({'fpl': p, 'ogimet': neighbour});\n        }\n    }\n\n    // eslint-disable-next-line eqeqeq\n    ogimetResults = ogimetResults.filter((r) => o_index[r.ogimet.name][1] == r.fpl);\n    ogimetResults = filterByXtd(ogimetResults);\n    //console.log(ogimetResults.length);\n    const reduceFn = (algorithm === 'xtd' ? lowestXtdIndex: lowestCrsIndex);\n    while (ogimetResults.length > 21) {\n        const idx = reduceFn(ogimetResults);\n        ogimetResults = ogimetResults.slice(0, idx).concat(ogimetResults.slice(idx + 1));\n    }\n    return new Route(ogimetResults.map((r) => r.ogimet))\n                .split(segmentSize, {'preserve': true, 'name': name, 'description': description});\n}\n\n/**\n * Computes ogimet url\n * @param {editolido.OFP} ofp the OFP\n * @param {editolido.GeoGridIndex} wmoGrid  the loaded Grid\n */\nexport function ogimetData(ofp, wmoGrid, algorithm=\"xtd\") {\n    // timestamp for departure\n    const taxitime = ofp.infos['taxitime'];\n    const ts = (ofp.infos['datetime'].valueOf() / 1000) + (taxitime * 60);\n    const now_ts = (new Date()).valueOf() / 1000;\n    const tref = Math.round(Math.max(ts, now_ts)); //for old ofp timeref=now\n    const dateref = new Date(tref * 1000);\n    // https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\n    const dateTimeFormat = new Intl.DateTimeFormat('en', {'year': '2-digit', 'month': 'short', 'day': '2-digit', 'hour': '2-digit', 'minute': '2-digit'});\n    const [{'value': month},,{'value': day},,{'value': year},,{'value': hour},,{'value': minute}] = dateTimeFormat.formatToParts(dateref);\n    const name = `Route Gramet ${ofp.infos['flight']} ${ofp.infos['departure']}-${ofp.infos['destination']} ${day}${month}${year} ${hour}:${minute}z OFP ${ofp.infos['ofp']}`;\n    let hini = 0;\n    let hfin = ofp.infos['duration'][0] + 1;\n    const levels = [...ofp.infos['rawfpl'].matchAll(/F(\\d{3})\\s/ug)].map(v => (v[1]*1));\n    let fl = 300;\n    if (levels && levels.length) {\n        fl = Math.round(levels.reduce((a, b) => a + b, 0) / levels.length);\n    }\n    const route = ogimetRoute(wmoGrid, ofp.route,{name, algorithm});\n    const labels = route.points.filter(p => p.name !== \"\").map(p => p.name);\n    route.description = labels.join(' ');\n    const url = `http://www.ogimet.com/display_gramet.php?lang=en&hini=${hini}&tref=${tref}&hfin=${hfin}&fl=${fl}&hl=3000&aero=yes&wmo=${labels.join('_')}&submit=submit`;\n    return {tref, name, route, 'wmo': labels, url};\n}\n","/* globals VERSION */\nexport const version = VERSION;\nexport {GeoPoint, nm_to_rad, rad_to_nm} from \"./modules/geopoint\"\nexport {AVENZAICONS, GOOGLEICONS, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, PIN_BLUE, PIN_BROWN, PIN_GREEN, PIN_NONE, PIN_ORANGE, PIN_PINK, PIN_PURPLE, PIN_RED, PIN_YELLOW} from \"./modules/kml_constants\";\nexport {Route, Track} from \"./modules/route\"\nexport {avenzaIconTemplate, avenzaStyleTemplate, avenzaTemplate, iconTemplate, styleTemplate, template} from \"./modules/kml_templates\";\nexport {KMLGenerator} from \"./modules/kml\";\nexport {Ofp} from \"./modules/ofp\";\nexport {GEO_HASH_GRID_SIZE, GeoGridIndex} from \"./modules/geoindex\";\nexport {ogimetRoute, ogimetData} from \"./modules/ogimet\";\n"],"sourceRoot":""}