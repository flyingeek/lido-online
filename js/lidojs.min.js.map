{"version":3,"sources":["webpack://editolido/webpack/universalModuleDefinition","webpack://editolido/./node_modules/ngeohash/main.js","webpack://editolido/webpack/bootstrap","webpack://editolido/webpack/runtime/compat get default export","webpack://editolido/webpack/runtime/define property getters","webpack://editolido/webpack/runtime/hasOwnProperty shorthand","webpack://editolido/webpack/runtime/make namespace object","webpack://editolido/./src/modules/geolite.js","webpack://editolido/./src/modules/geopoint.js","webpack://editolido/./src/modules/kml_constants.js","webpack://editolido/./src/modules/route.js","webpack://editolido/./src/modules/kml_templates.js","webpack://editolido/./src/modules/kml.js","webpack://editolido/./src/modules/ofp_extensions.js","webpack://editolido/./src/modules/iata2icao.js","webpack://editolido/./src/modules/ofp_infos.js","webpack://editolido/./src/modules/ofp.js","webpack://editolido/./src/modules/geoindex.js","webpack://editolido/./src/modules/ogimet.js","webpack://editolido/./src/index.js"],"names":["root","factory","exports","module","define","amd","globalThis","BASE32_CODES","BASE32_CODES_DICT","i","length","charAt","ENCODE_AUTO","MIN_LAT","MAX_LAT","MIN_LON","MAX_LON","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","LatLng","constructor","this","format","v","letters","abs","degrees","floor","rest","minutes","cents","letter","padding","toFixed","padStart","phi","lam","map","PI","PhiLam","R","deg","rad_to_nm","radians","rad_to_deg","nm_to_rad","nm","km_to_rad","km","fmod","b","Number","toPrecision","dm2decimal","s","indexOf","offset","parseInt","slice","parseFloat","array_normalizer","array","dm_normalizer","mixedValue","lng","Array","isArray","arincRegex","isARINC","label","match","arinc_normalizer","signed","GeoPoint","name","description","normalizer","latlng","Reflect","has","trim","philam_cache","dm_cache","asPhiLam","asDM","geopoint1","geopoint2","converter","distanceTo","course_to","point","segment","xtd_to","geopoints","options","howMany","x","y","z","p","philam","cosphi","cos","sin","atan2","sqrt","asLatLng","other","phi1","lam1","phi2","lam2","sd","acos","crs_ab","crs_ad","dist_ad","xtd","asin","atFraction","fraction","distance","circle","radius","steps","destination","tc","lat1","lon1","points","equals","toJSON","PIN_NONE","PIN_BLUE","PIN_YELLOW","PIN_BROWN","PIN_ORANGE","PIN_PINK","PIN_RED","PIN_GREEN","PIN_PURPLE","NAT_POSITION_ENTRY","NAT_POSITION_EXIT","PINS","GOOGLEICONS","c","AVENZAICONS","Route","iterator","route2","p1","p2","e","zip","segments","reduce","prev","current","accumulator","maxLength","preserve","remaining","first","maxRadians","segmentLength","Track","isMine","isComplete","infos","super","pointTemplate","style","dm","lineTemplate","coordinates","segmentTemplate","folderTemplate","content","open","template","styles","folders","avenzaTemplate","styleTemplate","id","color","width","avenzaStyleTemplate","googleEarthStyleTemplate","iconTemplate","href","avenzaIconTemplate","pinProp","KMLFolder","linestrings","placemarks","lineStyle","pinId","enabled","empty","newValue","oldStyle","newStyle","KMLGenerator","renderers","Map","icons","text","replace","computeOptions","folderName","folderPinInherit","pin","isNaN","addFolder","folder","set","addFolders","items","String","clone","deleteProperty","addLine","route","renderLine","addPoints","excluded","addPoint","addSegments","render","renderIconTemplate","renderStyleTemplate","renderTemplate","renderIcons","index","renderFolders","renderFolder","renderer","filter","concat","output","isSegment","tpl","changeFolderColor","changeFolderPin","changeFolderState","reset","setName","StringExtractException","extract","start","end","endIsOptional","inclusive","from","to","substring","WptRegExp","RegExp","matchAll","str","result","console","geoPoints","forEach","wptRegExp","raw","AIRPORTS","require","IATADB","TZDB","iata2icao","iata","icao2iata","icao","iata2tz","tz","tzOffset","isoString","timeZone","loc","event","Date","parse","toLocaleString","exec","day","month","year","hour","minute","baseIsoString","res","endsWith","iata2GeoPoint","data","months3","pdfParsers","freeze","ofpTypes","FISHPOINTS","Ofp","assert","startsWith","pdfParser","pdfjs","ofpType","S4","includes","NVP","pattern","flight","depICAO","destICAO","datetime","ofp","groups","ofpTextDate","hours","ofpOUT","UTC","inFlightReleased","rawFPL","flightNo","callsign","log","flightTime","alternates","ralts","levels","averageFL","rawFS","inFlightStart","InFlightStartETO","taxiTimeOUT","taxiTimeIN","destIATA","depIATA","pld","blockFuel","tripFuel","toUpperCase","groundDistance","scheduledIN","aircraftType","aircraftRegistration","exp","eep","minFuelMarginETOPS","aircraftICAO24","etopsTime","err","etopsSummary","min","m","ofpOFF","getTime","ofpON","ofpIN","ofpInfos","window","alert","exception","removePageFooterRegex","cache","fn","cacheStore","toISOString","wptCoordinates","wptCoordinatesAlternate","end_is_optional","reverse","wptNamesEET","matches","eet","previousEET","previousFL","level","t","fl","results","altname","isMyTrack","fplRoute","trackParser","trackDescription","fishPoints","tracks","unknowns","f","trackRoute","trackIsComplete","labelDict","g","geoPoint","fpl","lidoRoute","replaceSID","pointsName","rawPoints","lidoPoints","fplRouteLenght","departure","innerFplRoute","innerFplRouteLength","reversedPoints","reversedLidoRoute","lidoRouteLength","track","fplPoints","needle","trackPoints","splice","recursiveNatReplace","unshift","GEO_HASH_GRID_SIZE","GeoGridIndex","precision","gridSize","toString","centerPoint","suggestedPrecision","maxSize","entries","centerHash","meAndNeighbors","hash","getNearestPointsDirty","ogimetRoute","wmoGrid","segmentSize","algorithm","neighbourRadius","getNeighbour","neighbours","getNearestPoints","sort","findStrategic","k","o_xtd","ogimet","f_xtd","filterByXtd","j","ogimetResults","o_index","neighbour","reduceFn","bestXtd","best","maxi","bestDiff","diff","idx","ogimetData","taxitime","ts","now_ts","tref","trefOfp","dateTimeFormat","Intl","DateTimeFormat","formatToParts","hfin","ceil","labels","url","proxy","version","VERSION"],"mappings":"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","file":"lidojs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"editolido\"] = factory();\n\telse\n\t\troot[\"editolido\"] = factory();\n})(globalThis, function() {\nreturn ","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nlam is the longitude in radians (lambda is a reserved name in python)\nphi is the latitude in radians\n\nLatLng is the base object when using degrees\nPhiLam is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {PhiLam} PhiLam - convert to a PhiLam\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asPhiLam() {\n        const [phi, lam] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new PhiLam(phi, lam);\n    }\n}\n\n/**\n * PhiLam\n *\n * @property {number} phi - latitude in radians\n * @property {number} lam - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass PhiLam {\n    constructor(phi, lam) {\n        this.phi = phi;\n        this.lam = lam;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'PhiLam';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.phi, this.lam].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst philam2latlng = (philam) => philam.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\n\nexport {\n    LatLng, PhiLam, philam2latlng, latlng2dm\n};\n","/* eslint-disable max-lines */\nimport {LatLng, PhiLam} from \"./geolite\";\n\n\n// earth mean radius in meters\n// nm in meters\nconst R = 6371000.0;\nconst NM = 1852.0;\nconst deg = 180 / Math.PI;\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst rad_to_deg = (radians) => radians * deg;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\nconst fmod = (a, b) => Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new LatLng(...array);\n    }\n    return new LatLng([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new LatLng(dm2decimal(lat), dm2decimal(lng))\n}\nconst arincRegex = /^([NESW]\\d{4}|\\d[NESW]\\d{3}|\\d{4}[NS]\\d{3,5}[EW]|\\d{2}[NS]\\d{3}[EW])$/u;\nconst isARINC = (label) => label.match(arincRegex);\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new LatLng(lat, -lng);\n            case 'E': // NE + +\n                return new LatLng(lat, lng);\n            case 'S': // SE - +\n                return new LatLng(-lat, lng);\n            case 'W': // SW - -\n                return new LatLng(-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new LatLng(lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof LatLng) {\n            this.latlng = mixedValue;\n        } else if (mixedValue && typeof mixedValue === 'object'\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new LatLng(parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.philam_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion PhiLam\n     * @returns {PhiLam}\n     */\n    get philam() {\n        if (this.philam_cache === null) {\n            this.philam_cache = this.latlng.asPhiLam;\n        }\n        return this.philam_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Get the course in radians between to GeoPoints\n     * @param {GeoPoint} geopoint1 start GeoPoint\n     * @param {GeoPoint} geopoint2 end GeoPoint\n     * @returns {number} the course in radians\n     */\n    static course(geopoint1, geopoint2) {\n        return geopoint1.course_to(geopoint2);\n    }\n\n    /**\n     * Given the segment AB, computes cross track error at point D\n     * @param {GeoPoint} point GeoPoint D\n     * @param {[GeoPoint, GeoPoint]} segment segment AB\n     * @param {?function} converter the converter to use\n     * @returns {number} the xtd in radians unless a converter is given\n     */\n    static xtd(point, segment, converter=null) {\n        return point.xtd_to(segment, converter);\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options={}) {\n        let howMany = geopoints.length,\n            lam = 0,\n            phi = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            phi = p.philam.phi;\n            lam = p.philam.lam;\n            let cosphi = Math.cos(phi);\n            x += cosphi * Math.cos(lam);\n            y += cosphi * Math.sin(lam);\n            z += Math.sin(phi);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const sd = Math.acos(\n            Math.sin(phi1) * Math.sin(phi2)\n            + Math.cos(phi1) * Math.cos(phi2) * Math.cos(lam2 - lam1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * Get the course to another point\n     * @param {GeoPoint} other GeoPoint\n     * @returns {number} the course in radian\n     */\n    course_to(other) {\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        return fmod(\n            Math.atan2(\n                Math.sin(lam1 - lam2) * Math.cos(phi2),\n                Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam1 - lam2)\n            ),\n            2 * Math.PI\n        );\n    }\n\n    /**\n     * Given the segment AB; computes cross track error\n     * @param {[GeoPoint, GeoPoint]} segment the segment AB\n     * @param {?function} converter the converter to use otherwise result in radians\n     * @returns {number} the distance in radian unless a converter is set\n     */\n    xtd_to(segment, converter=null) {\n        const crs_ab = segment[0].course_to(segment[1]);\n        const crs_ad = segment[0].course_to(this);\n        const dist_ad = segment[0].distanceTo(this);\n        const xtd = Math.asin(Math.sin(dist_ad) * Math.sin(crs_ad - crs_ab));\n        if (converter !== null) {\n            return converter(xtd);\n        }\n        return xtd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const phi1 = this.philam.phi;\n        const lam1 = this.philam.lam;\n        const phi2 = other.philam.phi;\n        const lam2 = other.philam.lam;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(phi1) * Math.cos(lam1) + b * Math.cos(phi2) * Math.cos(lam2);\n        const y = a * Math.cos(phi1) * Math.sin(lam1) + b * Math.cos(phi2) * Math.sin(lam2);\n        const z = a * Math.sin(phi1) + b * Math.sin(phi2);\n        const phi = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const lam = Math.atan2(y, x);\n        return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n    }\n\n    /**\n     * Return points forming a circle around current points\n     * @param {int} radius distance in radians\n     * @param {int} steps number of points in the circle\n     * @param {function} converter converter to use for the radius\n     */\n    circle(radius, steps=64, converter=nm_to_rad) {\n        if (converter) radius = converter(radius);\n        const destination = (d, tc) => {\n            const lat1 = this.philam.phi;\n            const lon1 = this.philam.lam;\n            const phi = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) *Math.sin(d) * Math.cos(tc));\n            let lam = lon1;\n            if (Math.cos(phi) !== 0) {\n                lam = Math.asin(Math.sin(tc) * Math.sin(d) / Math.cos(phi))\n                if (lon1 - lam < - Math.PI) lam = lon1 + Math.PI; // fix PPT ETOPS circle\n                lam = fmod(lon1 - lam + Math.PI, 2 * Math.PI) - Math.PI;\n            }\n            return new GeoPoint(new PhiLam(phi, lam).asLatLng);\n        }\n        const points = [];\n        for (let i = 0; i <= steps; i += 1) {\n            points.push(destination(radius, i * 2 * Math.PI / steps));\n        }\n        //points.push(points[0]); // close circle\n        return points;\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\nexport {array_normalizer, dm_normalizer, arinc_normalizer, isARINC, GeoPoint,dm2decimal,km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, rad_to_deg, NM, R};\n","export const PIN_NONE = 0\nexport const PIN_BLUE = 1\nexport const PIN_YELLOW = 2\nexport const PIN_BROWN = 3 // not available in Avenza\nexport const PIN_ORANGE = 4\nexport const PIN_PINK = 5 // not available in Avenza\nexport const PIN_RED = 6\nexport const PIN_GREEN = 7\nexport const PIN_PURPLE = 8\n\nexport const NAT_POSITION_ENTRY = 0\nexport const NAT_POSITION_EXIT = 1\n\nexport const PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nexport const GOOGLEICONS = [\n    '', 'blu', 'ylw',\n    'red', 'orange', 'pink',\n    'red', 'grn', 'purple',\n].map(c => ((c) ? `https://maps.google.com/mapfiles/kml/paddle/${c}-blank.png` : ''));\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nexport const AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png`);\n","import {nm_to_rad, rad_to_nm} from \"./geopoint\";\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {GeoPoint[]}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=rad_to_nm) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} [options.converter] - must transform maxLength in radians\n     * @param {?boolean} [options.preserve] - if false, split at maxLength, do not keep intermediary points\n     * @param {string} [options.name] - generated route name\n     * @param {string} [options.description] - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options = {}){\n        let {converter=nm_to_rad, preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength;\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true, infos={}} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n        this.infos = infos;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n\n    /**\n     * Given a track letter, returns the track label used in FPL\n     * @param {string} letter the track letter designator\n     * @return {string} the track label\n     */\n    static label(letter) {\n        return `NAT${letter}`;\n    }\n}\n\nexport {Route, Track};\n","/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nexport const pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nexport const folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nexport const styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nexport const avenzaStyleTemplate = ({id, color, width=3}) => styleTemplate({id, color, width});\nexport const googleEarthStyleTemplate = ({id, color, width=2}) => ((id === 'rnat') ? styleTemplate({id, color, 'width': 1}) : styleTemplate({id, color, width}));\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nexport const iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => ((href) ? `\n    <Style id=\"${id}\">\n      <IconStyle>\n          <Icon>\n              <href><![CDATA[${href}]]></href>\n          </Icon>\n          <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n      </IconStyle>\n    </Style>\\n` : `<Style id=\"${id}\"></Style>\\n`);\n\nexport const avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n","/* eslint-disable max-lines */\nimport {GOOGLEICONS, PINS, PIN_NONE} from \"./kml_constants\";\nimport {\n    folderTemplate, iconTemplate, lineTemplate, pointTemplate, segmentTemplate, styleTemplate, template\n} from \"./kml_templates\";\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? PIN_NONE : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = PINS[this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = PINS[newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || template;\n        this.pointTemplate = renderers.pointTemplate || pointTemplate;\n        this.lineTemplate = renderers.lineTemplate || lineTemplate;\n        this.folderTemplate = renderers.folderTemplate || folderTemplate;\n        this.styleTemplate = renderers.styleTemplate || styleTemplate;\n        this.iconTemplate = renderers.iconTemplate || iconTemplate;\n        this.segmentTemplate = renderers.segmentTemplate || segmentTemplate;\n        this.icons = renderers.icons || GOOGLEICONS;\n        this.name = undefined;\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = PINS[options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} [items.pinId=0] - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = PIN_NONE;\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        const renderIconTemplate = options.iconTemplate || this.iconTemplate;\n        const renderStyleTemplate = options.styleTemplate || this.styleTemplate;\n        const renderTemplate = options.template || this.template;\n        const renderIcons = options.icons || this.icons;\n        PINS.forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': PINS[index].slice(1), 'href': renderIcons[index]};\n                styles += renderIconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += renderStyleTemplate(folder.lineStyle)\n            }\n        }\n        if (!options.name) options.name = this.name;\n        return renderTemplate({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === PIN_NONE || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n    /**\n     * set the default name inserted in template\n     * @param {string} name the name/description\n     */\n    setName(name) {\n        this.name = name;\n    }\n}\n\nexport {KMLGenerator};\n","import {GeoPoint, dm_normalizer} from \"./geopoint\";\n\n/**\n * Exception thrown when a search term is not found\n */\nclass StringExtractException extends Error {}\n\n/**\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nfunction extract(text, start, end, endIsOptional = true, inclusive = false) {\n  let from = 0;\n  let to = 0;\n  if (start) {\n    from = text.indexOf(start);\n    if (from === -1) {\n      throw new StringExtractException(`${start} not found`);\n    }\n    if (!inclusive) {\n      from += start.length;\n    }\n  }\n  if (!end) {\n    return text.substring(from);\n  }\n  to = text.indexOf(end, from);\n  if (to === -1) {\n    if (endIsOptional) {\n      return text.substring(from);\n    }\n    throw new StringExtractException(`${end} not found`);\n  } else if (inclusive) {\n    to += end.length;\n  }\n  return text.substring(from, to);\n}\n\n/**\n * Defines an extract method on the String prototype\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nReflect.defineProperty(String.prototype, 'extract', {\n  value(start, end, endIsOptional = true, inclusive = false) {\n    return extract(this, start, end, endIsOptional, inclusive);\n  }\n});\n\n\n/**\n * A matchAll RegExp to extract WPT COORDINATES from text\n * @return {GeoPoint[]}\n */\nclass WptRegExp extends RegExp {\n\n  /**\n   * matchAll methods to return an array of GeoPoint\n   * @param str\n   * @returns {GeoPoint[]}\n   */\n  [Symbol.matchAll](str) {\n    // eslint-disable-next-line prefer-reflect\n    let result = RegExp.prototype[Symbol.matchAll].call(this, str);\n    if (!result) {\n      console.error(\"WPT Coordinates regexp failed\");\n      return [];\n    }\n    let geoPoints = [];\n    Array.from(result).forEach((match) => {\n      let name = match[1].trim().replace(/^-+/u, \"\");\n      if (name === \"\") {\n        name = match[2] + match[3];\n      }\n      geoPoints.push(\n        new GeoPoint(\n          [match[2], match[3]],\n          {\"name\": name, \"normalizer\": dm_normalizer})\n      );\n    });\n    return geoPoints;\n  }\n}\nconst wptRegExp = new WptRegExp(String.raw`(\\S+|\\s+)\\s+([NS]\\d{4}\\.\\d)([EW]\\d{5}\\.\\d)`, 'gu');\n\nexport {wptRegExp, StringExtractException, extract};\n","import {GeoPoint} from './geopoint';\nconst AIRPORTS = require('./airports.json');\nconst IATADB = require('./iata2icao.json');\nconst TZDB = require('./timezones.json');\n\n/** return icao code for a iata code or '????' */\nexport function iata2icao(iata) {\n    const index = IATADB.indexOf(iata + ':');\n    return (index >= 0) ? IATADB.substring(index + 4, index + 8) : '????';\n}\n\n/** return iata code for a icao code or '???' */\nexport function icao2iata(icao) {\n    const index = IATADB.indexOf(':' + icao);\n    return (index >= 0) ? IATADB.substring(index - 3, index) : '???';\n}\n\n/** return iata timezone \"Europe/Paris\" or undefined*/\nexport function iata2tz(iata) {\n    const index = IATADB.indexOf(iata + ':');\n    if (index >= 0) {\n        const tz = IATADB.substring(index + 8, index + 10);\n        return (tz === '00') ? undefined : TZDB[tz];\n    }\n    return undefined;\n}\n\n/** return timezone offset \"-2\" \"+5.5\" for iata at a date like \"2021-08-12T14:25Z\" or undefined */\nexport function tzOffset(iata, isoString) {\n    const timeZone = iata2tz(iata);\n    if (!timeZone) return undefined;\n    let event = new Date(Date.parse(isoString));\n    // British English uses day/month/year order and 24-hour time without AM/PM\n    // eslint-disable-next-line init-declarations\n    let loc;\n    try {\n        loc = event.toLocaleString(\"en-GB\", {timeZone});\n    } catch (e) {\n        return undefined;\n    }\n    const re = /(\\d\\d)\\/(\\d\\d)\\/(\\d\\d\\d\\d), (\\d\\d):(\\d\\d):\\d\\d/u\n    const match = re.exec(loc);\n    if (match !== null) {\n        const [, day, month, year, hour, minute] = match;\n        const baseIsoString = `${year}-${month}-${day}T${hour}:${minute}`;\n        const baseEvent = new Date(Date.parse(baseIsoString + \"Z\"));\n        const offset = (baseEvent - event)/3600000;\n        if (offset === 0) {\n            return \"+0\";\n        }\n        let res = (offset >= 0) ? '+' : '';\n        res += offset.toFixed(1)\n        return (res.endsWith('.0')) ? res.slice(0, -2) : res;\n    }\n    return undefined\n}\n\n/** return a LatLng from a iata code */\nexport function iata2GeoPoint(iata) {\n    const name = iata2icao(iata);\n    if (name) {\n        const data = AIRPORTS[name];\n        if (data) {\n            return new GeoPoint(data, {name});\n        }\n    }\n    return undefined\n}\n","/* eslint-disable max-lines */\n/* eslint-disable complexity */\n/* eslint-disable max-lines-per-function */\n\nimport {GeoPoint} from './geopoint';\nimport {icao2iata} from './iata2icao';\nconst AIRPORTS = require('./airports');\n\nconst months3 = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n Dictionary of common OFP data:\n - flightNo (AF009)\n - callsign (AFR009)\n - depICAO (KJFK)\n - depIATA IATA departure (JFK)\n - destICAO (LFPG)\n - destIATA IATA destination (CDG)\n - taxiTimeIN (departure taxi time in minutes)\n - taxiTimeOUT (arrival taxi time in minutes)\n - flightTime (ofp flight time in minutes)\n - ofpOUT (a javascript Date object for scheduled departure block time)\n - ofpOFF (ofpOUT + taxiTimeOUT)\n - ofpON (ofpOUT + taxiTimeOUT + flightTime)\n - ofpIN (ofpOUT + taxiTimeOUT + flightTime + taxiTimeIN)\n - scheduledIN (a javascript Date object for scheduled arrival block time)\n - ofp (OFP number 9/0/1)\n - alternates an array of alternate names\n - ralts an array of route alternate names (ETOPS)\n - rawFPL the raw text of the FPL\n - EEP the airport related to the ETOPS entry GeoPoint\n - EXP the airport related to the ETOPS exit GeoPoint\n - raltPoints the ETOPS airports as GeoPoint\n - maxETOPS the ETOPS time in minutes\n - minFuelMarginETOPS minimum fuel margin in T (extracted from ETOPS SUMMARY)\n - averageFL average flight level or 300\n - levels = array of flight levels found in FPL or [300]\n - payload in T\n - tripFuel in T\n - blockFuel in T\n - inFlightReleased is true when the OFP is released while in flight\n - inFlightStart is the start point name for ofp released in flight\n * @param text The OFP in text format\n * @returns {{flightNo: string, callsign: string, depICAO: string, depIATA: string, destICAO: string, destIATA: string, taxiTimeOUT: number, taxiTimeIN: number, ofpOUT: Date, ofpOFF: Date, ofpON: Date, ofpIN: Date, scheduledIN: Date, ofp: string, ralts: [] alternates: [], rawFPL: string, EEP: GeoPoint, EXP: GeoPoint, raltPoints: [GeoPoint], maxETOPS: number, fl: number, levels: [number], tripFuel: number, blockFuel: number, payload: number, inFlightReleased: boolean, inFlightStart: string}}\n */\nfunction ofpInfos(text) {\n  let pattern = /(?<flight>AF\\s+\\S+\\s+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\d+\\S{0,8})/u;\n  let match = pattern.exec(text);\n  if (match === null) {\n    pattern = /(?<flight>AF.+)(?<depICAO>\\S{4})\\/(?<destICAO>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\S+)Main/u;\n    match = pattern.exec(text);\n  }\n  let {flight, depICAO, destICAO, datetime, ofp} = match.groups;\n  // datetime is like 27Sep2019/1450\n  const [ofpTextDate] = datetime.split('/', 1);\n  const day = parseInt(datetime.substring(0,2), 10);\n  const month = months3.indexOf(datetime.substring(2,5));\n  const year = parseInt(datetime.substring(5,9), 10);\n  const hours = parseInt(datetime.substring(10,12), 10);\n  const minutes = parseInt(datetime.substring(12,14), 10);\n  const ofpOUT = new Date(Date.UTC(year, month, day, hours, minutes));\n  const inFlightReleased = text.indexOf(\"Inflight Released\") >= 0;\n\n  const rawFPL = text\n    .extract(\"ATC FLIGHT PLAN\", \"TRACKSNAT\")\n    .extract(\"(\", \")\", false, true);\n  const flightNo = flight.replace(/\\s/gu, \"\");\n  let callsign = flightNo;\n  pattern = /\\(FPL-([^-]+)-/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      callsign = match[1];\n  }\n\n  pattern = new RegExp(String.raw`(?:-TRIP|SUMMARYTRIP)\\s+[0-9]+[\\s.]+(\\d{2})(\\d{2})\\s`, \"u\");\n  match = pattern.exec(text);\n  if (match === null){\n    pattern = new RegExp(String.raw`-${destICAO}(\\d{2})(\\d{2})\\s`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match === null) {\n      console.log(\"flight duration not found, arbitrary set to 1 hour\");\n    } else {\n      console.log(\"trip time not found, using fpl flight time\");\n    }\n  }\n  const flightTime = (match) ? parseInt(match[2], 10) + 60 * parseInt(match[1], 10) : 60;\n\n  // try with 2 alternates first\n  pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n  match = pattern.exec(rawFPL);\n  let alternates = [];\n  if (match !== null){\n    alternates.push(match[1]);\n    alternates.push(match[2]);\n  } else {\n    pattern = new RegExp(String.raw`-${destICAO}.+\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n    match = pattern.exec(rawFPL);\n    if (match !== null) {\n      alternates.push(match[1]);\n    }\n  }\n\n  pattern = /RALT\\/((?:\\S{4}[ \\n])+)/u;\n  match = pattern.exec(rawFPL);\n  let ralts = [];\n  if (match !== null) {\n    ralts = match[1].trim().split(/\\s/u);\n  }\n\n  let levels = [...rawFPL.matchAll(/F(\\d{3})\\s/ug)].map(v => (v[1]*1));\n  let averageFL = 300;\n  if (levels && levels.length) {\n      averageFL = Math.round(levels.reduce((a, b) => a + b, 0) / levels.length);\n  } else {\n    levels = [averageFL];\n  }\n  const rawFS = text.extract(\"FLIGHT SUMMARY\", \"Generated\");\n  // eslint-disable-next-line init-declarations\n  let inFlightStart;\n  // eslint-disable-next-line init-declarations\n  let InFlightStartETO;\n  if (inFlightReleased) {\n    pattern = new RegExp(String.raw`ATC:${callsign}\\s+(\\S+)\\s+\\d{4}\\s+\\.{4}\\s+(\\d{2})(\\d{2})`, \"u\");\n    match = pattern.exec(rawFS);\n    if (match) {\n      inFlightStart = match[1];\n      InFlightStartETO = new Date(Date.UTC(year, month, day, parseInt(match[2], 10), parseInt(match[3], 10)))\n    }\n  }\n  pattern = /\\s(\\d{2})(\\d{2})\\s+TAXI IN/u;\n  match = pattern.exec(rawFS);\n  let taxiTimeOUT = 15;\n  if (match === null) {\n    console.log(\"taxiTimeOUT not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeOUT = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  let taxiTimeIN= 15;\n  pattern = /\\/\\s+(\\d{2})(\\d{2})MIN/u;\n  match = pattern.exec(rawFS);\n  if (match === null) {\n    console.log(\"arrival taxitime not found, arbitrary set to 15mn\");\n  } else {\n    taxiTimeIN = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n  pattern = new RegExp(String.raw`\\s${destICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const destIATA = (match) ? match[1] : '';\n  pattern = new RegExp(String.raw`\\s${depICAO}/([A-Z]{3})\\s\\d{4}`, \"u\");\n  match = pattern.exec(rawFS);\n  const depIATA = (match) ? match[1] : icao2iata(depICAO);\n  pattern = /\\.PLD\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const pld = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\.BLOCK\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const blockFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\|TRIP\\s+(\\d+)\\s/u;\n  match = pattern.exec(rawFS);\n  const tripFuel = (match) ? parseInt(match[1], 10) : 0;\n  pattern = new RegExp(String.raw`GND DIST\\s+(\\d+)${ofpTextDate.toUpperCase().substring(0,5)}`, \"u\");\n  match = pattern.exec(rawFS);\n  const groundDistance = (match) ? parseInt(match[1], 10) : 0;\n  pattern = /\\s+STA\\s+([0-9]{4})/u;\n  match = pattern.exec(rawFS);\n  let scheduledIN = (match) ? new Date(Date.UTC(year, month, day, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10))): null;\n  if (scheduledIN && scheduledIN < ofpOUT) {\n    scheduledIN = new Date(Date.UTC(year, month, day + 1, parseInt(match[1].slice(0,2), 10), parseInt(match[1].slice(2), 10)));\n  }\n  //aircraft type\n  let aircraftType = \"???\";\n  const aircraftTypes = { // convert to Oliver Ravet codes\n    'A388': '380',\n    'B772': '772',\n    'B773': '773',\n    'B77W': '773',\n    'B77L': '77F',\n    'B788': '787',\n    'B789': '787',\n    'B78X': '787',\n    'A318': '318',\n    'A319': '319',\n    'A320': '320',\n    'A20N': '320', //A320 neo\n    'A321': '321',\n    'A332': '330',\n    'A333': '330',\n    'A338': '330',\n    'A339': '330',\n    'A342': '340',\n    'A343': '340',\n    'A344': '340',\n    'A345': '340',\n    'A346': '340',\n    'A359': '350',\n    'A35K': '350',\n    'BCS1': '220',\n    'BCS3': '220'\n  }\n  pattern = /-([AB][0-9]{2}.|BCS\\d)\\//u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftType = aircraftTypes[match[1]] || '???';\n  }\n  // aircraft registration\n  let aircraftRegistration = '';\n  pattern = /REG\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n      aircraftRegistration = match[1][0] + '-' + match[1].slice(1);\n  }\n  // icao24\n  let aircraftICAO24 = '';\n  pattern = /CODE\\/(\\S+)/u\n  match = pattern.exec(rawFPL);\n  if (match) {\n    aircraftICAO24 = match[1];\n  }\n  // eslint-disable-next-line init-declarations\n  let exp;\n  // eslint-disable-next-line init-declarations\n  let eep;\n  // eslint-disable-next-line init-declarations\n  let minFuelMarginETOPS;\n  let etopsTime = 0;\n  if (ralts.length > 0) {\n      pattern = /ETOPS\\s+(\\d{3})\\s/u\n      match = pattern.exec(rawFS);\n      if (match) {\n        etopsTime = parseInt(match[1], 10);\n      } else {\n        try {\n          match = pattern.exec(text.extract('FPL SUMMARY', 'Generated'));\n          if (match) {\n            etopsTime = parseInt(match[1], 10);\n          }\n        } catch (err) {\n          console.log(\"ETOPS range not found\");\n        }\n      }\n      const etopsSummary = text.extract(\"ETOPS SUMMARY\", \"--FLIGHT LOG\");\n      pattern = /EEP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        eep = match[1];\n      }\n      pattern = /EXP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        exp = match[1];\n      }\n      pattern = /ETO\\.{4}\\s+([\\d.]+)\\/EFOB\\s([\\d.]+)/gu;\n      minFuelMarginETOPS = Math.min(...Array.from(etopsSummary.matchAll(pattern), m => parseFloat(m[2]) - parseFloat(m[1])));\n  }\n\n  const ofpOFF = (!InFlightStartETO) ? new Date(ofpOUT.getTime() + taxiTimeOUT * 60000) : InFlightStartETO;\n  const ofpON = new Date(ofpOFF.getTime() + flightTime * 60000);\n  const ofpIN = new Date(ofpON.getTime() + taxiTimeIN * 60000);\n\n  const infos = {\n    //\"flight\": flightNo, /*deprecated */\n    flightNo,\n    callsign,\n\n    //\"departure\": depICAO, /*deprecated */\n    //\"dep3\": depIATA, /*deprecated */\n    \"depICAO\": depICAO,\n    \"depIATA\": depIATA,\n\n    //\"destination\": destICAO, /*deprecated */\n    //\"des3\": destIATA, /*deprecated */\n    \"destICAO\": destICAO,\n    \"destIATA\": destIATA,\n\n    //\"datetime\": ofpOUT, /*deprecated */\n    //\"STD\": ofpOUT, /*deprecated */\n    //\"takeoff\": ofpOFF, /*deprecated */\n    //\"landing\": ofpON, /*deprecated */\n    //\"station\": scheduledIN, /*deprecated */\n    //\"STA\": scheduledIN, /*deprecated */\n    //\"datetime2\": ofpIN, /*deprecated */\n    ofpOUT,\n    ofpOFF,\n    ofpON,\n    ofpIN,\n    scheduledIN,\n    \"flightTime\": (ofpON.getTime() - ofpOFF.getTime()) / 60000,\n    \"blockTime\": (ofpIN.getTime() - ofpOUT.getTime()) / 60000,\n    \"scheduledBlockTime\": (scheduledIN) ? (scheduledIN.getTime() - ofpOUT.getTime()) / 60000 : 0,\n    //\"date\": ofpTextDate, /* deprecated */\n    ofpTextDate,\n    \"ofp\": ofp.replace(\"\\xA9\", \"\"),\n    //\"duration\": duration,  /*deprecated */\n    \"alternates\": alternates,\n    \"ralts\": ralts,\n    \"raltPoints\": [],\n    //\"taxitime\": taxiTimeOUT, /*deprecated */\n    //\"taxitime2\": taxiTimeIN, /*deprecated */\n    taxiTimeOUT,\n    taxiTimeIN,\n    //\"rawfpl\": rawFPL,/*deprecated */\n    rawFPL,\n    //\"aircraft\": aircraftType,  /*deprecated */\n    aircraftType,\n    //\"registration\": aircraftRegistration,  /*deprecated */\n    aircraftRegistration,\n    //\"icao24\": aircraftICAO24,  /*deprecated */\n    aircraftICAO24,\n    \"EEP\": null,\n    \"EXP\": null,\n    //\"ETOPS\": etopsTime,  /*deprecated */\n    \"maxETOPS\": etopsTime,\n    minFuelMarginETOPS,\n    averageFL,\n    levels,\n    \"payload\": pld / 1000,\n    \"tripFuel\": tripFuel / 1000,\n    \"blockFuel\": blockFuel / 1000,\n    groundDistance,\n    inFlightReleased,\n    inFlightStart\n  }\n  try {\n    infos['raltPoints'] = [];\n    for (const v of ralts) {\n      if (v && AIRPORTS[v]) {\n        infos['raltPoints'].push(new GeoPoint(AIRPORTS[v], {'name': v, 'description': 'ETOPS'}));\n      } else {\n        console.error('missing airport', v);\n      }\n    }\n    if (eep && AIRPORTS[eep]) {\n      infos['EEP'] = new GeoPoint(AIRPORTS[eep], {'name': eep, 'description': 'EEP'});\n    } else if (eep){\n      console.error('missing airport', eep);\n    }\n    if (exp && AIRPORTS[exp]) {\n      infos['EXP'] = new GeoPoint(AIRPORTS[exp], {'name': exp, 'description': 'EXP'});\n    } else if (exp){\n      console.error('missing airport', exp);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n  return infos\n}\nexport {ofpInfos, months3};\n","/* eslint-disable no-underscore-dangle,max-lines-per-function, max-lines */\n\nimport {GeoPoint, arinc_normalizer} from \"./geopoint\";\nimport {Route, Track} from \"./route\";\nimport {wptRegExp} from \"./ofp_extensions\";\n// eslint-disable-next-line sort-imports\nimport {ofpInfos} from \"./ofp_infos\";\n\n\nconst pdfParsers = Object.freeze({\n  \"pypdf2\": 3,\n  \"pdfjs\": 4\n});\n\nconst ofpTypes = Object.freeze({\n  \"S4\": 1,\n  \"NVP\": 2\n});\n\nconst FISHPOINTS = require('./fishpoints');\n\nexport class Ofp {\n  constructor(text=\"\") {\n    console.assert(text.startsWith(\"_PDFJS_\"), \"invalid text file\");\n    this.pdfParser = pdfParsers.pdfjs;\n    this.ofpType = ofpTypes.S4;\n    if (text.includes(\"--FLIGHT SUMMARY--\")) {\n      this.ofpType = ofpTypes.NVP;\n    }\n    try {\n      this.infos = ofpInfos(text);\n    } catch (error) {\n      console.error(error);\n      try {\n        if (window) {\n          // eslint-disable-next-line no-alert\n          window.alert(`Erreur: {error}` )\n        }\n      } catch (exception) {\n        // not in browser, just log\n      }\n      throw error;\n    }\n    this.removePageFooterRegex = new RegExp(String.raw`([\\s-]\\d{1,2})?Page\\s[0-9]+\\s.+?Page\\s[0-9]+.+?\\/${this.infos['depICAO']}-${this.infos['destICAO']}`, 'gsu');\n    this.text = text.replace(this.removePageFooterRegex,'');\n    this.cache = function (name, fn) {\n      if (this.cacheStore === undefined) {\n        this.cacheStore = {}; /* on first run create cache storage */\n      }\n      if (this.cacheStore[name] === undefined) {\n        this.cacheStore[name] = fn();\n      }\n      return this.cacheStore[name];\n    };\n  }\n\n  get description() {\n    const infos = this.infos;\n    return `${infos.flightNo} ${infos.depICAO}-${infos.destICAO} ${infos.ofpTextDate} ${infos.ofpOUT.toISOString().substring(11,16)}z OFP ${infos.ofp}`;\n  }\n\n  /**\n   * Array of WPT COORDINATES found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinates(start=\"WPT COORDINATES\") {\n    const infos = this.infos;\n    const end = (this.ofpType === ofpTypes.NVP) ? '----' + infos['destICAO']: '----';\n    const extract = this.text.extract(start, end);\n    const geoPoints = extract.matchAll(wptRegExp);\n    if (geoPoints.length > 0) {\n      if (!infos.inFlightReleased) {\n        geoPoints[0].name = this.infos['depICAO']; // avoid name problems\n      } else if (infos.inFlightStart) {\n        geoPoints[0].name = infos.inFlightStart;\n      }\n    }\n    return geoPoints;\n  }\n\n  /**\n   * Array of WPT COORDINATES for alternate found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinatesAlternate(start='WPT COORDINATES', end_is_optional=false) {\n\n    const end = (this.ofpType === ofpTypes.NVP) ? '--WIND INFORMATION--': 'ATC FLIGHT PLAN';\n    // take only what is after the last '----' (python rsplit)\n    // eslint-disable-next-line require-jsdoc\n    function reverse(str) {\n      return [...str].reverse().join('');\n    }\n    const t = this.text.extract(start, end, end_is_optional)\n    const extract = reverse(t).split('----', 1)[0];\n    return reverse(extract).matchAll(wptRegExp);\n  }\n\n  wptNamesEET(geoPoints) {\n    const start = 'ATC DEPARTURE';\n    const pattern = /[\\s-]([A-Z0-9/]+)\\s+[0-9]{3}\\s+(?:[0-9.\\s]{4})\\s+\\.\\.\\.\\.\\/\\.\\.\\.\\.\\s(.{3})\\s[A-Z0-9/.+\\s-]+?[0-9]{4}\\/([0-9]{4})\\s+[0-9]{3}\\/[0-9]{3}/gu;\n    const extract = this.text.extract(start, 'DESTINATION ALTERNATE', true);\n    const matches = extract.matchAll(pattern);\n\n    const eet = {};\n    let previousEET = 0;\n    // eslint-disable-next-line init-declarations\n    let previousFL = this.infos.levels[0];\n    for (let [,name, level, t,] of matches) {\n      //console.log(name)\n      if (name.startsWith('/')) name = name.slice(1); // ofp AF082\n      const fl = parseInt(level, 10);\n      if (!isNaN(fl)) previousFL = fl;\n      eet[name.split('/')[0]] = [previousEET, previousFL];\n      previousEET = (parseFloat(t.slice(0,2)) * 60) + parseFloat(t.slice(2))\n    }\n    eet[this.infos['destICAO']] = [previousEET, previousFL];\n    //console.log(eet);\n    const results = [];\n    let error = false;\n    for (const p of geoPoints) {\n      if (eet[p.name] === undefined) {\n          let altname = p.name.replace(/00\\.0/gu,'')\n          if (eet[altname] === undefined) {\n              altname = p.name.replace(/\\.0/gu,'')\n              if (eet[altname] === undefined) {\n                console.log('missing point', p.name);\n                error = true;\n                break;\n              } else {\n                results.push([p, ...eet[altname]]);\n              }\n          } else {\n            results.push([p, ...eet[altname]])\n          }\n      } else {\n          results.push([p, ...eet[p.name]])\n      }\n    }\n    return (error) ? [] : results;\n  }\n\n  /**\n   * check if the designated track is in the FPL\n   * @param letter\n   * @returns {boolean}\n   */\n  isMyTrack(letter) {\n    return this.fplRoute.indexOf(Track.label(letter)) !== -1;\n  }\n\n  /**\n   * Parse the OFP and return tracks as an array of [trackLetter, trackDescription]\n   * @returns {[]}\n   */\n  trackParser() {\n    let extract = \"\";\n    const infos = {};\n    try {\n      extract = this.text\n        .extract(\"ATC FLIGHT PLAN\").extract(')');\n    } catch (e) {\n      return [];\n    }\n    let results = [];\n    if (extract.includes(\"REMARKS:\")) {\n      extract = extract.split(\"REMARKS:\", 1)[0];\n      extract = extract.split(\"Generated at\", 1)[0];\n    }\n    if (extract.includes(\" LVLS \")) {\n      // split at track letter, discard first part\n      const a = extract.split(/(?:\\s|[^A-Z\\d])([A-Z])\\s{3}/gu).slice(1);\n      // results are [trackLetter, trackDescription]\n      for (let i = 0, max = a.length; i < max; i += 2) {\n        let trackDescription = a[i + 1];\n        if (trackDescription.includes(\" NOTES:\")){\n          trackDescription = trackDescription.split(\" NOTES:\", 1)[0];\n        }\n        results.push([a[i], trackDescription]);\n      }\n    } else if (extract.includes('TRACKS')) {\n      console.error(\"Unknown TRACKSNAT message format\");\n      console.log(extract);\n    }\n    return {results, infos};\n  }\n\n  /**\n   * Tracks found in the OFP as an array of Track\n   * @returns {Track[]}\n   */\n  get tracks() {\n    return this.cache(\"tracks\", () => {\n      const {results, infos} = this.trackParser();\n      const pattern = /(\\d{2,4}[NS]\\d{3,5}[EW]|[NESW]\\d{4}|\\d[NESW]\\d{3}[^EW])/u;\n      let fishPoints = {};\n      let tracks = [];\n\n      //find unknows named waypoints in tracks\n      let unknowns = [];\n      // eslint-disable-next-line array-callback-return\n      results.map(([, description]) => {\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) === null) {\n                unknowns.push(label);\n              }\n            }\n          });\n      });\n      // console.debug(`Unknown track points: ${unknowns}`);\n      unknowns.forEach((name) => {\n        const f = FISHPOINTS[name];\n        if (f !== undefined) {\n          fishPoints[name] = new GeoPoint(f, {\"name\": name});\n        }\n      });\n\n      results.forEach(([letter, description]) => {\n        let trackRoute = [];\n        let trackIsComplete = true;\n        const isMine = this.isMyTrack(letter);\n        let labelDict = (isMine) ? {} : fishPoints;\n        if (isMine) {\n          this.route.points.forEach((g) => {\n            if (g.name !== \"\") {\n              labelDict[g.name] = g\n            }\n          })\n        }\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) !== null) {\n                trackRoute.push(new GeoPoint(label, {\n                  \"name\": label,\n                  \"normalizer\": arinc_normalizer\n                }));\n              } else {\n                let geoPoint = labelDict[label];\n                if (geoPoint !== undefined) {\n                  trackRoute.push(new GeoPoint(geoPoint, {\"name\": label}));\n                } else {\n                  trackIsComplete = false;\n                }\n              }\n            }\n          });\n        let direction = \"\";\n        if (description.match(/RTS WEST/u)) direction = \"WEST\";\n        if (description.match(/RTS EAST/u)) direction = \"EAST\";\n        tracks.push(new Track(trackRoute,\n          {\n            \"name\": `NAT ${letter}`,\n            \"description\": description,\n            \"isMine\": isMine,\n            \"isComplete\": trackIsComplete,\n            \"infos\": {...infos, direction}\n          }));\n      });\n      return tracks;\n    });\n  }\n\n  /**\n   * Returns FPL as an Array\n   * @returns {string[]}\n   */\n  fpl() {\n    const infos = this.infos;\n    let text = infos.rawFPL.extract(`-${infos.depICAO}`, `-${infos.destICAO}`, false);\n    text = text.substring(text.indexOf(\" \") + 1);\n    let results = [infos.depICAO];\n    text.split(\" \").map((v) => v.trim())\n      .forEach((v) => {\n        if (v !== \"\" && !v.startsWith(\"-N\")){\n          results.push(v);\n        }\n      });\n    results.push(infos.destICAO);\n    return results;\n  }\n\n  /**\n   * FPL route found in OFP (fpl without speed/FL annotations)\n   * @returns {string[]}\n   */\n  get fplRoute() {\n    return this.cache(\"fplRoute\",\n      () => this.fpl().map((p) => {\n        if (p.includes(\"/\")) {\n          return p.split(\"/\", 1)[0];\n        }\n        return p;\n      })\n    );\n  }\n\n  get route() {\n    return this.cache(\"route\", () => new Route(this.wptCoordinates()));\n  }\n\n  lidoRoute(replaceSID=true) {\n    return this.cache(\"lidoRoute\" + ((replaceSID) ? \"_r\" : \"\"), () => {\n      const points = [];\n      const pointsName = []; // used if replaceSID === false\n      const rawPoints = []; // used if replaceSID === true\n      this.route.points.forEach((p) => {\n        rawPoints.push(p.dm);\n        pointsName.push(p.name || p.dm);\n        if (p.name === \"\" || (/\\d+/u).exec(p.name) !== null) {\n          points.push(p.dm);\n        } else {\n          points.push(p.name);\n        }\n      });\n      let lidoPoints = [];\n\n      let fplRoute = this.fplRoute;\n      let fplRouteLenght = fplRoute.length;\n      if (fplRouteLenght < 2) {\n        return points;\n      }\n      let departure = fplRoute[0];\n      let destination = fplRoute[fplRouteLenght - 1];\n      let innerFplRoute = fplRoute.slice(1, -1);\n      let innerFplRouteLength = innerFplRoute.length;\n\n\n      // replace points by rawPoint before first common waypoint\n      for (let i = 0; i < innerFplRouteLength; i += 1 ) {\n        let p = innerFplRoute[i];\n        let offset = points.indexOf(p);\n        if (offset !== -1) {\n          if (replaceSID) {\n            lidoPoints = rawPoints.slice(1, offset).concat(innerFplRoute.slice(i));\n          } else {\n            lidoPoints = pointsName.slice(1, offset).concat(innerFplRoute.slice(i));\n          }\n          break;\n        }\n      }\n      // replace points after last common waypoint by rawPoints\n      let reversedPoints = points.slice().reverse(); // copy before reverse\n      let reversedLidoRoute = lidoPoints.slice().reverse();\n      let lidoRouteLength = lidoPoints.length;\n      for (let i = 0; i < lidoRouteLength; i += 1 ) {\n        let p = reversedLidoRoute[i];\n        let offset = reversedPoints.indexOf(p);\n        if (offset !== -1) {\n          if (i > 0) {\n            lidoPoints = lidoPoints.slice(0, -i);\n          }\n          if (replaceSID) {\n            lidoPoints = lidoPoints.concat(rawPoints.slice(-offset, -1));\n          } else {\n            lidoPoints = lidoPoints.concat(pointsName.slice(-offset, -1));\n          }\n          break;\n        }\n      }\n      // replace known tracks (NATA, NATB...) by track_points\n      /**\n       * When there is a FL or Speed change, we may have multiple\n       * \"NATW\" in the FPL, so change them all.\n       * @param fplPoints: [] - an array of fplPoints\n       * @param needle: string\n       * @param trackPoints\n       * @returns {[]}\n       */\n      const recursiveNatReplace = function (fplPoints, needle, trackPoints) {\n        let match = [];\n        // infinite loop (while(true) breaks in browser)\n        // https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript\n        for (;;) {\n          let offset = fplPoints.indexOf(needle);\n          if (offset === -1) {\n            return match;\n          }\n          fplPoints.splice(offset, 1, ...trackPoints.slice(\n            trackPoints.indexOf(fplPoints[offset - 1]) +1,\n            trackPoints.indexOf(fplPoints[offset + 1])));\n          match = fplPoints;\n        }\n      };\n\n      this.tracks.forEach( (track) => {\n        if (track.isMine) {\n          let letter = track.name.slice(-1);\n          let results = recursiveNatReplace(\n            lidoPoints,\n            Track.label(letter),\n            track.points.map((p) => p.name)\n          );\n          if (results.length > 0) {\n            lidoPoints = results;\n          }\n        }\n      });\n      lidoPoints.push(destination);\n      lidoPoints.unshift((!this.infos.inFlightStart) ? departure : this.infos.inFlightStart);\n      // adds alternates and ralts\n      lidoPoints = lidoPoints.concat(...this.infos.alternates);\n      lidoPoints= lidoPoints.concat(...this.infos.ralts);\n      return lidoPoints;\n    });\n  }\n}\n","import {GeoPoint, km_to_rad} from \"./geopoint\";\nimport geohash from \"ngeohash\";\n\n// dependence between hashtag's precision and distance accurate calculating\n// in fact it's sizes of grids in km\nexport const GEO_HASH_GRID_SIZE = {\n    \"1\": 5000.0,\n    \"2\": 1260.0,\n    \"3\": 156.0,\n    \"4\": 40.0,\n    \"5\": 4.8,\n    \"6\": 1.22,\n    \"7\": 0.152,\n    \"8\": 0.038\n}\n\nexport class GeoGridIndex {\n    constructor(precision=3) {\n        this.precision = precision;\n        this.gridSize = km_to_rad(GEO_HASH_GRID_SIZE[precision.toString()]);\n        this.data = {};\n    }\n\n    /**\n     * Get Nearest points based on the geohash of the point\n     * It returns all wmo points in the 9 adjacents tiles\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians (unless a converter is given)\n     * @param {?function} converter\n     * @generator {GeoPoint}\n     */\n    *getNearestPointsDirty(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        if (radius > this.gridSize / 2.0) {\n            // radius is too big for current grid, we cannot use 9 neighbors\n            // to cover all possible points\n            let suggestedPrecision = 0;\n            for (const [precision, maxSize] of Object.entries(GEO_HASH_GRID_SIZE)) {\n                if (radius > km_to_rad(maxSize) / 2.0) {\n                    suggestedPrecision = parseInt(precision, 10) - 1;\n                    break;\n                }\n            }\n            throw new Error(`Too large radius, please rebuild GeoHashGrid with precision=\"${suggestedPrecision}\"`);\n        }\n        const centerHash = geohash.encode(centerPoint.latitude, centerPoint.longitude, this.precision);\n        let meAndNeighbors = geohash.neighbors(centerHash);\n        meAndNeighbors.push(centerHash);\n        for (const hash of meAndNeighbors) {\n            if (hash in this.data) {\n                for (const [name, latitude, longitude] of this.data[hash]) {\n                    yield new GeoPoint([latitude, longitude], {\"name\": name});\n                }\n            }\n        }\n    }\n\n    /**\n     * find nearest wmo points. Returns an array of [[distance, GeoPoint]]\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians unless a converter is set\n     * @param {?function} converter fn return radians\n     * @returns {{[number, GeoPoint]}} distance from centerPoint and a GeoPoint of the wmo\n     */\n    *getNearestPoints(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        for (const geoPoint of this.getNearestPointsDirty(centerPoint, radius, null)) {\n            let distance = geoPoint.distanceTo(centerPoint, null);\n            if (distance <= radius) {\n                if (converter !== null) {\n                    distance /= converter(1.0);\n                }\n                yield [geoPoint, distance];\n            }\n        }\n    }\n}\n","/* eslint-disable max-lines-per-function */\nimport {km_to_rad, rad_to_km} from \"./geopoint\";\nimport {Route} from \"./route\";\n\n/**\n * Compute the Ogimet Route\n * @param {editolido.Route} route the route to find the ogimet route for\n * @param {number} segmentSize the result is split to this length\n * @param {string} name the name of the returned route\n * @param {string} description the description of the returned route\n */\nexport function ogimetRoute(wmoGrid, route, {name=\"\", description=\"\", segmentSize=300, algorithm='xtd'} = {}) {\n    const neighbourRadius = (rad_to_km(wmoGrid.gridSize) / 2.0) - 0.1\n\n    const getNeighbour = (point) => {\n        let neighbours = [...wmoGrid.getNearestPoints(point, neighbourRadius)];\n        if (neighbours.length > 0) {\n            neighbours = neighbours.sort((a, b) => a[1] - b[1]);\n            if (neighbours.map((a) => a[0].name).indexOf(point.name) >= 0) {\n                return [point, 0];\n            }\n            return [neighbours[0][0], neighbours[0][1]];\n        }\n        return [null, null];\n    };\n    const findStrategic = (start, end, results) => {\n        const length = results.length;\n        for (let k = end - 1; k > start; k -= 1) {\n            const o_xtd = results[k].ogimet.xtd_to(\n                [results[k].fpl, results[k + 1].fpl]\n            );\n            const f_xtd = results[k].fpl.xtd_to(\n                [results[start].ogimet, results[end].ogimet]\n            )\n            if (Math.abs(f_xtd) > Math.abs(o_xtd)) {\n                const d = (k < length - 1) ? results[k].fpl.distanceTo(results[k+1].fpl) : -1;\n                if (Math.abs(f_xtd) < d || d < 0) return k;\n            }\n        }\n        return null;\n    };\n\n    const filterByXtd = (results) => {\n        if (results.length === 0) return [];\n        const res = [results[0]];\n        let i = -1;\n        while (i < results.length - 1) {\n            i += 1;\n            let j = i + 2;\n            while (j <= results.length - 1) {\n                let k = findStrategic(i, j, results);\n                if (k === null) {\n                    j += 1;\n                } else {\n                    if (res.map((r) => r.ogimet.name).indexOf(results[k].ogimet.name) < 0) {\n                        res.push(results[k]);\n                    }\n                    i = k - 1;\n                    break;\n                }\n            }\n        }\n        res.push(results[results.length - 1]);\n        if (res.length < results.length) {\n            return filterByXtd(res);\n        }\n        return res;\n    };\n\n    // eslint-disable-next-line no-unused-vars\n    const lowestCrsIndex = (results) => {\n        let bestDiff = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const diff = Math.abs(\n                results[i - 1].ogimet.course_to(results[i].ogimet)\n                - results[i - 1].ogimet.course_to(results[i+1].ogimet)\n            );\n            if (best === null || diff < bestDiff) {\n                best = i;\n                bestDiff = diff;\n            }\n        }\n        return best;\n    };\n\n    const lowestXtdIndex = (results) => {\n        let bestXtd = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const xtd = Math.abs(\n                results[i].fpl.xtd_to([results[i - 1].ogimet, results[i + 1].ogimet])\n            );\n            if (best === null || xtd < bestXtd) {\n                best = i;\n                bestXtd = xtd;\n            }\n        }\n        return best;\n    }\n\n    let ogimetResults = [];\n    const o_index = {};\n    for (const p of route.split(60, {'converter': km_to_rad, 'preserve': true}).points) {\n        const [neighbour, x] = getNeighbour(p);\n        if (neighbour !== null) {\n            if (neighbour.name in o_index) {\n                if (o_index[neighbour.name][0] > x) {\n                    o_index[neighbour.name] = [x, p];\n                }\n            } else {\n                o_index[neighbour.name] = [x, p];\n            }\n            ogimetResults.push({'fpl': p, 'ogimet': neighbour});\n        }\n    }\n\n    // eslint-disable-next-line eqeqeq\n    ogimetResults = ogimetResults.filter((r) => o_index[r.ogimet.name][1] == r.fpl);\n    ogimetResults = filterByXtd(ogimetResults);\n    //console.log(ogimetResults.length);\n    const reduceFn = (algorithm === 'xtd' ? lowestXtdIndex: lowestCrsIndex);\n    while (ogimetResults.length > 21) {\n        const idx = reduceFn(ogimetResults);\n        ogimetResults = ogimetResults.slice(0, idx).concat(ogimetResults.slice(idx + 1));\n    }\n    return new Route(ogimetResults.map((r) => r.ogimet))\n                .split(segmentSize, {'preserve': true, 'name': name, 'description': description});\n}\n\n/**\n * Computes ogimet url\n * @param {editolido.OFP} ofp the OFP\n * @param {editolido.GeoGridIndex} wmoGrid  the loaded Grid\n */\nexport function ogimetData(ofp, wmoGrid, algorithm=\"xtd\") {\n    // timestamp for departure\n    const taxitime = ofp.infos['taxiTimeOUT'];\n    const ts = (ofp.infos['ofpOUT'].getTime() / 1000) + (taxitime * 60);\n    const now_ts = (new Date()).getTime() / 1000;\n    const tref = Math.round(Math.max(ts, now_ts)); //for old ofp timeref=now\n    const trefOfp = new Date(Math.round(ts) * 1000);\n    // const dateref = new Date(tref * 1000); //for caching we use the ofp time instead\n    // https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\n    const dateTimeFormat = new Intl.DateTimeFormat('en', {'year': '2-digit', 'month': 'short', 'day': '2-digit', 'hour': '2-digit', 'minute': '2-digit', 'hourCycle': 'h24', 'timeZone': 'UTC'});\n    const [{'value': month},,{'value': day},,{'value': year},,{'value': hour},,{'value': minute}] = dateTimeFormat.formatToParts(trefOfp);\n    const name = `Route Gramet ${ofp.infos['flightNo']} ${ofp.infos['depICAO']}-${ofp.infos['destICAO']} ${day}${month}${year} ${hour}:${minute}z OFP ${ofp.infos['ofp']}`;\n    let hini = 0;\n    let hfin = Math.ceil(ofp.infos.flightTime / 60);\n    const fl = ofp.infos.averageFL;\n    const route = ogimetRoute(wmoGrid, ofp.route,{name, algorithm});\n    const labels = route.points.filter(p => p.name !== \"\").map(p => p.name);\n    route.description = labels.join(' ');\n    const url = `http://www.ogimet.com/display_gramet.php?lang=en&hini=${hini}&tref=${tref}&hfin=${hfin}&fl=${fl}&hl=3000&aero=yes&wmo=${labels.join('_')}&submit=submit`;\n    const proxy = `${hini}-${Math.round(ts)}-${hfin}-${fl}-${labels.join('_')}`;\n    return {tref, name, route, 'wmo': labels, url, proxy};\n}\n","/* globals VERSION */\nexport const version = VERSION;\nexport {GeoPoint, nm_to_rad, rad_to_nm, rad_to_deg, dm_normalizer, arinc_normalizer, isARINC} from \"./modules/geopoint\"\nexport {AVENZAICONS, GOOGLEICONS, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, PIN_BLUE, PIN_BROWN, PIN_GREEN, PIN_NONE, PIN_ORANGE, PIN_PINK, PIN_PURPLE, PIN_RED, PIN_YELLOW} from \"./modules/kml_constants\";\nexport {Route, Track} from \"./modules/route\"\nexport {googleEarthStyleTemplate, avenzaIconTemplate, avenzaStyleTemplate, avenzaTemplate, iconTemplate, styleTemplate, template} from \"./modules/kml_templates\";\nexport {KMLGenerator} from \"./modules/kml\";\nexport {Ofp} from \"./modules/ofp\";\nexport {GEO_HASH_GRID_SIZE, GeoGridIndex} from \"./modules/geoindex\";\nexport {ogimetRoute, ogimetData} from \"./modules/ogimet\";\nexport {months3} from \"./modules/ofp_infos\";\nexport {StringExtractException, extract} from \"./modules/ofp_extensions\";\nexport {iata2GeoPoint, icao2iata, iata2icao, tzOffset, iata2tz} from \"./modules/iata2icao\";\n"],"sourceRoot":""}