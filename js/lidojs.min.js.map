{"version":3,"sources":["webpack://editolido/webpack/universalModuleDefinition","webpack://editolido/webpack/bootstrap","webpack://editolido/./node_modules/ngeohash/main.js","webpack://editolido/./src/modules/geolite.js","webpack://editolido/./src/modules/geopoint.js","webpack://editolido/./src/modules/kml_constants.js","webpack://editolido/./src/modules/route.js","webpack://editolido/./src/modules/kml_templates.js","webpack://editolido/./src/modules/kml.js","webpack://editolido/./src/modules/ofp_extensions.js","webpack://editolido/./src/modules/ofp_infos.js","webpack://editolido/./src/modules/ofp.js","webpack://editolido/./src/modules/geoindex.js","webpack://editolido/./src/modules/ogimet.js","webpack://editolido/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BASE32_CODES","BASE32_CODES_DICT","length","charAt","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","mid","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","toLowerCase","bit","decode_bbox_int","hashInt","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","geohash","hashstringLength","latErr","lonErr","encodeNeighbor","neighborLatDir","neighborLonDir","encodeNeighbor_int","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","latlon","LatLng","constructor","this","format","v","letters","abs","degrees","floor","rest","minutes","cents","letter","padding","toFixed","padStart","rlat","phi","map","PI","LatPhi","R","rad_to_nm","radians","nm_to_rad","nm","km_to_rad","km","fmod","a","b","Number","toPrecision","dm2decimal","indexOf","offset","parseInt","slice","parseFloat","array_normalizer","array","dm_normalizer","mixedValue","lng","Array","isArray","arinc_normalizer","label","signed","GeoPoint","description","normalizer","latlng","Reflect","has","trim","latphi_cache","dm_cache","asLatPhi","asDM","geopoint1","geopoint2","converter","distanceTo","course_to","point","segment","xtd_to","geopoints","options","howMany","x","y","z","latphi","cosrlat","cos","sin","atan2","sqrt","asLatLng","other","rlat1","phi1","rlat2","phi2","sd","acos","crs_ab","crs_ad","dist_ad","xtd","asin","atFraction","fraction","distance","circle","radius","steps","destination","tc","lat1","lon1","points","equals","toJSON","PIN_NONE","PIN_BLUE","PIN_YELLOW","PIN_BROWN","PIN_ORANGE","PIN_PINK","PIN_RED","PIN_GREEN","PIN_PURPLE","NAT_POSITION_ENTRY","NAT_POSITION_EXIT","PINS","GOOGLEICONS","AVENZAICONS","Route","iterator","route2","p1","p2","e","zip","segments","reduce","prev","current","accumulator","maxLength","preserve","remaining","first","maxRadians","segmentLength","Track","isMine","isComplete","super","pointTemplate","style","dm","lineTemplate","coordinates","segmentTemplate","folderTemplate","content","open","template","styles","folders","avenzaTemplate","styleTemplate","id","color","width","avenzaStyleTemplate","googleEarthStyleTemplate","iconTemplate","href","avenzaIconTemplate","pinProp","KMLFolder","linestrings","placemarks","lineStyle","pinId","enabled","empty","newValue","oldStyle","newStyle","KMLGenerator","renderers","Map","icons","text","replace","computeOptions","folderName","folderPinInherit","pin","isNaN","addFolder","folder","set","addFolders","items","String","clone","deleteProperty","addLine","route","renderLine","addPoints","excluded","addPoint","addSegments","render","renderIconTemplate","renderStyleTemplate","renderTemplate","renderIcons","forEach","index","renderFolders","renderFolder","renderer","filter","concat","output","isSegment","tpl","changeFolderColor","changeFolderPin","changeFolderState","reset","setName","StringExtractException","start","end","endIsOptional","inclusive","from","to","substring","WptRegExp","RegExp","matchAll","str","result","console","geoPoints","match","wptRegExp","raw","AIRPORTS","require","months3","pdfParsers","freeze","ofpTypes","FISHPOINTS","Ofp","assert","startsWith","pdfParser","pdfjs","ofpType","S4","includes","NVP","infos","pattern","exec","flight","departure","datetime","ofp","groups","date","day","month","year","hours","rawFplText","extract","duration","log","alternates","ralts","levels","fl","rawFS","taxitime","aircraft","aircraftTypes","registration","exp","eep","icao24","etopsTime","err","etopsSummary","Date","UTC","ofpInfos","alert","exception","removePageFooterRegex","cache","fn","cacheStore","toISOString","wptCoordinates","wptCoordinatesAlternate","end_is_optional","reverse","wptNamesEET","matches","eet","previousEET","previousFL","level","results","altname","isMyTrack","fplRoute","trackParser","parserResults","fishPoints","tracks","unknowns","f","trackRoute","trackIsComplete","labelDict","g","geoPoint","fpl","rawfpl","lidoRoute","replaceSID","pointsName","rawPoints","lidoPoints","fplRouteLenght","innerFplRoute","innerFplRouteLength","reversedPoints","reversedLidoRoute","lidoRouteLength","track","fplPoints","needle","trackPoints","splice","recursiveNatReplace","unshift","GEO_HASH_GRID_SIZE","GeoGridIndex","precision","gridSize","toString","data","centerPoint","suggestedPrecision","maxSize","entries","centerHash","meAndNeighbors","neighbors","hash","getNearestPointsDirty","ogimetRoute","wmoGrid","segmentSize","algorithm","neighbourRadius","getNeighbour","neighbours","getNearestPoints","sort","findStrategic","k","o_xtd","ogimet","f_xtd","filterByXtd","res","j","ogimetResults","o_index","neighbour","reduceFn","bestXtd","best","maxi","bestDiff","diff","idx","ogimetData","ts","getTime","now_ts","tref","trefOfp","dateTimeFormat","Intl","DateTimeFormat","hour","minute","formatToParts","hfin","labels","url","proxy","version","VERSION"],"mappings":"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","file":"lidojs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"editolido\"] = factory();\n\telse\n\t\troot[\"editolido\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n","/*\nlatitude is the latitude in degrees\nlongitude is the longitude in degrees\n\nrlat is the latitude in radians (lambda is a reserved name in python)\nphi is the longitude in radians\n\nLatLng is the base object when using degrees\nLatPhi is the base object when using lradians\n*/\n\n/**\n * LatLng\n *\n * @property {number} latitude - latitude in degrees\n * @property {number} longitude - longitude in degrees\n * @property {LatPhi} asLatPhi - convert to a LatPhi\n */\nclass LatLng {\n    constructor(latitude, longitude) {\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatLng';\n    }\n\n    /**\n     *Degrees Minutes representation of LatLng\n     * exemple: N09W020.3\n     * @returns {String}\n     */\n    get asDM() {\n        const format = function (v, letters = \"NS\") {\n            let value = Math.abs(v);\n            let degrees = Math.floor(value);\n            let rest = (value - degrees) * 60;\n            let minutes = Math.floor(rest);\n            let cents = Math.round((rest - minutes) * 10);\n            if (cents >= 10) {\n                cents = 0;\n                minutes += 1;\n            }\n            if (minutes >= 60) {\n                minutes = 0;\n                degrees += 1;\n            }\n            let letter = \"\",\n                padding = 2;\n            if (letters === 'NS') {\n                letter = (v >= 0) ? letters[0] : letters[1];\n            } else {\n                letter = (v > 0) ? letters[0] : letters[1];\n                padding = 3;\n            }\n            return [\n                letter,\n                degrees.toFixed(0).padStart(padding, \"0\"),\n                minutes.toFixed(0).padStart(2, \"0\"),\n                '.' + cents.toFixed(0)\n            ].join('');\n        }\n        return format(this.latitude) + format(this.longitude, 'EW');\n    }\n\n    get asLatPhi() {\n        const [rlat, phi] = [this.latitude, this.longitude].map((d) => d * Math.PI / 180);\n        return new LatPhi(rlat, phi);\n    }\n}\n\n/**\n * LatPhi\n *\n * @property {number} rlat - latitude in radians\n * @property {number} phi - longitude in radians\n * @property {LatLng} asLatLng - convert to a LatLng\n */\nclass LatPhi {\n    constructor(rlat, phi) {\n        this.rlat = rlat;\n        this.phi = phi;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'LatPhi';\n    }\n\n    /**\n     * asLatLng return a new corresponding LatLng object\n     * @returns {LatLng}\n     */\n    get asLatLng() {\n        const [latitude, longitude] = [this.rlat, this.phi].map((r) => r * 180 / Math.PI);\n        return new LatLng(latitude, longitude);\n    }\n}\n\n//helper for python like code\nconst latphi2latlng = (latphi) => latphi.asLatLng;\nconst latlng2dm = (latlng) => latlng.asDM;\n\nexport {\n    LatLng, LatPhi, latphi2latlng, latlng2dm\n};\n","import {LatLng, LatPhi} from \"./geolite\";\n\n\n// earth mean radius in meters\n// nm in meters\nconst R = 6371000.0;\nconst NM = 1852.0;\n\n// Converters\nconst rad_to_nm = (radians) => radians * R / NM;\nconst rad_to_km = (radians) => radians * R / 1000.0;\nconst nm_to_rad = (nm) => nm * NM / R;\nconst km_to_rad = (km) => km * 1000.0 / R;\nconst km_to_nm = (km) => km * 1000.0 / NM;\n\nconst fmod = (a, b) => Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n/**\n * convert geo coordinates in degrees, minutes in signed fixed value\n *  N5500.0 => 55.00000000\n *  W02000.0 => -20.00000000\n * @param s String\n * @returns {number}\n */\nfunction dm2decimal(s) {\n    // convert geo coordinates in degrees, minutes in signed decimal value\n    // N5500.0 => Decimal('55.0')\n    // W02000.0 => Decimal('-20.0')\n    // :param s: str\n    const letter = s[0];\n    if ('NSEW'.indexOf(letter) < 0) throw new Error(\"invalid letter coordinates: \" + s);\n    const sign = (letter === 'N' || letter === 'E') ? 1 : -1;\n    const offset = (letter === 'N' || letter === 'S') ? 3 : 4;\n    const degrees = parseInt(s.slice(1, offset), 10);\n    const minutes = parseFloat(s.slice(offset));\n    return (sign * (degrees + minutes / 60))\n}\n\n// Normalizers\n/**\n *  Useful for testing (it is the default normalizer).\n *  It transforms an array into a LatLng\n * @param {number[]} array - [latitude, longitude]\n * @returns {LatLng}\n */\nfunction array_normalizer(array) {\n    if (array && array.length) {\n        return new LatLng(...array);\n    }\n    return new LatLng([0, 0])\n}\n\n/**\n * Normalize degrees minute value into LatLng\n * @param {string|string[]} mixedValue - 'N4038.4W07346.7' or ['N4038.4', 'W07346.7']\n * @returns {LatLng}\n */\nfunction dm_normalizer(mixedValue) {\n    let lat = 0,\n        lng = 0;\n    if (Array.isArray(mixedValue)) {\n        [lat, lng] = mixedValue;\n    } else {\n        lat = mixedValue.slice(0, 7);\n        lng = mixedValue.slice(7);\n    }\n    return new LatLng(dm2decimal(lat), dm2decimal(lng))\n}\n\n/**\n * Normalize ARINC point into LatLng\n * @param {string} label the arinc label\n * @returns {LatLng}\n */\nfunction arinc_normalizer(label) {\n    const signed = function (letter, lat, lng) {\n        switch (letter) {\n            case 'N': // NW + -\n                return new LatLng(lat, -lng);\n            case 'E': // NE + +\n                return new LatLng(lat, lng);\n            case 'S': // SE - +\n                return new LatLng(-lat, lng);\n            case 'W': // SW - -\n                return new LatLng(-lat, -lng);\n            default:\n                throw new Error('invalid letter');\n        }\n    };\n    let lat = 0,\n        lng = 0;\n    if ('NESW'.indexOf(label[0]) >= 0) {\n        // N5520  lon<100\n        lat = parseInt(label.slice(1,3), 10) + 0.5;\n        lng = parseInt(label.slice(3, 5), 10);\n        return signed(label[0], lat, lng);\n    } else if ('NESW'.indexOf(label[1]) >=0) {\n        // 5N520  lon>=100\n        lat = parseInt(label[0] + label[2], 10) + 0.5;\n        lng = parseInt(\"1\" + label.slice(3,5), 10);\n        return signed(label[1], lat, lng);\n    } else if ('NS'.indexOf(label[4]) >= 0) {\n        // 5530N020W => N5530.0W02000.0 => (55.5, -20)\n        // 5530N02000W => N5530.0W02000.0 => (55.5, -20)\n        lat = dm2decimal(label[4] + label.slice(0, 4) + \".0\");\n        lng = dm2decimal((label.slice(-1) + label.slice(5, -1) + \"00\").slice(0, 5) + \".0\");\n    } else {\n        // 55N020W => N5500.0W02000.0 => (55.0, -20)\n        lat = dm2decimal(label[2] + label.slice(0, 2) + \"00.0\");\n        lng = dm2decimal(label.slice(-1) + label.slice(3, -1) + \"00.0\");\n    }\n    return new LatLng(lat, lng);\n}\n\n\n/** GeoPoint class is the base element to construct a Route */\nclass GeoPoint {\n\n    /**\n     * Create a GeoPoint.\n     * @param {GeoPoint|LatLng|*} mixedValue - any value type supported by the normalizer\n     * @param {string} [name=\"\"]\n     * @param {string} [description=\"\"]\n     * @param {?function} [normalizer=array_normalizer]\n     */\n    constructor(mixedValue, {name=\"\", description=\"\", normalizer=array_normalizer} = {}){\n        if (mixedValue instanceof GeoPoint) {\n            this.latlng = mixedValue.latlng;\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else if (mixedValue instanceof LatLng) {\n            this.latlng = mixedValue;\n        } else if (mixedValue && typeof mixedValue === 'object'\n            && Reflect.has(mixedValue, \"longitude\")\n            && Reflect.has(mixedValue, \"latitude\")) {\n            this.latlng = new LatLng(parseFloat(mixedValue.latitude), parseFloat(mixedValue.longitude));\n            name = name || mixedValue.name || \"\";\n            description = description || mixedValue.description || \"\";\n        } else {\n            this.latlng = normalizer ? normalizer(mixedValue) : mixedValue;\n        }\n        this.name = name.trim();\n        this.description = description;\n        this.latphi_cache = null;\n        this.dm_cache = null;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'GeoPoint';\n    }\n\n    get latitude() {\n        return this.latlng.latitude;\n    }\n    get longitude() {\n        return this.latlng.longitude;\n    }\n\n    /**\n     * Lazy conversion LatPhi\n     * @returns {LatPhi}\n     */\n    get latphi() {\n        if (this.latphi_cache === null) {\n            this.latphi_cache = this.latlng.asLatPhi;\n        }\n        return this.latphi_cache;\n    }\n\n    /**\n     * Lazy Degrees Minutes String representation\n     * @returns {null}\n     */\n    get dm() {\n        if (this.dm_cache === null) {\n            this.dm_cache = this.latlng.asDM;\n        }\n        return this.dm_cache;\n    }\n\n    /**\n     * Get the spherical distance beetween two GeoPoints\n     * @param {GeoPoint} geopoint1\n     * @param {GeoPoint} geopoint2\n     * @param {?function} converter - by default results in radians\n     * @returns {*}\n     */\n    static distance(geopoint1, geopoint2, converter=null) {\n        return geopoint1.distanceTo(geopoint2, converter)\n    }\n\n    /**\n     * Get the course in radians between to GeoPoints\n     * @param {GeoPoint} geopoint1 start GeoPoint\n     * @param {GeoPoint} geopoint2 end GeoPoint\n     * @returns {number} the course in radians\n     */\n    static course(geopoint1, geopoint2) {\n        return geopoint1.course_to(geopoint2);\n    }\n\n    /**\n     * Given the segment AB, computes cross track error at point D\n     * @param {GeoPoint} point GeoPoint D\n     * @param {[GeoPoint, GeoPoint]} segment segment AB\n     * @param {?function} converter the converter to use\n     * @returns {number} the xtd in radians unless a converter is given\n     */\n    static xtd(point, segment, converter=null) {\n        return point.xtd_to(segment, converter);\n    }\n\n    /**\n     * Returns a pseudo center points from a list of GeoPoints\n     * @param {GeoPoint[]} geopoints\n     * @param {?Object} options\n     * @param {string} options.name\n     * @param {string} options.description\n     * @param {?function} options.normalizer\n     * @returns {GeoPoint}\n     */\n    static getCenter(geopoints, options={}) {\n        let howMany = geopoints.length,\n            phi = 0,\n            rlat = 0,\n            x = 0,\n            y = 0,\n            z = 0;\n\n        for (let p of geopoints) {\n            rlat = p.latphi.rlat;\n            phi = p.latphi.phi;\n            let cosrlat = Math.cos(rlat);\n            x += cosrlat * Math.cos(phi);\n            y += cosrlat * Math.sin(phi);\n            z += Math.sin(rlat);\n        }\n        x /= howMany;\n        y /= howMany;\n        z /= howMany;\n        rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        phi = Math.atan2(y, x);\n        return new GeoPoint(new LatPhi(rlat, phi).asLatLng, options || {});\n    }\n\n    /**\n     * Get the spherical distance from another GeoPoint\n     * @param {GeoPoint} other Geopoint\n     * @param {?function} [converter=null] - by default distance in radians\n     * @returns {number} the distance in the unit set by the converter\n     */\n    distanceTo(other, converter=null) {\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const sd = Math.acos(\n            Math.sin(rlat1) * Math.sin(rlat2)\n            + Math.cos(rlat1) * Math.cos(rlat2) * Math.cos(phi2 - phi1)\n        );\n        if (converter !== null) {\n            return converter(sd);\n        }\n        return sd;\n    }\n\n    /**\n     * Get the course to another point\n     * @param {GeoPoint} other GeoPoint\n     * @returns {number} the course in radian\n     */\n    course_to(other) {\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        return fmod(\n            Math.atan2(\n                Math.sin(phi1 - phi2) * Math.cos(rlat2),\n                Math.cos(rlat1) * Math.sin(rlat2) - Math.sin(rlat1) * Math.cos(rlat2) * Math.cos(phi1 - phi2)\n            ),\n            2 * Math.PI\n        );\n    }\n\n    /**\n     * Given the segment AB; computes cross track error\n     * @param {[GeoPoint, GeoPoint]} segment the segment AB \n     * @param {?function} converter the converter to use otherwise result in radians\n     * @returns {number} the distance in radian unless a converter is set\n     */\n    xtd_to(segment, converter=null) {\n        const crs_ab = segment[0].course_to(segment[1]);\n        const crs_ad = segment[0].course_to(this);\n        const dist_ad = segment[0].distanceTo(this);\n        const xtd = Math.asin(Math.sin(dist_ad) * Math.sin(crs_ad - crs_ab));\n        if (converter !== null) {\n            return converter(xtd);\n        }\n        return xtd;\n    }\n\n    /**\n     * computes intermediate point at fraction of other on great circle\n     * if distance=null, the required distance will be computed\n     * @param {GeoPoint} other GeoPoint\n     * @param {number} [fraction=0.5] - between 0 and 1\n     * @param {?number} [distance=null] - optional pre-computed distance in radians\n     * @returns {GeoPoint}\n     */\n    atFraction(other, fraction=0.5, distance=null) {\n        const d = (distance === null) ? this.distanceTo(other) : distance;\n        const rlat1 = this.latphi.rlat;\n        const phi1 = this.latphi.phi;\n        const rlat2 = other.latphi.rlat;\n        const phi2 = other.latphi.phi;\n        const a = Math.sin((1 - fraction) * d) / Math.sin(d);\n        const b = Math.sin(fraction * d) / Math.sin(d);\n        const x = a * Math.cos(rlat1) * Math.cos(phi1) + b * Math.cos(rlat2) * Math.cos(phi2);\n        const y = a * Math.cos(rlat1) * Math.sin(phi1) + b * Math.cos(rlat2) * Math.sin(phi2);\n        const z = a * Math.sin(rlat1) + b * Math.sin(rlat2);\n        const rlat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n        const phi = Math.atan2(y, x);\n        return new GeoPoint(new LatPhi(rlat, phi).asLatLng);\n    }\n\n    /**\n     * Return points forming a circle around current points\n     * @param {int} radius distance in radians\n     * @param {int} steps number of points in the circle\n     * @param {function} converter converter to use for the radius\n     */\n    circle(radius, steps=64, converter=nm_to_rad) {\n        if (converter) radius = converter(radius);\n        const destination = (d, tc) => {\n            const lat1 = this.latphi.rlat;\n            const lon1 = this.latphi.phi;\n            const rlat = Math.asin(Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) *Math.sin(d) * Math.cos(tc));\n            let phi = lon1;\n            if (Math.cos(rlat) !== 0) {\n                phi = Math.asin(Math.sin(tc) * Math.sin(d) / Math.cos(rlat))\n                if (lon1 - phi < - Math.PI) phi = lon1 + Math.PI; // fix PPT ETOPS circle\n                phi = fmod(lon1 - phi + Math.PI, 2 * Math.PI) - Math.PI;\n            }\n            return new GeoPoint(new LatPhi(rlat, phi).asLatLng);\n        }\n        const points = [];\n        for (let i = 0; i <= steps; i += 1) {\n            points.push(destination(radius, i * 2 * Math.PI / steps));\n        }\n        //points.push(points[0]); // close circle\n        return points;\n    }\n\n    equals(other){\n        return (this.latitude.toFixed(6) === other.latitude.toFixed(6)\n            && this.longitude.toFixed(6) === other.longitude.toFixed(6))\n    }\n\n    toJSON(){\n        // TODO still useful or should return a geojson feature enclosing the point ?\n        return {\n            '__geopoint__': true,\n            'latitude': this.latitude.toFixed(6),\n            'longitude': this.longitude.toFixed(6),\n            'name': this.name,\n            'description': this.description\n        };\n    }\n}\n\nexport {array_normalizer, dm_normalizer, arinc_normalizer, GeoPoint,dm2decimal,km_to_nm, km_to_rad, nm_to_rad, rad_to_km, rad_to_nm, NM, R};\n","export const PIN_NONE = 0\nexport const PIN_BLUE = 1\nexport const PIN_YELLOW = 2\nexport const PIN_BROWN = 3 // not available in Avenza\nexport const PIN_ORANGE = 4\nexport const PIN_PINK = 5 // not available in Avenza\nexport const PIN_RED = 6\nexport const PIN_GREEN = 7\nexport const PIN_PURPLE = 8\n\nexport const NAT_POSITION_ENTRY = 0\nexport const NAT_POSITION_EXIT = 1\n\nexport const PINS = [\n    '#placemark-none', '#placemark-blue', '#placemark-yellow',\n    '#placemark-brown', '#placemark-orange', '#placemark-pink',\n    '#placemark-red', '#placemark-green', '#placemark-purple'];\n\nexport const GOOGLEICONS = [\n    '', 'blu', 'ylw',\n    'red', 'orange', 'pink',\n    'red', 'grn', 'purple',\n].map(c => ((c) ? `https://maps.google.com/mapfiles/kml/paddle/${c}-blank.png` : ''));\n\n/**\n * Avenza is missing color 3 and 5: brown and pink displayed as red\n * @type {string[]}\n */\nexport const AVENZAICONS = [\n    'null', 'blue', 'yellow',\n    'red', 'orange', 'red',\n    'red', 'green', 'purple',\n].map(c => `http://download.avenza.com/images/pdfmaps_icons/pin-${c}-inground.png`);\n","import {nm_to_rad, rad_to_nm} from \"./geopoint\";\n\n\n/** Class representing a route. */\nclass Route {\n\n    /**\n     * Create a route.\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     */\n    constructor(points, {name=\"\", description=\"\"} = {}) {\n        this.points = points || [];\n        this.name = name;\n        this.description = description;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Route';\n    }\n\n    /**\n     * Route iterator - iterates over the route's points\n     * @returns {GeoPoint|*}\n     */\n    get [Symbol.iterator] () {\n        return this.points[Symbol.iterator];\n    }\n    // implementing like this causes a ReferenceError: regeneratorRuntime is not defined\n    // *[Symbol.iterator]() {\n    //     yield* this.points;\n    // }\n\n    /**\n     * check if two routes contains the same points\n     * @param route2\n     * @returns {boolean}\n     */\n    equals(route2) {\n        if (this.points.length !== route2.points.length) return false;\n        const zip = (a, b) => a.map((e, i) => [e, b[i]]);\n        for (let [p1, p2] of zip(this.points, route2.points)) {\n            if (! p1.equals(p2)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * if route points are [a, b, c], this returns [[a, b], [b, c]]\n     * @returns {GeoPoint[]}\n     */\n    get segments() {\n        let segments = [];\n        if (this.points.length > 0){\n            this.points.reduce((prev, current) => {\n                segments.push([prev, current]);\n                return current;\n            });\n        }\n        return segments;\n    }\n\n    /**\n     * Returns the distance of the route, unit is set by the converter.\n     * @param {?function} converter - if null returns the distance in radians\n     * @returns {number}\n     */\n    distance(converter=rad_to_nm) {\n        const distance = this.segments\n            .map(([p1, p2]) => p1.distanceTo(p2))\n            .reduce((accumulator, current) => accumulator + current, 0);\n        if (converter === null) {\n            return distance;\n        }\n        return converter(distance);\n    }\n\n    /**\n     * Split a route in smaller segments.\n     * The new Route might be different from the original one as original\n     * start and end of inner segments are not preserved by default.\n     *\n     * @param {number} maxLength - length of the segment, by default in NM\n     * @param {?Object} options - additional options are the Route options\n     * @param {?function} [options.converter] - must transform maxLength in radians\n     * @param {?boolean} [options.preserve] - if false, split at maxLength, do not keep intermediary points\n     * @param {string} [options.name] - generated route name\n     * @param {string} [options.description] - generated route description\n     * @returns {Route}\n     */\n    split(maxLength, options = {}){\n        let {converter=nm_to_rad, preserve=false} = options || {};\n        let points = [];\n        let remaining = 0;\n        let first = true;\n        let maxRadians = (converter) ? converter(maxLength) : maxLength;\n        let geopoint1 = null,\n            geopoint2 = null;\n        for ([geopoint1, geopoint2] of this.segments) {\n            if (first) {\n                first = false;\n                points.push(geopoint1); // first point\n            }\n            let segmentLength = geopoint1.distanceTo(geopoint2);\n            let d = remaining\n            while (d <= segmentLength - maxRadians) {\n                d += maxRadians;\n                points.push(geopoint1.atFraction(geopoint2, d / segmentLength, segmentLength));\n            }\n            remaining = parseFloat((d - segmentLength).toFixed(10)); // <=> python round(value, 10)\n            if (preserve && remaining) {\n                points.push(geopoint2);\n                remaining = 0;\n            }\n        }\n        if (remaining) {\n            points.push(geopoint2); // last if not emitted\n        }\n        return new Route(points, options);\n    }\n}\n\n/**\n * a Track is a Route with additional properties and methods\n */\nclass Track extends Route {\n\n    /**\n     * Track constructor\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}]\n     * @param {string} [options.name=\"\"]\n     * @param {string} [options.description=\"\"]\n     * @param {boolean} [options.isMine=false] - true when my route uses this track\n     * @param {boolean} [options.isComplete=true] - true when there is no missing points in the track\n     */\n    constructor(points, options) {\n        let {isMine=false, isComplete=true} = options || {};\n        super(points, options);\n        this.isMine = isMine;\n        this.isComplete = isComplete;\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    get [Symbol.toStringTag]() {\n        return 'Track';\n    }\n\n    /**\n     * Given a track letter, returns the track label used in FPL\n     * @param {string} letter the track letter designator\n     * @return {string} the track label\n     */\n    static label(letter) {\n        return `NAT${letter}`;\n    }\n}\n\nexport {Route, Track};\n","/**\n * Templates are use dynamically, that's why we use functions.\n */\n\n\n/**\n * Placemark renderer\n * @param {LatLng|GeoPoint} point\n * @param {string} name\n * @param {string} style - exemple '#placemark-red'\n * @param {string} description\n * @returns {string}\n */\nexport const pointTemplate = ({point, style}) => `\n     <Placemark>\n      <name><![CDATA[${point.name || point.dm}]]></name>\n      <styleUrl>${style}</styleUrl>\n      <description><![CDATA[${point.description || ''}]]></description>\n      <Point>\n        <coordinates>${point.longitude.toFixed(6)},${point.latitude.toFixed(6)}</coordinates>\n      </Point>\n    </Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72 2.21,47.90\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const lineTemplate = ({coordinates, name, style, description}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <description><![CDATA[${description}]]></description>\n  <LineString>\n    <tessellate>1</tessellate>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Line segment renderer\n * @param {string} coordinates - space separated list of lng,lat exemple \"2.54,49.01 2.23,48.72\"\n * @param {string} name\n * @param {string} style - exemple \"#my-folder-name\"\n * @returns {string}\n */\nexport const segmentTemplate = ({coordinates, name, style}) => `\n<Placemark>\n  <name><![CDATA[${name}]]></name>\n  <styleUrl>${style}</styleUrl>\n  <LineString>\n    <coordinates>${coordinates}</coordinates>\n  </LineString>\n</Placemark>\n`;\n\n\n/**\n * Folder renderer\n * @param {string} name\n * @param {string} content\n * @param {string|number} [open=1] - not recognized by mapsme/avenza\n * @returns {string}\n */\nexport const folderTemplate = ({name, content, open=1}) => `\n<Folder>\n    <name>${name}</name>\n    <open>${open}</open>\n    ${content}\n</Folder>\n`;\n\n\n/**\n * Global KML renderer\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const template = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        ${folders}\n  </Document>\n</kml>\n`;\n\n\n/**\n * Global KML renderer for Avenza (uses an additional root folder)\n * @param {string} name\n * @param {string} styles\n * @param {string} folders\n * @returns {string}\n */\nexport const avenzaTemplate = ({name, styles, folders}) => `<?xml version='1.0' encoding='UTF-8'?>\n<kml xmlns='http://www.opengis.net/kml/2.2'>\n  <Document>\n    <name><![CDATA[${name}]]></name>\n        ${styles}\n        <Folder><name><![CDATA[${name}]]></name>\n        ${folders}\n        </Folder>\n  </Document>\n</kml>\n`;\n\n\n/**\n * LineStyle Style renderer\n * @param {string} id - the style id, exemple: 'my-folder-name'\n * @param {string} color - kml color to use, inversed from web color: 641400FF for #FF0014 with 100% opacity\n * @param {number|string} [width=6] - the width of the line, set to 2 for Avenza\n * @returns {string}\n */\nexport const styleTemplate = ({id, color, width=6}) => `\n    <Style id=\"${id}\">\n        <LineStyle>\n            <width>${width}</width>\n            <color>${color}</color>\n        </LineStyle>\n    </Style>\n`;\n\nexport const avenzaStyleTemplate = ({id, color, width=3}) => styleTemplate({id, color, width});\nexport const googleEarthStyleTemplate = ({id, color, width=2}) => ((id === 'rnat') ? styleTemplate({id, color, 'width': 1}) : styleTemplate({id, color, width}));\n\n/**\n * IconsStyle Style renderer\n * @param {string} id - the style id, exemple: \"placemark-red\"\n * @param {string} href - url of the icons (not used by mapsme)\n * @param {string} [x=\"0.5\"] - hotspot zone x\n * @param {string} [y=\"0.0\"] - hotspot zone y, set to \"0.5\" for Avenza\n * @returns {string}\n */\nexport const iconTemplate = ({id, href, x=\"0.5\", y=\"0.0\"}) => ((href) ? `\n    <Style id=\"${id}\">\n      <IconStyle>\n          <Icon>\n              <href><![CDATA[${href}]]></href>\n          </Icon>\n          <hotSpot x=\"${x}\"  y=\"${y}\" xunits=\"fraction\" yunits=\"fraction\"/>\n      </IconStyle>\n    </Style>\\n` : `<Style id=\"${id}\"></Style>\\n`);\n\nexport const avenzaIconTemplate = ({id, href, x=\"0.5\", y=\"0.5\"}) => iconTemplate({id, href, x, y});\n","/* eslint-disable max-lines */\nimport {GOOGLEICONS, PINS, PIN_NONE} from \"./kml_constants\";\nimport {\n    folderTemplate, iconTemplate, lineTemplate, pointTemplate, segmentTemplate, styleTemplate, template\n} from \"./kml_templates\";\n\n/**\n * KMLFolder class\n * this a KML folder representation optimized for recreating live the KML:\n * @property {boolean} enabled - toggle the linestring visibility\n * @property {number} pin - change placemark icon style\n */\nconst pinProp = Symbol('pin private property');\n\nclass KMLFolder {\n\n    /**\n     * create a folder\n     * @param {string} name\n     * @param {Object} options - options is send to the kml renderer\n     * @param {number} [options.pinId] - the pinId used by this folder\n     * @param {boolean} [options.enabled=true] - show/hide this folder output's\n     */\n    constructor(name, options={}){\n        this.name = name;\n        this.options = options;\n        this.linestrings = []; // {String[]}\n        this.placemarks = []; // {Object[]}\n        this.lineStyle = {};\n        this[pinProp] = (options.pinId === undefined) ? PIN_NONE : options.pinId;\n        this.enabled = (options.enabled === undefined) ? true : options.enabled;\n    }\n    get pin() {\n        return this[pinProp];\n    }\n\n    /**\n     * empty the folder data\n     */\n    empty(){\n        this.linestrings = [];\n        this.placemarks = [];\n    }\n\n    /**\n     * set a new default pin value for the folder\n     * @param {number} newValue - the new pin to use\n     */\n    set pin(newValue){\n        const oldStyle = PINS[this[pinProp]];\n        this[pinProp] = newValue;\n        const newStyle = PINS[newValue];\n        //replace all styles using oldStyle with newStyle\n        this.placemarks = this.placemarks.map(o => {\n            if (o.style === oldStyle) {\n                o.style = newStyle;\n            }\n            return o;\n        });\n    }\n}\n\n/**\n * KMLGenerator class\n * it's a virtual representation of kml elements\n *\n * The python version filter elements on input.\n * To allow reactive rendering, here we filter elements on output\n *\n * Change\n */\nclass KMLGenerator {\n\n    /**\n     * Create a KML generator\n     * @param {Object} [renderers]\n     * @param {function} [renderers.template=template] - global template renderer\n     * @param {function} [renderers.pointTemplate=pointTemplate] - placemark rendere\n     * @param {function} [renderers.lineTemplate=lineTemplate] - linestring renderer\n     * @param {function} [renderers.folderTemplate=folderTemplate] - folder renderer\n     * @param {function} [renderers.styleTemplate=styleTemplate] - style renderer for linestring\n     * @param {function} [renderers.iconTemplate=iconTemplate] - style renderer for placemarks\n     * @param {function} [renderers.segmentTemplate=segmentTemplate] - linestring segments renderer\n     * @param {function} [renderers.icons=GOOGLEICONS] - icons (pins) to use\n     */\n    constructor(renderers={}) {\n        this.folders = new Map();\n        this.template = renderers.template || template;\n        this.pointTemplate = renderers.pointTemplate || pointTemplate;\n        this.lineTemplate = renderers.lineTemplate || lineTemplate;\n        this.folderTemplate = renderers.folderTemplate || folderTemplate;\n        this.styleTemplate = renderers.styleTemplate || styleTemplate;\n        this.iconTemplate = renderers.iconTemplate || iconTemplate;\n        this.segmentTemplate = renderers.segmentTemplate || segmentTemplate;\n        this.icons = renderers.icons || GOOGLEICONS;\n        this.name = undefined;\n    }\n\n    /**\n     * replace common invalid xml characters from a string\n     * @param {string} text\n     * @returns {string}\n     */\n    static escape (text) {\n        return text\n            .replace(\"&\", \"&amp;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\"<\", \"&lt;\")\n            .replace(\">\", \"&gt;\")\n            .replace(\"\\\"\", \"&quot;\");\n    }\n\n    /**\n     * determine style using pin[options.style]/options.style/#folderName\n     * @param {string} folderName\n     * @param {?Object} options\n     * @param {string|number} [options.style]\n     * @param {boolean} [folderPinInherit=false] - consider folder pin if defined\n     * @returns {Object} options - new options to use\n     */\n    computeOptions (folderName, options={}, folderPinInherit=false) {\n        options = {...options}; // work on a copy\n        if (folderPinInherit && options.style === undefined) {\n            let {style = this.folders.get(folderName).pin} = options;\n            options.style = style;\n        }\n        if (options.style === undefined) {\n            options.style = '#' + folderName;\n        } else if (!isNaN(options.style)) {\n            options.style = PINS[options.style];\n        }\n        return options; // return a copy of options with a style override\n    }\n\n    /**\n     * add a folder in our virtual kml\n     * @param {string} name\n     * @param {Object} options - options passed to the template\n     * @param {number} [options.pinId=0] - the pin identifier\n     */\n    addFolder (name, options={}) {\n        // create a folder entry and add necessary styles\n        let folder = new KMLFolder(name, options);\n        this.folders.set(name, folder);\n        let value = {'id': name, 'color': name + '_color'};\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * add multiple folders in our virtual kml\n     * @param {...{string|Object}} items - ...{name, [pin=0], ...}\n     * @param {string} items.name - folder name\n     * @param {number} [items.pinId=0] - folder pinId\n     */\n    addFolders (...items) {\n        for (let value of items) {\n            if (typeof(value) === 'string' || value instanceof String){\n                this.addFolder(value);\n            } else {\n                let clone = {...value}; // get a copy\n                Reflect.deleteProperty(clone, \"name\");\n                this.addFolder(value.name, clone);\n            }\n        }\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addLine(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        let value = {\n            'name': options.name || route.name,\n            'style': options.style,\n            'description': options.description || route.description\n        };\n        this.folders.get(folderName).linestrings.push(\n            this.renderLine(route.points, {...value, ...options})); //options override value\n\n    }\n\n    /**\n     * add route as points in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     * @param {Array} [options.excluded=[]] - a list of points to omit\n     */\n    addPoints(folderName, route, options={}) {\n        const excluded = options.excluded || [];\n        options = this.computeOptions(folderName, options, true);\n        for (let point of route.points) {\n            if (excluded.indexOf(point) >= 0) {\n                options.style = PIN_NONE;\n            }\n            this.addPoint(folderName, point, options);\n        }\n    }\n\n    /**\n     * add a point to a folder\n     * @param {string} folderName\n     * @param {GeoPoint} point\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value (with folder pin's inheritance)\n     */\n    addPoint ( folderName, point, options={}) {\n        options = this.computeOptions(folderName, options, true);\n        // as each point may have a dynamic style option,\n        // we delegate the rendering to the folder by storing objects instead of string\n        this.folders.get(folderName)\n            .placemarks.push({point, ...options});\n    }\n\n    /**\n     * add a route as line in a folder\n     * @param {string} folderName\n     * @param {Route} route\n     * @param {?Object} [options] - options is passed to the kml template\n     * @param {string|number} [options.style] - style will be computed based on this value\n     */\n    addSegments(folderName, route, options={}) {\n        options = this.computeOptions(folderName, options);\n        for (let [p1, p2] of route.segments){\n            const label = route.name || folderName;\n            const value = {\n                'name': `${label}: ${p1.name || p1.dm}->${p2.name || p2.dm}`,\n            }\n            this.folders.get(folderName).linestrings.push(\n                this.renderLine([p1, p2], {...value, ...options}, true));// options override value\n        }\n    }\n\n    /**\n     * render the whole KML\n     * @param {Route} route\n     * @param {?Object} [options={}] - options is passed to the kml templates\n     * @returns {string}\n     */\n    render(options={}){\n        let styles = '';\n        const renderIconTemplate = options.iconTemplate || this.iconTemplate;\n        const renderStyleTemplate = options.styleTemplate || this.styleTemplate;\n        const renderTemplate = options.template || this.template;\n        const renderIcons = options.icons || this.icons;\n        PINS.forEach((value, index) => {\n            if (index !== 0) {\n                value = {'id': PINS[index].slice(1), 'href': renderIcons[index]};\n                styles += renderIconTemplate({...value, ...options});\n            }\n        });\n\n        for (let [,folder] of this.folders){\n            if (folder.enabled) {\n                styles += renderStyleTemplate(folder.lineStyle)\n            }\n        }\n        if (!options.name) options.name = this.name;\n        return renderTemplate({...options, \"styles\": styles, \"folders\": this.renderFolders()});\n    }\n\n    /**\n     * render a single folder\n     * @param {string|KMLFolder} folder - accepts a name or a Map iteration element\n     * @returns {string}\n     */\n    renderFolder (folder, renderer=this.folderTemplate){\n        if (typeof(folder) === 'string' || folder instanceof String) {\n            folder = this.folders.get(folder);\n        }\n        if (!folder.enabled) return '';\n        // linestrings never change the folder is simply enabled or disabled\n        // placemarks are dynamic due to the excluded parameter\n        let placemarks = [];\n        if (folder.pin === PIN_NONE || folder.pin === undefined){\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE] && o.style !== undefined);\n        } else {\n            placemarks = folder.placemarks\n                .filter(o => o.style !== PINS[PIN_NONE]);\n        }\n        let value = {\n            \"name\": folder.name,\n            \"content\": folder.linestrings.concat(\n                placemarks.map(o => this.pointTemplate(o, o.style)))\n                .join('\\n')\n        };\n        return renderer({...value, ...folder.options});\n    }\n\n    /**\n     * render all folders\n     * @returns {string}\n     */\n    renderFolders () {\n        let output = [];\n        for (let [, folder] of this.folders) {\n            output.push(this.renderFolder(folder));\n        }\n        return output.join('\\n');\n    }\n\n    /**\n     * line/segment renderer\n     * @param {GeoPoint[]} points\n     * @param {?Object} [options={}] - options is passed to the kml template\n     * @param {boolean} isSegment - determine the template: segment or line\n     * @returns {string}\n     */\n    renderLine (points, options={}, isSegment=false){\n        const tpl = (p) => `${p.longitude.toFixed(6)},${p.latitude.toFixed(6)}`;\n        const coordinates = points.map(p => tpl(p)).join(' ');\n        const value = {...options, coordinates};\n        return isSegment ? this.segmentTemplate(value) : this.lineTemplate(value);\n    }\n\n    /**\n     * Change the Style of a folder, thus changing color\n     * @param {string} name\n     * @param {string} color\n     * @param {Object} [options] - additional options passed to the template\n     */\n    changeFolderColor(name, color, options={}){\n        const value = {'id': name, 'color': color};\n        const folder = this.folders.get(name);\n        folder.lineStyle = {...value, ...options};\n    }\n\n    /**\n     * Change folder pin shortcut\n     * @param {string} name\n     * @param {number} pin - the pin id\n     */\n    changeFolderPin(name, pin){\n        this.folders.get(name).pin = pin\n    }\n\n    /**\n     * Change folder state shortcut\n     * @param {string} name\n     * @param {boolean} enabled - enable or disable folder\n     */\n    changeFolderState(name, enabled){\n        this.folders.get(name).enabled = enabled;\n    }\n\n    /**\n     * reset KML Generator\n     */\n    reset(){\n        for (let [, folder] of this.folders){\n            folder.empty();\n        }\n    }\n\n    /**\n     * set the default name inserted in template\n     * @param {string} name the name/description\n     */\n    setName(name) {\n        this.name = name;\n    }\n}\n\nexport {KMLGenerator};\n","import {GeoPoint, dm_normalizer} from \"./geopoint\";\n\n/**\n * Exception thrown when a search term is not found\n */\nclass StringExtractException extends Error {}\n\n/**\n * Defines an extract method on the String prototype\n * Extract text between start and end mark\n * @param text: String\n * @param start: String\n * @param end: String\n * @param endIsOptional: if end is missing, captures till EOF\n * @param inclusive: if true, captures start and end\n * @return String\n */\nReflect.defineProperty(String.prototype, 'extract', {\n  value(start, end, endIsOptional = true, inclusive = false) {\n    let from = 0;\n    let to = 0;\n    if (start) {\n      from = this.indexOf(start);\n      if (from === -1) {\n        throw new StringExtractException(`${start} not found`);\n      }\n      if (!inclusive) {\n        from += start.length;\n      }\n    }\n    if (!end) {\n      return this.substring(from);\n    }\n    to = this.indexOf(end, from);\n    if (to === -1) {\n      if (endIsOptional) {\n        return this.substring(from);\n      }\n      throw new StringExtractException(`${end} not found`);\n    } else if (inclusive) {\n      to += end.length;\n    }\n    return this.substring(from, to);\n  }\n});\n\n\n/**\n * A matchAll RegExp to extract WPT COORDINATES from text\n * @return {GeoPoint[]}\n */\nclass WptRegExp extends RegExp {\n\n  /**\n   * matchAll methods to return an array of GeoPoint\n   * @param str\n   * @returns {GeoPoint[]}\n   */\n  [Symbol.matchAll](str) {\n    // eslint-disable-next-line prefer-reflect\n    let result = RegExp.prototype[Symbol.matchAll].call(this, str);\n    if (!result) {\n      console.error(\"WPT Coordinates regexp failed\");\n      return [];\n    }\n    let geoPoints = [];\n    Array.from(result).forEach((match) => {\n      let name = match[1].trim().replace(/^-+/u, \"\");\n      if (name === \"\") {\n        name = match[2] + match[3];\n      }\n      geoPoints.push(\n        new GeoPoint(\n          [match[2], match[3]],\n          {\"name\": name, \"normalizer\": dm_normalizer})\n      );\n    });\n    return geoPoints;\n  }\n}\nconst wptRegExp = new WptRegExp(String.raw`(\\S+|\\s+)\\s+([NS]\\d{4}\\.\\d)([EW]\\d{5}\\.\\d)`, 'gu');\n\nexport {wptRegExp};\n","/* eslint-disable complexity */\n/* eslint-disable max-lines-per-function */\n\nimport {GeoPoint} from './geopoint';\nconst AIRPORTS = require('./airports');\n\nconst months3 = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/**\n Dictionary of common OFP data:\n - flight (AF009)\n - departure (KJFK)\n - destination (LFPG)\n - datetime (a javascript Date object for scheduled departure block time)\n - date (OFP text date 25Apr2016)\n - datetime2 (a javascript Date object for scheduled arrival landing time)\n - duration [hours, minutes] hours and minutes are Number\n - ofp (OFP number 9/0/1)\n - alternates an array of alternate\n - ralts an array of route alternates (ETOPS)\n - taxitime (departure taxi time in mn)\n - rawfpl the raw text of the FPL\n - EEP the  ETOPS entry GeoPoint\n - EXP the ETOPS exit GeoPoint\n - raltPoints the ETOPS airports as GeoPoint\n - ETOPS the ETOPS time in minutes\n - fl average flight level or 300\n - levels = array of flight levels found in FPL or [300]\n * @param text The OFP in text format\n * @returns {{duration: number[], flight: string, datetime: Date, taxitime: number, destination: string, ofp: string, ralts: [], departure: string, alternates: [], rawfpl: string}}\n */\nfunction ofpInfos(text) {\n  let pattern = /(?<flight>AF\\s+\\S+\\s+)(?<departure>\\S{4})\\/(?<destination>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\d+\\S{0,8})/u;\n  let match = pattern.exec(text);\n  if (match === null) {\n    pattern = /(?<flight>AF.+)(?<departure>\\S{4})\\/(?<destination>\\S{4})\\s+(?<datetime>\\S+\\/\\S{4})z.*OFP\\s+(?<ofp>\\S+)Main/u;\n    match = pattern.exec(text);\n  }\n  let {flight, departure, destination, datetime, ofp} = match.groups;\n  // datetime is like 27Sep2019/1450\n  const [date] = datetime.split('/', 1);\n  const day = parseInt(datetime.substring(0,2), 10);\n  const month = months3.indexOf(datetime.substring(2,5));\n  const year = parseInt(datetime.substring(5,9), 10);\n  const hours = parseInt(datetime.substring(10,12), 10);\n  const minutes = parseInt(datetime.substring(12,14), 10);\n\n  const rawFplText = text\n    .extract(\"ATC FLIGHT PLAN\", \"TRACKSNAT\")\n    .extract(\"(\", \")\", false, true);\n\n  let duration = [1, 0];\n  pattern = new RegExp(String.raw`-TRIP\\s+[0-9]+[\\s.]+([0-9]{4})`, \"u\");\n  match = pattern.exec(text);\n  if (match === null){\n    pattern = new RegExp(String.raw`-${destination}(\\d{4})\\s`, \"u\");\n    match = pattern.exec(rawFplText);\n    duration = [1, 0];\n    if (match === null) {\n      console.log(\"flight duration not found, arbitrary set to 1 hour\");\n    }\n  }\n  duration = [\n    parseInt(match[1].substring(0,2), 10),\n    parseInt(match[1].substring(2,4), 10)\n  ];\n\n\n  // try with 2 alternates first\n  pattern = new RegExp(String.raw`-${destination}.+\\s(\\S{4})\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n  match = pattern.exec(rawFplText);\n  let alternates = [];\n  if (match !== null){\n    alternates.push(match[1]);\n    alternates.push(match[2]);\n  } else {\n     pattern = new RegExp(String.raw`-${destination}.+\\s(\\S{4})\\s?[\\n\\-]`, \"u\");\n     match = pattern.exec(rawFplText);\n     if (match !== null) {\n       alternates.push(match[1]);\n     }\n  }\n\n  pattern = /RALT\\/((?:\\S{4}[ \\n])+)/u;\n  match = pattern.exec(rawFplText);\n  let ralts = [];\n  if (match !== null) {\n    ralts = match[1].trim().split(/\\s/u);\n  }\n\n  let levels = [...rawFplText.matchAll(/F(\\d{3})\\s/ug)].map(v => (v[1]*1));\n  let fl = 300;\n  if (levels && levels.length) {\n      fl = Math.round(levels.reduce((a, b) => a + b, 0) / levels.length);\n  } else {\n    levels = [fl];\n  }\n  const rawFS = text.extract(\"FLIGHT SUMMARY\", \"Generated\");\n  pattern = /\\s(\\d{2})(\\d{2})\\s+TAXI IN/u;\n  match = pattern.exec(rawFS);\n  let taxitime = 15;\n  if (match === null) {\n    console.log(\"taxitime not found, arbitrary set to 15mn\");\n  } else {\n    taxitime = parseInt(match[1], 10) * 60 + parseInt(match[2], 10);\n  }\n\n  //aircraft type\n  let aircraft = \"???\";\n  const aircraftTypes = { // convert to Oliver Ravet codes\n    'A388': '380',\n    'B772': '772',\n    'B773': '773',\n    'B77W': '773',\n    'B77L': '77F',\n    'B788': '787',\n    'B789': '787',\n    'B78X': '787',\n    'A318': '318',\n    'A319': '319',\n    'A320': '320',\n    'A321': '321',\n    'A332': '330',\n    'A333': '330',\n    'A338': '330',\n    'A339': '330',\n    'A342': '340',\n    'A343': '340',\n    'A344': '340',\n    'A345': '340',\n    'A346': '340',\n    'A359': '350',\n    'A35K': '350'\n  }\n  pattern = /-([AB][0-9]{2}.)\\//u\n  match = pattern.exec(rawFplText);\n  if (match) {\n      aircraft = aircraftTypes[match[1]] || '???';\n  }\n  // aircraft registration\n  let registration = '';\n  pattern = /REG\\/(\\S+)/u\n  match = pattern.exec(rawFplText);\n  if (match) {\n      registration = match[1][0] + '-' + match[1].slice(1);\n  }\n  // icao24\n  let icao24 = '';\n  pattern = /CODE\\/(\\S+)/u\n  match = pattern.exec(rawFplText);\n  if (match) {\n    icao24 = match[1];\n  }\n  // eslint-disable-next-line init-declarations\n  let exp;\n  // eslint-disable-next-line init-declarations\n  let eep;\n  let etopsTime = 0;\n  if (ralts.length > 0) {\n      pattern = /ETOPS\\s+(\\d{3})\\s/u\n      match = pattern.exec(rawFS);\n      if (match) {\n        etopsTime = parseInt(match[1], 10);\n      } else {\n        try {\n          match = pattern.exec(text.extract('FPL SUMMARY', 'Generated'));\n          if (match) {\n            etopsTime = parseInt(match[1], 10);\n          }\n        } catch (err) {\n          console.log(\"ETOPS range not found\");\n        }\n      }\n      const etopsSummary = text.extract(\"ETOPS SUMMARY\", \"Generated\");\n      pattern = /EEP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        eep = match[1];\n      }\n      pattern = /EXP\\((\\S{4})\\)/u;\n      match = pattern.exec(etopsSummary);\n      if (match) {\n        exp = match[1];\n      }\n  }\n  const infos = {\n    \"flight\": flight.replace(/\\s/gu, \"\"),\n    \"departure\": departure,\n    \"destination\": destination,\n    \"datetime\": new Date(Date.UTC(year, month, day, hours, minutes)),\n    \"takeoff\": new Date(Date.UTC(year, month, day, hours , minutes + taxitime)),\n    \"landing\": new Date(Date.UTC(year, month, day, hours + duration[0], minutes + duration[1] + taxitime)),\n    \"datetime2\": new Date(Date.UTC(year, month, day, hours + duration[0], minutes + duration[1] + taxitime)), //backward compatibility\n    \"date\": date,\n    \"ofp\": ofp.replace(\"\\xA9\", \"\"),\n    \"duration\": duration,\n    \"alternates\": alternates,\n    \"ralts\": ralts,\n    \"raltPoints\": [],\n    \"taxitime\": taxitime,\n    \"rawfpl\": rawFplText,\n    aircraft,\n    registration,\n    icao24,\n    \"EEP\": null,\n    \"EXP\": null,\n    \"ETOPS\": etopsTime,\n    fl,\n    levels\n  }\n  try {\n    infos['raltPoints'] = [];\n    for (const v of ralts) {\n      if (v && AIRPORTS[v]) {\n        infos['raltPoints'].push(new GeoPoint(AIRPORTS[v], {'name': v, 'description': 'ETOPS'}));\n      } else {\n        console.error('missing airport', v);\n      }\n    }\n    if (eep && AIRPORTS[eep]) {\n      infos['EEP'] = new GeoPoint(AIRPORTS[eep], {'name': eep, 'description': 'EEP'});\n    } else if (eep){\n      console.error('missing airport', eep);\n    }\n    if (exp && AIRPORTS[exp]) {\n      infos['EXP'] = new GeoPoint(AIRPORTS[exp], {'name': exp, 'description': 'EXP'});\n    } else if (exp){\n      console.error('missing airport', exp);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n  return infos\n}\nexport {ofpInfos};\n","/* eslint-disable no-underscore-dangle,max-lines-per-function, max-lines */\n\nimport {GeoPoint, arinc_normalizer} from \"./geopoint\";\nimport {Route, Track} from \"./route\";\nimport {wptRegExp} from \"./ofp_extensions\";\n// eslint-disable-next-line sort-imports\nimport {ofpInfos} from \"./ofp_infos\";\n\n\nconst pdfParsers = Object.freeze({\n  \"pypdf2\": 3,\n  \"pdfjs\": 4\n});\n\nconst ofpTypes = Object.freeze({\n  \"S4\": 1,\n  \"NVP\": 2\n});\n\nconst FISHPOINTS = require('./fishpoints');\n\nexport class Ofp {\n  constructor(text=\"\") {\n    console.assert(text.startsWith(\"_PDFJS_\"), \"invalid text file\");\n    this.pdfParser = pdfParsers.pdfjs;\n    this.ofpType = ofpTypes.S4;\n    if (text.includes(\"--FLIGHT SUMMARY--\")) {\n      this.ofpType = ofpTypes.NVP;\n    }\n    try {\n      this.infos = ofpInfos(text);\n    } catch (error) {\n      console.error(error);\n      try {\n        if (window) {\n          // eslint-disable-next-line no-alert\n          window.alert(`Erreur: {error}` )\n        }\n      } catch (exception) {\n        // not in browser, just log\n      }\n      throw error;\n    }\n    this.removePageFooterRegex = new RegExp(String.raw`([\\s-]\\d{1,2})?Page\\s[0-9]+\\s.+?Page\\s[0-9]+.+?\\/${this.infos['departure']}-${this.infos['destination']}`, 'gsu');\n    this.text = text.replace(this.removePageFooterRegex,'');\n    this.cache = function (name, fn) {\n      if (this.cacheStore === undefined) {\n        this.cacheStore = {}; /* on first run create cache storage */\n      }\n      if (this.cacheStore[name] === undefined) {\n        this.cacheStore[name] = fn();\n      }\n      return this.cacheStore[name];\n    };\n  }\n\n  get description() {\n    const infos = this.infos;\n    return `${infos.flight} ${infos.departure}-${infos.destination} ${infos.date} ${infos.datetime.toISOString().substring(11,16)}z OFP ${infos.ofp}`;\n  }\n\n  /**\n   * Array of WPT COORDINATES found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinates(start=\"WPT COORDINATES\") {\n    const infos = this.infos;\n    const end = (this.ofpType === ofpTypes.NVP) ? '----' + infos['destination']: '----';\n    const extract = this.text.extract(start, end);\n    const geoPoints = extract.matchAll(wptRegExp);\n    if (geoPoints.length > 0) geoPoints[0].name = this.infos['departure']; // avoid name problems\n    return geoPoints;\n  }\n\n  /**\n   * Array of WPT COORDINATES for alternate found in OFP\n   * @param start the text marker for start (useful for tests)\n   * @param end the end marker for end (useful for tests)\n   * @returns {GeoPoint[]}\n   */\n  wptCoordinatesAlternate(start='WPT COORDINATES', end_is_optional=false) {\n\n    const end = (this.ofpType === ofpTypes.NVP) ? '--WIND INFORMATION--': 'ATC FLIGHT PLAN';\n    // take only what is after the last '----' (python rsplit)\n    // eslint-disable-next-line require-jsdoc\n    function reverse(str) {\n      return [...str].reverse().join('');\n    }\n    const t = this.text.extract(start, end, end_is_optional)\n    const extract = reverse(t).split('----', 1)[0];\n    return reverse(extract).matchAll(wptRegExp);\n  }\n\n  wptNamesEET(geoPoints) {\n    const start = 'ATC DEPARTURE';\n    const pattern = /[\\s-]([A-Z0-9/]+)\\s+[0-9]{3}\\s+(?:[0-9.\\s]{4})\\s+\\.\\.\\.\\.\\/\\.\\.\\.\\.\\s(.{3})\\s[A-Z0-9/.+\\s-]+?[0-9]{4}\\/([0-9]{4})\\s+[0-9]{3}\\/[0-9]{3}/gu;\n    const extract = this.text.extract(start, 'DESTINATION ALTERNATE', true);\n    const matches = extract.matchAll(pattern);\n\n    const eet = {};\n    let previousEET = 0;\n    // eslint-disable-next-line init-declarations\n    let previousFL = this.infos.levels[0];\n    for (let [,name, level, t,] of matches) {\n      //console.log(name)\n      if (name.startsWith('/')) name = name.slice(1); // ofp AF082\n      const fl = parseInt(level, 10);\n      if (!isNaN(fl)) previousFL = fl;\n      eet[name.split('/')[0]] = [previousEET, previousFL];\n      previousEET = (parseFloat(t.slice(0,2)) * 60) + parseFloat(t.slice(2))\n    }\n    eet[this.infos['destination']] = [previousEET, previousFL];\n    //console.log(eet);\n    const results = [];\n    let error = false;\n    for (const p of geoPoints) {\n      if (eet[p.name] === undefined) {\n          let altname = p.name.replace(/00\\.0/gu,'')\n          if (eet[altname] === undefined) {\n              altname = p.name.replace(/\\.0/gu,'')\n              if (eet[altname] === undefined) {\n                console.log('missing point', p.name);\n                error = true;\n                break;\n              } else {\n                results.push([p, ...eet[altname]]);\n              }\n          } else {\n            results.push([p, ...eet[altname]])\n          }\n      } else {\n          results.push([p, ...eet[p.name]])\n      }\n    }\n    return (error) ? [] : results;\n  }\n\n  /**\n   * check if the designated track is in the FPL\n   * @param letter\n   * @returns {boolean}\n   */\n  isMyTrack(letter) {\n    return this.fplRoute.indexOf(Track.label(letter)) !== -1;\n  }\n\n  /**\n   * Parse the OFP and return tracks as an array of [trackLetter, trackDescription]\n   * @returns {[]}\n   */\n  trackParser() {\n    let extract = \"\";\n    try {\n      extract = this.text\n        .extract(\"ATC FLIGHT PLAN\", \"NOTES:\").extract(')');\n    } catch (e) {\n      return [];\n    }\n    let results = [];\n    if (extract.includes(\"REMARKS:\")) {\n      extract = extract.split(\"REMARKS:\", 1)[0];\n      extract = extract.split(\"Generated at\", 1)[0];\n    }\n    if (extract.includes(\" LVLS \")) {\n      // split at track letter, discard first part\n      const a = extract.split(/(?:\\s|[^A-Z\\d])([A-Z])\\s{3}/gu).slice(1);\n      // results are [trackLetter, trackDescription]\n      for (let i = 0, max = a.length; i < max; i += 2) {\n        results.push([a[i], a[i + 1]]);\n      }\n    } else if (extract.includes('TRACKS')) {\n      console.error(\"Unknown TRACKSNAT message format\");\n      console.log(extract);\n    }\n    return results;\n  }\n\n  /**\n   * Tracks found in the OFP as an array of Track\n   * @returns {Track[]}\n   */\n  get tracks() {\n    return this.cache(\"tracks\", () => {\n      let parserResults = this.trackParser();\n      const pattern = /(\\d{2,4}[NS]\\d{3,5}[EW]|[NESW]\\d{4}|\\d[NESW]\\d{3}[^EW])/u;\n      let fishPoints = {};\n      let tracks = [];\n\n      //find unknows named waypoints in tracks\n      let unknowns = [];\n      // eslint-disable-next-line array-callback-return\n      parserResults.map(([, description]) => {\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) === null) {\n                unknowns.push(label);\n              }\n            }\n          });\n      });\n      // console.debug(`Unknown track points: ${unknowns}`);\n      unknowns.forEach((name) => {\n        const f = FISHPOINTS[name];\n        if (f !== undefined) {\n          fishPoints[name] = new GeoPoint(f, {\"name\": name});\n        }\n      });\n\n      parserResults.forEach(([letter, description]) => {\n        let trackRoute = [];\n        let trackIsComplete = true;\n        const isMine = this.isMyTrack(letter);\n        let labelDict = (isMine) ? {} : fishPoints;\n        if (isMine) {\n          this.route.points.forEach((g) => {\n            if (g.name !== \"\") {\n              labelDict[g.name] = g\n            }\n          })\n        }\n        description.split(\" LVLS \", 1)[0].split(\" \")\n          .forEach((p) => {\n            const label = p.trim();\n            if (label !== \"\") {\n              if (pattern.exec(label) !== null) {\n                trackRoute.push(new GeoPoint(label, {\n                  \"name\": label,\n                  \"normalizer\": arinc_normalizer\n                }));\n              } else {\n                let geoPoint = labelDict[label];\n                if (geoPoint !== undefined) {\n                  trackRoute.push(new GeoPoint(geoPoint, {\"name\": label}));\n                } else {\n                  trackIsComplete = false;\n                }\n              }\n            }\n          });\n        tracks.push(new Track(trackRoute,\n          {\n            \"name\": `NAT ${letter}`,\n            \"description\": description,\n            \"isMine\": isMine,\n            \"isComplete\": trackIsComplete\n          }));\n      });\n      return tracks;\n    });\n  }\n\n  /**\n   * Returns FPL as an Array\n   * @returns {string[]}\n   */\n  fpl() {\n    const infos = this.infos;\n    let text = infos.rawfpl\n      .extract(`-${infos.departure}`, `-${infos.destination}`, false);\n    text = text.substring(text.indexOf(\" \") + 1);\n    let results = [infos.departure];\n    text.split(\" \").map((v) => v.trim())\n      .forEach((v) => {\n        if (v !== \"\" && !v.startsWith(\"-N\")){\n          results.push(v);\n        }\n      });\n    results.push(infos.destination);\n    return results;\n  }\n\n  /**\n   * FPL route found in OFP (fpl without speed/FL annotations)\n   * @returns {string[]}\n   */\n  get fplRoute() {\n    return this.cache(\"fplRoute\",\n      () => this.fpl().map((p) => {\n        if (p.includes(\"/\")) {\n          return p.split(\"/\", 1)[0];\n        }\n        return p;\n      })\n    );\n  }\n\n  get route() {\n    return this.cache(\"route\", () => new Route(this.wptCoordinates()));\n  }\n\n  lidoRoute(replaceSID=true) {\n    return this.cache(\"lidoRoute\" + ((replaceSID) ? \"_r\" : \"\"), () => {\n      const points = [];\n      const pointsName = []; // used if replaceSID === false\n      const rawPoints = []; // used if replaceSID === true\n      this.route.points.forEach((p) => {\n        rawPoints.push(p.dm);\n        pointsName.push(p.name || p.dm);\n        if (p.name === \"\" || (/\\d+/u).exec(p.name) !== null) {\n          points.push(p.dm);\n        } else {\n          points.push(p.name);\n        }\n      });\n      let lidoPoints = [];\n\n      let fplRoute = this.fplRoute;\n      let fplRouteLenght = fplRoute.length;\n      if (fplRouteLenght < 2) {\n        return points;\n      }\n      let departure = fplRoute[0];\n      let destination = fplRoute[fplRouteLenght - 1];\n      let innerFplRoute = fplRoute.slice(1, -1);\n      let innerFplRouteLength = innerFplRoute.length;\n\n\n      // replace points by rawPoint before first common waypoint\n      for (let i = 0; i < innerFplRouteLength; i += 1 ) {\n        let p = innerFplRoute[i];\n        let offset = points.indexOf(p);\n        if (offset !== -1) {\n          if (replaceSID) {\n            lidoPoints = rawPoints.slice(1, offset).concat(innerFplRoute.slice(i));\n          } else {\n            lidoPoints = pointsName.slice(1, offset).concat(innerFplRoute.slice(i));\n          }\n          break;\n        }\n      }\n      // replace points after last common waypoint by rawPoints\n      let reversedPoints = points.slice().reverse(); // copy before reverse\n      let reversedLidoRoute = lidoPoints.slice().reverse();\n      let lidoRouteLength = lidoPoints.length;\n      for (let i = 0; i < lidoRouteLength; i += 1 ) {\n        let p = reversedLidoRoute[i];\n        let offset = reversedPoints.indexOf(p);\n        if (offset !== -1) {\n          if (i > 0) {\n            lidoPoints = lidoPoints.slice(0, -i);\n          }\n          if (replaceSID) {\n            lidoPoints = lidoPoints.concat(rawPoints.slice(-offset, -1));\n          } else {\n            lidoPoints = lidoPoints.concat(pointsName.slice(-offset, -1));\n          }\n          break;\n        }\n      }\n      // replace known tracks (NATA, NATB...) by track_points\n      /**\n       * When there is a FL or Speed change, we may have multiple\n       * \"NATW\" in the FPL, so change them all.\n       * @param fplPoints: [] - an array of fplPoints\n       * @param needle: string\n       * @param trackPoints\n       * @returns {[]}\n       */\n      const recursiveNatReplace = function (fplPoints, needle, trackPoints) {\n        let match = [];\n        // infinite loop (while(true) breaks in browser)\n        // https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript\n        for (;;) {\n          let offset = fplPoints.indexOf(needle);\n          if (offset === -1) {\n            return match;\n          }\n          fplPoints.splice(offset, 1, ...trackPoints.slice(\n            trackPoints.indexOf(fplPoints[offset - 1]) +1,\n            trackPoints.indexOf(fplPoints[offset + 1])));\n          match = fplPoints;\n        }\n      };\n\n      this.tracks.forEach( (track) => {\n        if (track.isMine) {\n          let letter = track.name.slice(-1);\n          let results = recursiveNatReplace(\n            lidoPoints,\n            Track.label(letter),\n            track.points.map((p) => p.name)\n          );\n          if (results.length > 0) {\n            lidoPoints = results;\n          }\n        }\n      });\n      lidoPoints.push(destination);\n      lidoPoints.unshift(departure);\n      // adds alternates and ralts\n      lidoPoints = lidoPoints.concat(...this.infos.alternates);\n      lidoPoints= lidoPoints.concat(...this.infos.ralts);\n      return lidoPoints;\n    });\n  }\n}\n","import {GeoPoint, km_to_rad} from \"./geopoint\";\nimport geohash from \"ngeohash\";\n\n// dependence between hashtag's precision and distance accurate calculating\n// in fact it's sizes of grids in km\nexport const GEO_HASH_GRID_SIZE = {\n    \"1\": 5000.0,\n    \"2\": 1260.0,\n    \"3\": 156.0,\n    \"4\": 40.0,\n    \"5\": 4.8,\n    \"6\": 1.22,\n    \"7\": 0.152,\n    \"8\": 0.038\n}\n\nexport class GeoGridIndex {\n    constructor(precision=3) {\n        this.precision = precision;\n        this.gridSize = km_to_rad(GEO_HASH_GRID_SIZE[precision.toString()]);\n        this.data = {};\n    }\n\n    /**\n     * Get Nearest points based on the geohash of the point\n     * It returns all wmo points in the 9 adjacents tiles\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians (unless a converter is given)\n     * @param {?function} converter\n     * @generator {GeoPoint}\n     */\n    *getNearestPointsDirty(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        if (radius > this.gridSize / 2.0) {\n            // radius is too big for current grid, we cannot use 9 neighbors\n            // to cover all possible points\n            let suggestedPrecision = 0;\n            for (const [precision, maxSize] of Object.entries(GEO_HASH_GRID_SIZE)) {\n                if (radius > km_to_rad(maxSize) / 2.0) {\n                    suggestedPrecision = parseInt(precision, 10) - 1;\n                    break;\n                }\n            }\n            throw new Error(`Too large radius, please rebuild GeoHashGrid with precision=\"${suggestedPrecision}\"`);\n        }\n        const centerHash = geohash.encode(centerPoint.latitude, centerPoint.longitude, this.precision);\n        let meAndNeighbors = geohash.neighbors(centerHash);\n        meAndNeighbors.push(centerHash);\n        for (const hash of meAndNeighbors) {\n            if (hash in this.data) {\n                for (const [name, latitude, longitude] of this.data[hash]) {\n                    yield new GeoPoint([latitude, longitude], {\"name\": name});\n                }\n            }\n        }\n    }\n\n    /**\n     * find nearest wmo points. Returns an array of [[distance, GeoPoint]]\n     * @param {GeoPoint} centerPoint\n     * @param {number} radius the radius in radians unless a converter is set\n     * @param {?function} converter fn return radians\n     * @returns {{[number, GeoPoint]}} distance from centerPoint and a GeoPoint of the wmo\n     */\n    *getNearestPoints(centerPoint, radius, converter=km_to_rad) {\n        if (converter !== null) {\n            radius = converter(radius);\n        }\n        for (const geoPoint of this.getNearestPointsDirty(centerPoint, radius, null)) {\n            let distance = geoPoint.distanceTo(centerPoint, null);\n            if (distance <= radius) {\n                if (converter !== null) {\n                    distance /= converter(1.0);\n                }\n                yield [geoPoint, distance];\n            }\n        }\n    }\n}\n","/* eslint-disable max-lines-per-function */\nimport {km_to_rad, rad_to_km} from \"./geopoint\";\nimport {Route} from \"./route\";\n\n/**\n * Compute the Ogimet Route\n * @param {editolido.Route} route the route to find the ogimet route for\n * @param {number} segmentSize the result is split to this length\n * @param {string} name the name of the returned route\n * @param {string} description the description of the returned route\n */\nexport function ogimetRoute(wmoGrid, route, {name=\"\", description=\"\", segmentSize=300, algorithm='xtd'} = {}) {\n    const neighbourRadius = (rad_to_km(wmoGrid.gridSize) / 2.0) - 0.1\n\n    const getNeighbour = (point) => {\n        let neighbours = [...wmoGrid.getNearestPoints(point, neighbourRadius)];\n        if (neighbours.length > 0) {\n            neighbours = neighbours.sort((a, b) => a[1] - b[1]);\n            if (neighbours.map((a) => a[0].name).indexOf(point.name) >= 0) {\n                return [point, 0];\n            }\n            return [neighbours[0][0], neighbours[0][1]];\n        }\n        return [null, null];\n    };\n    const findStrategic = (start, end, results) => {\n        const length = results.length;\n        for (let k = end - 1; k > start; k -= 1) {\n            const o_xtd = results[k].ogimet.xtd_to(\n                [results[k].fpl, results[k + 1].fpl]\n            );\n            const f_xtd = results[k].fpl.xtd_to(\n                [results[start].ogimet, results[end].ogimet]\n            )\n            if (Math.abs(f_xtd) > Math.abs(o_xtd)) {\n                const d = (k < length - 1) ? results[k].fpl.distanceTo(results[k+1].fpl) : -1;\n                if (Math.abs(f_xtd) < d || d < 0) return k;\n            }\n        }\n        return null;\n    };\n\n    const filterByXtd = (results) => {\n        if (results.length === 0) return [];\n        const res = [results[0]];\n        let i = -1;\n        while (i < results.length - 1) {\n            i += 1;\n            let j = i + 2;\n            while (j <= results.length - 1) {\n                let k = findStrategic(i, j, results);\n                if (k === null) {\n                    j += 1;\n                } else {\n                    if (res.map((r) => r.ogimet.name).indexOf(results[k].ogimet.name) < 0) {\n                        res.push(results[k]);\n                    }\n                    i = k - 1;\n                    break;\n                }\n            }\n        }\n        res.push(results[results.length - 1]);\n        if (res.length < results.length) {\n            return filterByXtd(res);\n        }\n        return res;\n    };\n\n    // eslint-disable-next-line no-unused-vars\n    const lowestCrsIndex = (results) => {\n        let bestDiff = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const diff = Math.abs(\n                results[i - 1].ogimet.course_to(results[i].ogimet)\n                - results[i - 1].ogimet.course_to(results[i+1].ogimet)\n            );\n            if (best === null || diff < bestDiff) {\n                best = i;\n                bestDiff = diff;\n            }\n        }\n        return best;\n    };\n\n    const lowestXtdIndex = (results) => {\n        let bestXtd = 0;\n        let best = null;\n        let maxi = results.length - 1;\n        for (let i = 1; i < maxi; i += 1) {\n            const xtd = Math.abs(\n                results[i].fpl.xtd_to([results[i - 1].ogimet, results[i + 1].ogimet])\n            );\n            if (best === null || xtd < bestXtd) {\n                best = i;\n                bestXtd = xtd;\n            }\n        }\n        return best;\n    }\n\n    let ogimetResults = [];\n    const o_index = {};\n    for (const p of route.split(60, {'converter': km_to_rad, 'preserve': true}).points) {\n        const [neighbour, x] = getNeighbour(p);\n        if (neighbour !== null) {\n            if (neighbour.name in o_index) {\n                if (o_index[neighbour.name][0] > x) {\n                    o_index[neighbour.name] = [x, p];\n                }\n            } else {\n                o_index[neighbour.name] = [x, p];\n            }\n            ogimetResults.push({'fpl': p, 'ogimet': neighbour});\n        }\n    }\n\n    // eslint-disable-next-line eqeqeq\n    ogimetResults = ogimetResults.filter((r) => o_index[r.ogimet.name][1] == r.fpl);\n    ogimetResults = filterByXtd(ogimetResults);\n    //console.log(ogimetResults.length);\n    const reduceFn = (algorithm === 'xtd' ? lowestXtdIndex: lowestCrsIndex);\n    while (ogimetResults.length > 21) {\n        const idx = reduceFn(ogimetResults);\n        ogimetResults = ogimetResults.slice(0, idx).concat(ogimetResults.slice(idx + 1));\n    }\n    return new Route(ogimetResults.map((r) => r.ogimet))\n                .split(segmentSize, {'preserve': true, 'name': name, 'description': description});\n}\n\n/**\n * Computes ogimet url\n * @param {editolido.OFP} ofp the OFP\n * @param {editolido.GeoGridIndex} wmoGrid  the loaded Grid\n */\nexport function ogimetData(ofp, wmoGrid, algorithm=\"xtd\") {\n    // timestamp for departure\n    const taxitime = ofp.infos['taxitime'];\n    const ts = (ofp.infos['datetime'].getTime() / 1000) + (taxitime * 60);\n    const now_ts = (new Date()).getTime() / 1000;\n    const tref = Math.round(Math.max(ts, now_ts)); //for old ofp timeref=now\n    const trefOfp = new Date(Math.round(ts) * 1000);\n    // const dateref = new Date(tref * 1000); //for caching we use the ofp time instead\n    // https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\n    const dateTimeFormat = new Intl.DateTimeFormat('en', {'year': '2-digit', 'month': 'short', 'day': '2-digit', 'hour': '2-digit', 'minute': '2-digit', 'hourCycle': 'h24', 'timeZone': 'UTC'});\n    const [{'value': month},,{'value': day},,{'value': year},,{'value': hour},,{'value': minute}] = dateTimeFormat.formatToParts(trefOfp);\n    const name = `Route Gramet ${ofp.infos['flight']} ${ofp.infos['departure']}-${ofp.infos['destination']} ${day}${month}${year} ${hour}:${minute}z OFP ${ofp.infos['ofp']}`;\n    let hini = 0;\n    let hfin = ofp.infos['duration'][0] + 1;\n    const fl = ofp.infos['fl']; // average flight level\n    const route = ogimetRoute(wmoGrid, ofp.route,{name, algorithm});\n    const labels = route.points.filter(p => p.name !== \"\").map(p => p.name);\n    route.description = labels.join(' ');\n    const url = `http://www.ogimet.com/display_gramet.php?lang=en&hini=${hini}&tref=${tref}&hfin=${hfin}&fl=${fl}&hl=3000&aero=yes&wmo=${labels.join('_')}&submit=submit`;\n    const proxy = `${hini}-${Math.round(ts)}-${hfin}-${fl}-${labels.join('_')}`;\n    return {tref, name, route, 'wmo': labels, url, proxy};\n}\n","/* globals VERSION */\nexport const version = VERSION;\nexport {GeoPoint, nm_to_rad, rad_to_nm} from \"./modules/geopoint\"\nexport {AVENZAICONS, GOOGLEICONS, NAT_POSITION_ENTRY, NAT_POSITION_EXIT, PINS, PIN_BLUE, PIN_BROWN, PIN_GREEN, PIN_NONE, PIN_ORANGE, PIN_PINK, PIN_PURPLE, PIN_RED, PIN_YELLOW} from \"./modules/kml_constants\";\nexport {Route, Track} from \"./modules/route\"\nexport {googleEarthStyleTemplate, avenzaIconTemplate, avenzaStyleTemplate, avenzaTemplate, iconTemplate, styleTemplate, template} from \"./modules/kml_templates\";\nexport {KMLGenerator} from \"./modules/kml\";\nexport {Ofp} from \"./modules/ofp\";\nexport {GEO_HASH_GRID_SIZE, GeoGridIndex} from \"./modules/geoindex\";\nexport {ogimetRoute, ogimetData} from \"./modules/ogimet\";\n"],"sourceRoot":""}